---
layout: page
title: 'GNU Emacs integrated computing environment'
subtitle: 'My comprehensive "dotemacs" (.emacs) for GNU/Linux'
excerpt: "Protesilaos Stavrou's customisations for Emacs. These contribute to a consistent computing experience on top of GNU/Linux."
permalink: /emacs/dotemacs
redirect_from:
  - /dotemacs
---

<ul class="org-ul">
<li>Created: 2019-08-15</li>
<li>Updated: <b>2022-01-04 14:26 +0200</b>.</li>
<li>Emacs Version: GNU Emacs 29.0.50.</li>
<li>Git repository (part of my dotfiles for GNU/Linux):
<a href="https://gitlab.com/protesilaos/dotfiles">https://gitlab.com/protesilaos/dotfiles</a>.</li>
<li>File history:
<a href="https://gitlab.com/protesilaos/dotfiles/-/commits/master/emacs/.emacs.d/prot-emacs.org">https://gitlab.com/protesilaos/dotfiles/-/commits/master/emacs/.emacs.d/prot-emacs.org</a>.</li>
<li>Just the <code>*.el</code> version of this file:
<a href="https://gitlab.com/protesilaos/dotfiles/-/commits/master/emacs/.emacs.d/prot-emacs.el">https://gitlab.com/protesilaos/dotfiles/-/commits/master/emacs/.emacs.d/prot-emacs.el</a></li>
</ul>

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h:9ff13b78-42b8-49fe-9e23-0307c780de93">1. Overview</a>
<ul>
<li><a href="#h:0a9b72b3-aa4a-4c5c-a654-d4bc04b31bbd">1.1. Canonical links to this document</a></li>
<li><a href="#h:8cfd5674-4997-44c7-bb7a-1869d5d53538">1.2. What is this</a>
<ul>
<li><a href="#h:584c3604-55a1-49d0-9c31-abe46cb1f028">1.2.1. Main macros and other contents of my init.el (for Emacs 28)</a>
<ul>
<li><a href="#h:874944d8-7ac0-4115-aa21-6ff4e005f6f6">1.2.1.1. The "early init"</a></li>
</ul>
</li>
<li><a href="#h:f738cdfc-a6ff-46cb-9962-31f754280af5">1.2.2. About the source code version of this document</a></li>
</ul>
</li>
<li><a href="#h:1b9e6455-ba10-4683-88d4-738ecc41cdf6">1.3. COPYING</a></li>
</ul>
</li>
<li><a href="#h:4d42f3e3-e96f-4125-a819-0544a21d45f3">2. Base settings</a>
<ul>
<li><a href="#h:c82dcbfa-97d0-4f7c-85af-768ce90f1372">2.1. Common auxiliary functions (prot-common.el)</a></li>
<li><a href="#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb">2.2. Common custom functions (prot-simple.el)</a>
<ul>
<li><a href="#h:6bbc41d6-da7c-4301-84c6-c5887c29283f">2.2.1. prot-pulse.el (highlight cursor position)</a></li>
</ul>
</li>
<li><a href="#h:b24ce3fc-a12c-4d21-93d7-c1e7bd36a65d">2.3. Make Custom UI code disposable</a></li>
<li><a href="#h:abe40d9f-e454-442a-9b9a-77e3b6c0b5db">2.4. Propagation of shell environment variables (exec-path-from-shell.el)</a></li>
<li><a href="#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">2.5. Modus themes (my highly accessible themes)</a></li>
<li><a href="#h:601027a1-7288-4dcd-bb78-435965df27ba">2.6. LIN Is Noticeable (lin.el)</a></li>
<li><a href="#h:7a4dd5b8-724d-4f7c-b5ee-01d8ac98bda9">2.7. Typeface configurations</a>
<ul>
<li><a href="#h:e03b6415-a18f-4058-b9b0-5721d38c6c50">2.7.1. Font configurations (prot-fonts.el)</a></li>
<li><a href="#h:9035a1ed-e988-4731-89a5-0d9e302c3dea">2.7.2. Simple font suitability test</a></li>
</ul>
</li>
<li><a href="#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0">2.8. Repeatable key chords (repeat-mode)</a></li>
<li><a href="#h:1d0e8ab3-d779-41d4-b478-d735dc3ad7ae">2.9. Handle performance for very long lines (so-long.el)</a></li>
</ul>
</li>
<li><a href="#h:5c060e2e-231d-4896-a5d2-b3fb4134764e">3. Selection candidates and search methods</a>
<ul>
<li><a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">3.1. Completion framework and extras</a>
<ul>
<li><a href="#h:7b1374dd-6b1f-4548-8fbf-1034230c80e0">3.1.1. Orderless completion style (and prot-orderless.el)</a></li>
<li><a href="#h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40">3.1.2. Completion annotations (marginalia)</a></li>
<li><a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">3.1.3. Minibuffer configurations and my extras (mct.el)</a></li>
<li><a href="#h:2733674b-51f9-494e-b34d-e8842ac4ef96">3.1.4. Minibuffer history (savehist-mode)</a></li>
<li><a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">3.1.5. Enhanced minibuffer commands (consult.el and prot-consult.el)</a>
<ul>
<li><a href="#h:4c41ab10-9533-40b2-8c0a-e38b5f0194f6">3.1.5.1. Switch to directories (consult-dir.el)</a></li>
</ul>
</li>
<li><a href="#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">3.1.6. Extended minibuffer actions and more (embark.el and prot-embark.el)</a></li>
<li><a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">3.1.7. Projects (project.el and prot-project.el)</a>
<ul>
<li><a href="#h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055">3.1.7.1. Extra features for projects (project-x.el)</a></li>
</ul>
</li>
<li><a href="#h:5723c4bb-ff6c-449f-bb60-be66fab3f137">3.1.8. Completion for recent files and directories (prot-recentf.el)</a></li>
<li><a href="#h:98876022-57cc-40de-936e-4ee42cefd69a">3.1.9. In-buffer completions</a>
<ul>
<li><a href="#h:675ebef4-d74d-41af-808d-f9579c2a5ec4">3.1.9.1. Corfu (Completion Overlay Region FUnction) and CAPE</a></li>
<li><a href="#h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84">3.1.9.2. Dabbrev (dynamic word completion)</a></li>
<li><a href="#h:33cd69cc-1a50-4abb-9f09-cae98dc8998b">3.1.9.3. Abbreviations or Abbrevs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:67dac9fe-5c15-437d-bb3e-26b293affa45">3.2. Configurations for&#x2014;or extensions to&#x2014;built-in search commands</a>
<ul>
<li><a href="#h:b67687ee-25a3-4bf4-a924-180ccb63c629">3.2.1. Isearch, occur, grep, and extras (prot-search.el)</a></li>
<li><a href="#h:6c6759c8-3ae3-40b0-8356-05cc0975e12a">3.2.2. Test regular expressions (re-builder)</a></li>
<li><a href="#h:42624165-f4cb-4318-abce-c11232426880">3.2.3. wgrep (writable grep)</a></li>
<li><a href="#h:594bca38-542c-4aac-95f5-349f034c6802">3.2.4. Cross-references (xref.el)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:402cb0db-1e93-4b1f-8f6d-e17b4409fb86">4. Directory, buffer, window management</a>
<ul>
<li><a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">4.1. Dired file manager (and prot-dired.el extras)</a>
<ul>
<li><a href="#h:954adfb4-8f2c-4665-bb5b-e098926341b0">4.1.1. dired-like mode for the trash (trashed.el)</a></li>
</ul>
</li>
<li><a href="#h:137f16fe-4f88-4b4d-bd71-cd978c9fdcd5">4.2. Working with buffers</a>
<ul>
<li><a href="#h:17933226-27a8-47c0-80f9-3cc609aacae0">4.2.1. Keymap for buffers (Emacs28)</a></li>
<li><a href="#h:60a70340-49dc-4f45-b147-12a4141db42b">4.2.2. Unique names for buffers</a></li>
<li><a href="#h:06290f9c-491c-45b2-b213-0248f890c83d">4.2.3. Ibuffer and extras (dired-like buffer list manager)</a></li>
</ul>
</li>
<li><a href="#h:12591f89-eeea-4b12-93e8-9293504e5a12">4.3. Window configuration</a>
<ul>
<li><a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">4.3.1. Window rules and basic tweaks (window.el)</a></li>
<li><a href="#h:6b4f7792-6ccd-45d5-b262-01d200639072">4.3.2. Window history (winner-mode)</a></li>
<li><a href="#h:230d96c8-a955-4b82-844d-9de9a1b7c531">4.3.3. Directional window motions (windmove)</a></li>
<li><a href="#h:63ad472f-c9c2-40ad-9675-1dc529487788">4.3.4. Tabs for window layouts (tab-bar.el and prot-tab.el)</a></li>
<li><a href="#h:753ea060-57e4-4dba-9bf9-b6337e478839">4.3.5. Transposition and rotation of windows</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:fa8bd8af-de14-489b-bc56-1a9bb3ef9f0f">5. Applications and utilities</a>
<ul>
<li><a href="#h:79cd6177-a81b-420f-8759-e6927b974377">5.1. Built-in bookmarking framework (bookmark.el and prot-bookmark.el)</a>
<ul>
<li><a href="#h:67b7944e-6398-44a8-91d6-79e423b3e5f1">5.1.1. Ibuffer-like bookmark list (blist.el)</a></li>
</ul>
</li>
<li><a href="#h:77d14350-978d-4820-ab7f-4641706c445a">5.2. Custom extensions for "focus mode" (prot-logos.el)</a></li>
<li><a href="#h:787df548-0d95-4512-a61d-27852198f561">5.3. USLS &#x2014; Unassuming Sidenotes of Little Significance</a></li>
<li><a href="#h:c66a0f25-840a-49f0-a615-66dfca61890b">5.4. INVTR (toy inventory and client manager)</a></li>
<li><a href="#h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa">5.5. tmr.el (TMR Must Recur)</a></li>
<li><a href="#h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7">5.6. Version control tools</a>
<ul>
<li><a href="#h:2ff46d23-09d5-4d92-b0af-2339dc19719f">5.6.1. Diff-mode (and prot-diff.el extensions)</a></li>
<li><a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">5.6.2. Version control framework (vc.el and prot-vc.el)</a>
<ul>
<li><a href="#h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301">5.6.2.1. git-email.el for preparing patches</a></li>
</ul>
</li>
<li><a href="#h:76d1b392-e693-40dc-b320-d4c1047115ab">5.6.3. Interactive and powerful git front-end (Magit)</a></li>
<li><a href="#h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1">5.6.4. Smerge and Ediff</a></li>
</ul>
</li>
<li><a href="#h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b">5.7. Command-line shells</a>
<ul>
<li><a href="#h:103a8795-c29c-474f-9ddf-ecafaa2f6775">5.7.1. Eshell and prot-eshell.el</a></li>
<li><a href="#h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a">5.7.2. Shell (M-x shell)</a></li>
</ul>
</li>
<li><a href="#h:4e8347de-415e-4804-b383-d61499e05ca1">5.8. Org-mode (personal information manager)</a></li>
<li><a href="#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9">5.9. Calendar and Diary (and prot-diary.el)</a></li>
<li><a href="#h:5ad80664-3163-4d9d-be65-462637d77903">5.10. Email settings</a>
<ul>
<li><a href="#h:a82766be-daab-4925-b23a-1c5ffd47e599">5.10.1. Client-agnostic email settings (and prot-mail.el)</a>
<ul>
<li><a href="#h:8d0bd754-8a31-431b-b112-f541cc0144ac">5.10.1.1. Sample of authinfo.gpg</a></li>
<li><a href="#h:88a605b8-d5b5-486f-87c9-0c80b423ae36">5.10.1.2. .mbsyncrc</a></li>
</ul>
</li>
<li><a href="#h:a196812e-1644-4536-84ba-687366867def">5.10.2. Notmuch (mail indexer and mail user agent (MUA))</a>
<ul>
<li><a href="#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5">5.10.2.1. .notmuch-config</a></li>
<li><a href="#h:70d60d41-cb63-4950-bbd9-9157c4d186dc">5.10.2.2. notmuch post-new rules</a></li>
<li><a href="#h:a7580136-cf32-44e8-81f6-590dbdd7f8f9">5.10.2.3. Org+Notmuch integration (ol-notmuch.el)</a></li>
</ul>
</li>
<li><a href="#h:2d793cf8-83f5-4830-b73d-78385d9b96dd">5.10.3. Sending email (SMTP)</a></li>
<li><a href="#h:d386e14b-dcf7-46a2-851f-867cd84c6cae">5.10.4. EBDB (mail contacts)</a></li>
</ul>
</li>
<li><a href="#h:4d2f596a-6fc5-4179-a361-c29f77a5ba11">5.11. Rcirc (IRC client)</a></li>
<li><a href="#h:758afe0d-bc7c-4afc-9c6b-b5e569901591">5.12. Bongo music or media manager (and prot-bongo.el)</a></li>
<li><a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">5.13. Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el</a>
<ul>
<li><a href="#h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f">5.13.1. Sample configuration for MPV (Elfeed+Bongo extension)</a></li>
</ul>
</li>
<li><a href="#h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325">5.14. Proced (process monitor, similar to `top')</a></li>
<li><a href="#h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78">5.15. Pass interface (password-store)</a></li>
<li><a href="#h:524bc702-ff55-4ed9-9a38-26d30d64591d">5.16. Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el</a></li>
<li><a href="#h:02894c1d-a739-48e7-9116-3c27a6505485">5.17. Extensions for PDFs (pdf-tools)</a></li>
</ul>
</li>
<li><a href="#h:b6bd2eea-8269-4029-b446-ee340c12ebc3">6. General interface and interactions</a>
<ul>
<li><a href="#h:ac889a76-1092-449e-a184-9092093f3103">6.1. Go to last change</a></li>
<li><a href="#h:39f57b0d-300a-4310-9ba8-8c388fa72e1d">6.2. Mode line</a>
<ul>
<li><a href="#h:c07b9dfc-14a2-41a6-9310-53539dec8684">6.2.1. Moody.el (simple mode line configuration utility)</a></li>
<li><a href="#h:b31005e3-c475-4be9-87fd-85b404550d8c">6.2.2. Hide modeline "lighters" (minions.el)</a></li>
<li><a href="#h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b">6.2.3. Mode line recursion indicators</a></li>
<li><a href="#h:da14ac1d-a06f-4531-b6c3-0414e8c98102">6.2.4. Display current time (and <code>world-clock</code>)</a></li>
<li><a href="#h:e8e51a73-e583-4250-ac26-15627cd93932">6.2.5. Keycast mode</a></li>
</ul>
</li>
<li><a href="#h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b">6.3. Window divider mode</a></li>
<li><a href="#h:26a4fac6-33e2-4f6c-8589-9463df8525c9">6.4. Fringe mode</a></li>
<li><a href="#h:755d055b-ef80-4f63-af08-ce9e931de30c">6.5. Color tools (ct.el)</a></li>
<li><a href="#h:9061c694-5f45-46b0-a878-6bcfb018e18d">6.6. Rainbow mode for colour previewing (rainbow-mode.el)</a></li>
<li><a href="#h:6478350b-b89b-406e-9b08-2dc9e93cc5b4">6.7. Depth-based code colourisation (prism.el)</a></li>
<li><a href="#h:cb76fcee-e304-4b86-a764-6c3c6775da51">6.8. Line numbers and relevant indicators (prot-sideline.el)</a></li>
<li><a href="#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1">6.9. Outline mode, outline minor mode, and extras (prot-outline.el)</a></li>
<li><a href="#h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820">6.10. Cursor and mouse settings</a>
<ul>
<li><a href="#h:cf9086c1-1b33-4127-a716-de94259e14a0">6.10.1. Cursor appearance and tweaks (prot-cursor.el)</a></li>
<li><a href="#h:02572210-eb26-4941-8f7c-666a0314877b">6.10.2. Mouse wheel behaviour</a></li>
<li><a href="#h:0c44b318-813a-4f4a-b596-75df4a86476b">6.10.3. Scrolling behaviour</a></li>
<li><a href="#h:d53b7b54-924a-443b-955a-3c5b222e3a90">6.10.4. Delete selection</a></li>
<li><a href="#h:9f492949-70fb-4fba-a0ea-569d4a240be8">6.10.5. Tooltips (tooltip-mode)</a></li>
</ul>
</li>
<li><a href="#h:aad79917-cd80-491b-9020-db27867ab132">6.11. Dired-like list for registers (rlist)</a></li>
<li><a href="#h:271c9122-280b-424e-98f0-af9e4f09bbdb">6.12. Conveniences and minor extras</a>
<ul>
<li><a href="#h:24c2ac42-a537-4658-8a08-9aebb0de1a73">6.12.1. Automatic time stamps for files (time-stamp.el)</a></li>
<li><a href="#h:7a8422e6-86d1-40f3-add4-0a1c826e44a3">6.12.2. Auto revert mode</a></li>
<li><a href="#h:9eae0d2a-eef1-4b14-b883-39094be4de71">6.12.3. Preserve contents of system clipboard</a></li>
<li><a href="#h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874">6.12.4. Newline characters for file ending</a></li>
<li><a href="#h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00">6.12.5. Zap characters</a></li>
<li><a href="#h:0d36996d-c12d-42e6-a388-b67c548c4a4b">6.12.6. Package lists</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:8fc1f9ca-f5ae-407a-b721-aab414ca657b">7. Language settings for prose and code</a>
<ul>
<li><a href="#h:485bb253-208a-4a0a-99e3-ae1a205e3b7b">7.1. Support for various major modes</a>
<ul>
<li><a href="#h:a04db751-9675-4f31-befc-0b48671c4b3b">7.1.1. Plain text (text-mode with prot-text.el)</a></li>
<li><a href="#h:7e0416c0-3acc-4748-9eca-4dd4da11d79b">7.1.2. Markdown (markdown-mode)</a></li>
<li><a href="#h:c6a1aa30-4850-40b4-9764-302d98ba95fc">7.1.3. YAML (yaml-mode)</a></li>
<li><a href="#h:ec10bfe6-5340-481c-9de2-3e346868241b">7.1.4. CSS (css-mode)</a></li>
<li><a href="#h:fee2b8ff-80d6-4669-904c-c8ee64c9719c">7.1.5. Shell scripts (sh-mode)</a></li>
</ul>
</li>
<li><a href="#h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3">7.2. Paragraphs and fill-mode (prot-fill.el)</a></li>
<li><a href="#h:fa56241c-6840-4a39-8f59-18460d37fc69">7.3. Comments (newcomment.el and prot-comment.el)</a></li>
<li><a href="#h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9">7.4. Configure 'electric' behaviour</a></li>
<li><a href="#h:3d374354-843f-4efa-aa38-1ba2c9ccc14c">7.5. Parentheses (show-paren-mode)</a></li>
<li><a href="#h:d51d37df-4e58-4e0b-85a1-019ceda342f6">7.6. Tabs, indentation, and the TAB key</a></li>
<li><a href="#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c">7.7. Flyspell and prot-spell.el (spell check)</a></li>
<li><a href="#h:20448ad8-9371-4e00-b88b-6b93f4c654d9">7.8. Code and text linters</a>
<ul>
<li><a href="#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a">7.8.1. Flymake</a>
<ul>
<li><a href="#h:a45fd661-8cd7-4ee7-bff0-5f738d82b73b">7.8.1.1. Flymake + Shellcheck</a></li>
<li><a href="#h:2a954862-c532-43e9-afdf-4bacd152295f">7.8.1.2. Flymake + Proselint</a>
<ul>
<li><a href="#h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b">7.8.1.2.1. Proselint configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:d03342da-3035-409f-a5e7-5df1e614d507">7.8.2. Elisp packaging requirements</a></li>
</ul>
</li>
<li><a href="#h:d0f76937-4f54-401c-aae8-ffadf8697357">7.9. Eldoc (elisp live documentation feedback)</a></li>
<li><a href="#h:ce420306-c40c-4d9a-bc01-205c5e49a5d1">7.10. Tools for manual pages (manpages)</a></li>
</ul>
</li>
<li><a href="#h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b">8. History and state</a>
<ul>
<li><a href="#h:68d57dd2-4df1-4b7a-8766-231216e6cd9c">8.1. Emacs server and desktop</a></li>
<li><a href="#h:ab868c1a-7ca6-4f54-83d8-eab49447da82">8.2. Record various types of history</a>
<ul>
<li><a href="#h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978">8.2.1. Record cursor position</a></li>
<li><a href="#h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296">8.2.2. Backups</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:4e73b827-cdf3-46a2-81c5-55b6e95701b7">9. Frequently Asked Questions about this document</a>
<ul>
<li><a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">9.1. How do you learn Emacs?</a></li>
<li><a href="#h:b9233089-5a3a-4e7a-81ef-3ad395a26036">9.2. Why maintain all those 'prot-*.el' files?</a></li>
<li><a href="#h:0077f7e0-409f-4645-a040-018ee9b5b2f2">9.3. What is the purpose of "prot/" and "contrib/"?</a></li>
<li><a href="#h:ba373e0d-29d1-4224-b0f1-64b640ceeaae">9.4. Why do you use so many `setq'?</a></li>
<li><a href="#h:3e4fefda-c069-4403-a2ad-6d77ee8c0914">9.5. Why do you explicitly set variables the same as default?</a></li>
<li><a href="#h:a654fcb5-0163-4dc6-977a-8c50175118a1">9.6. Did you know XYZ package is better than the defaults?</a></li>
<li><a href="#h:7be4b564-4360-4905-aa10-1405fba6ea2a">9.7. Compare Gnus, Mu4e, Notmuch?</a></li>
<li><a href="#h:7e4448ec-3878-4ea2-9cd6-75e9faaac373">9.8. Have you tried Gnus for RSS feeds?</a></li>
<li><a href="#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703">9.9. What is the meaning of the `s-KEY' bindings?</a></li>
<li><a href="#h:0675f798-e2d9-4762-9df2-f47cd24cf00a">9.10. How to reproduce your dotemacs?</a></li>
<li><a href="#h:044977f2-a909-4804-bf89-576dd429d405">9.11. What is your distro and/or window manager?</a></li>
<li><a href="#h:e134a8b2-224e-4383-bf03-b080ab6659c7">9.12. What hardware do you use?</a></li>
</ul>
</li>
<li><a href="#h:7b39c38c-ae23-4385-b439-afca89baca52">10. Other people's Emacs work</a></li>
</ul>
</div>
</div>

<div id="outline-container-h:9ff13b78-42b8-49fe-9e23-0307c780de93" class="outline-2">
<h2 id="h:9ff13b78-42b8-49fe-9e23-0307c780de93"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-h:9ff13b78-42b8-49fe-9e23-0307c780de93">
</div>
<div id="outline-container-h:0a9b72b3-aa4a-4c5c-a654-d4bc04b31bbd" class="outline-3">
<h3 id="h:0a9b72b3-aa4a-4c5c-a654-d4bc04b31bbd"><span class="section-number-3">1.1.</span> Canonical links to this document</h3>
<div class="outline-text-3" id="text-h:0a9b72b3-aa4a-4c5c-a654-d4bc04b31bbd">
<dl class="org-dl">
<dt>HTML version</dt><dd><a href="https://protesilaos.com/emacs/dotemacs">https://protesilaos.com/emacs/dotemacs</a></dd>
<dt>Git repo</dt><dd><a href="https://gitlab.com/protesilaos/dotfiles">https://gitlab.com/protesilaos/dotfiles</a></dd>
</dl>
</div>
</div>

<div id="outline-container-h:8cfd5674-4997-44c7-bb7a-1869d5d53538" class="outline-3">
<h3 id="h:8cfd5674-4997-44c7-bb7a-1869d5d53538"><span class="section-number-3">1.2.</span> What is this</h3>
<div class="outline-text-3" id="text-h:8cfd5674-4997-44c7-bb7a-1869d5d53538">
<p>
The present document, referred to in the source code version as
<code>prot-emacs.org</code>, contains the bulk of my configurations for GNU Emacs.
It is designed using principles of "literate programming": a
combination of ordinary language and inline code blocks.  Emacs knows
how to parse this file properly so as to evaluate only the Elisp
("Emacs Lisp") included herein.  The rest is for humans to make sense
of my additions and their underlying rationale.
</p>

<p>
Literate programming allows us to be more expressive and deliberate.
Not only can we use typography to its maximum potential, but may also
employ techniques such as internal links between sections.  This makes
the final product much more useful for end users than, say, a terse
script.
</p>

<p>
Each section provides information about the code it contains.  In case
you feel something is missing, I maintain a <a href="#h:4e73b827-cdf3-46a2-81c5-55b6e95701b7">Frequently Asked Questions</a>
section (when in doubt, or to offer feedback, suggestions, further
comments, etc., do <a href="https://protesilaos.com/contact">contact me</a>).
</p>

<p>
In more practical terms, this document is written using <code>org-mode</code>.  It
contains all <i>package configurations</i> for my Emacs setup.  To actually
work, it needs to be initialised from another file that only covers the
absolute essentials.
</p>
</div>

<div id="outline-container-h:584c3604-55a1-49d0-9c31-abe46cb1f028" class="outline-4">
<h4 id="h:584c3604-55a1-49d0-9c31-abe46cb1f028"><span class="section-number-4">1.2.1.</span> Main macros and other contents of my init.el (for Emacs 28)</h4>
<div class="outline-text-4" id="text-h:584c3604-55a1-49d0-9c31-abe46cb1f028">
<p>
The <code>prot-emacs.org</code> is loaded from an other file, named <code>init.el</code> per the
Emacs conventions.  Mine includes some helper macros for package
configuration and is otherwise designed to initialise the package lists
and load the file with my configurations (i.e. the present document).
</p>

<p>
<b>Those macros are integral parts of my setup</b>, as they control the
configuration of all packages declared herein.  In particular:
</p>

<ul class="org-ul">
<li><code>prot-emacs-builtin-package</code> is used for libraries that are either
shipped with Emacs or are part of my dotfiles' directory.  The latter
class consists of all those <code>prot-*.el</code> files, as well as a few others.
What this macro does is to <code>require</code> the given feature and then evaluate
all of its forms (variables, key bindings, hooks, etc.).</li>

<li><code>prot-emacs-elpa-package</code> controls packages that I install from some
Emacs Lisp Package Archive, like MELPA or GNU ELPA.  This macro will
load the package if it is already installed and then evaluate all of
its forms.  If the package is not installed, it will produce a warning
telling the user that all the uninstalled-yet-declared packages can be
downloaded in one go with the command <code>prot-emacs-install-ensured</code>
(though read further below about auto-installing packages).</li>

<li><code>prot-emacs-manual-package</code> handles the few packages that I install
manually via their Git repository.  Each of those repos must be inside
<code>(locate-user-emacs-file "contrib-lisp")</code> (typically available at
<code>~/.emacs.d/contrib-lisp</code>).  The macro will load the package normally
and configure it accordingly if it exists at the desired path, else it
will log a warning about what file path it expects to read.  In
concrete terms, if you want <code>package-A</code> you must first place all of its
files at <code>~/.emacs.d/contrib-lisp/package-A</code>.</li>
</ul>

<p>
<b>I must stress that no package is automatically installed by default:</b> the
user is expected to do so on their own either by calling a command or by
providing their explicit consent to the auto-installation of packages
from Emacs Lisp Package Archives.  The idea is to avoid the malpractice
of installing software without asking the user to opt in to such a deal.
To actually instruct my declared packages to be installed automatically,
a user must create a new file called <code>basic-init.el</code>, place it in the same
directory as my <code>init.el</code> and <code>prot-emacs.org</code> and include in it this form:
<code>(setq prot-emacs-autoinstall-elpa t)</code>.
</p>

<p>
For more read: <a href="#h:0675f798-e2d9-4762-9df2-f47cd24cf00a">How to reproduce your dotemacs?</a>.
</p>

<p>
The <code>init.el</code> (reproduced further below) also sets some variables to their
desired values and provides a couple of functions that control the start
and end phases of my Emacs sessions.
</p>

<ul class="org-ul">
<li><code>prot-emacs-build-config</code> is the final function from my part that runs
before terminating the running Emacs process.  It regenerates my
configurations and byte compiles the output.  This speeds things up
the next time I launch Emacs, while it also ensures that I am always
running the latest version of my setup.</li>

<li><code>prot-emacs-load-config</code> will either load the output of the
aforementioned function or, if that is not available, parse the
literate program that holds my code (this Org file if you are viewing
the source code or the document that produces the HTML of this web
page).  Either way, it load my configurations.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; init.el --- Personal configuration file -*- lexical-binding: t -*-

;; Copyright (c) 2019-2021  Protesilaos Stavrou &lt;info@protesilaos.com&gt;

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This file is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This file is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

;;; Commentary:

;; This file sets up the essentials for incorporating my init org
;; file.  This is known as "literate programming", which I think is
;; particularly helpful for sharing Emacs configurations with a wider
;; audience that includes new or potential users (I am still very new
;; myself).
;;
;; See my dotfiles: https://gitlab.com/protesilaos/dotfiles

;;; Code:

(require 'package)

(add-to-list 'package-archives
             '("elpa-devel" . "https://elpa.gnu.org/devel/"))

(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))

(defvar prot-emacs-autoinstall-elpa nil
  "Whether `prot-emacs-elpa-package' should install packages.
The default nil value means never to automatically install
packages.  A non-nil value is always interpreted as consent for
auto-installing everything---this process does not cover manually
maintained git repos, controlled by `prot-emacs-manual-package'.")

(defvar prot-emacs-basic-init "basic-init.el"
  "Name of 'basic init' file.

This file is meant to store user configurations that are evaluated
before loading `prot-emacs-configuration-main-file' and, when
available, `prot-emacs-configuration-user-file'.  Those values
control the behaviour of the Emacs setup.

The only variable that is currently expected to be in the 'basic
init' file is `prot-emacs-autoinstall-elpa'.

See `prot-emacs-basic-init-setup' for the actual initialisation
process.")

(defun prot-emacs-basic-init-setup ()
  "Load 'basic-init.el' if it exists.
This is meant to evaluate forms that control the rest of my Emacs
setup."
  (let* ((init prot-emacs-basic-init)
         (file (locate-user-emacs-file init)))
    (when (file-exists-p file)
      (load-file file))))

;; This variable is incremented in prot-emacs.org.  The idea is to
;; produce a list of packages that we want to install on demand from an
;; ELPA, when `prot-emacs-autoinstall-elpa' is set to nil (the default).
;;
;; So someone who tries to reproduce my Emacs setup will first get a
;; bunch of warnings about unavailable packages, though not
;; show-stopping errors, and will then have to use the command
;; `prot-emacs-install-ensured'.  After that command does its job, a
;; re-run of my Emacs configurations will yield the expected results.
;;
;; The assumption is that such a user will want to inspect the elements
;; of `prot-emacs-ensure-install', remove from the setup whatever code
;; block they do not want, and then call the aforementioned command.
;;
;; I do not want to maintain a setup that auto-installs everything on
;; first boot without requiring explicit consent.  I think that is a bad
;; practice because it teaches the user to simply put their faith in the
;; provider.
(defvar prot-emacs-ensure-install nil
  "List of package names used by `prot-emacs-install-ensured'.")

(defun prot-emacs-install-ensured ()
  "Install all `prot-emacs-ensure-install' packages, if needed.
If a package is already installed, no further action is performed
on it."
  (interactive)
  (when (yes-or-no-p (format "Try to install %d packages?"
                             (length prot-emacs-ensure-install)))
    (package-refresh-contents)
    (mapc (lambda (package)
            (unless (package-installed-p package)
              (package-install package)))
          prot-emacs-ensure-install)))

(defmacro prot-emacs-builtin-package (package &amp;rest body)
  "Set up builtin PACKAGE with rest BODY.
PACKAGE is a quoted symbol, while BODY consists of balanced
expressions."
  (declare (indent 1))
  `(progn
     (unless (require ,package nil 'noerror)
       (display-warning 'prot-emacs (format "Loading `%s' failed" ,package) :warning))
     ,@body))

(defmacro prot-emacs-elpa-package (package &amp;rest body)
  "Set up PACKAGE from an Elisp archive with rest BODY.
PACKAGE is a quoted symbol, while BODY consists of balanced
expressions.

When `prot-emacs-autoinstall-elpa' is non-nil try to install the
package if it is missing."
  (declare (indent 1))
  `(progn
     (when (and prot-emacs-autoinstall-elpa
                (not (package-installed-p ,package)))
       (package-install ,package))
     (if (require ,package nil 'noerror)
         (progn ,@body)
       (display-warning 'prot-emacs (format "Loading `%s' failed" ,package) :warning)
       (add-to-list 'prot-emacs-ensure-install ,package)
       (display-warning
        'prot-emacs
        "Run `prot-emacs-install-ensured' to install all packages in `prot-emacs-ensure-install'"
        :warning))))

(defmacro prot-emacs-manual-package (package &amp;rest body)
  "Set up manually installed PACKAGE with rest BODY.
PACKAGE is a quoted symbol, while BODY consists of balanced
expressions."
  (declare (indent 1))
  (let ((path (thread-last user-emacs-directory
                (expand-file-name "contrib-lisp")
                (expand-file-name (symbol-name (eval package))))))
    `(progn
       (eval-and-compile
         (add-to-list 'load-path ,path))
       (if (require ,package nil 'noerror)
	       (progn ,@body)
         (display-warning 'prot-emacs (format "Loading `%s' failed" ,package) :warning)
         (display-warning 'prot-emacs (format "This must be available at %s" ,path) :warning)))))

(require 'vc)
(setq vc-follow-symlinks t) ; Because my dotfiles are managed that way

;; "prot-lisp" is for all my custom libraries; "contrib-lisp" is for
;; third-party code that I handle manually; while "modus-themes"
;; contains my themes which I use directly from source for development
;; purposes.
(dolist (path '("prot-lisp" "contrib-lisp" "modus-themes"))
  (add-to-list 'load-path (locate-user-emacs-file path)))

;; Some basic settings
(setq frame-title-format '("%b"))
(setq default-input-method "greek")
(setq ring-bell-function 'ignore)

(setq use-short-answers t)    ; for Emacs28, replaces the defalias below
;; (defalias 'yes-or-no-p 'y-or-n-p)

(put 'narrow-to-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
(put 'overwrite-mode 'disabled t)

(setq initial-buffer-choice t)			; always start with *scratch*

;; I create an "el" version of my Org configuration file as a final step
;; before closing down Emacs (see further below).  This is done to load
;; the latest version of my code upon startup.  Also helps with
;; initialisation times.  Not that I care too much about those...

(defvar prot-emacs-configuration-main-file "prot-emacs"
  "Base name of the main configuration file.")

;; THIS IS EXPERIMENTAL.  Basically I want to test how we can let users
;; include their own customisations in addition to my own.  Those will
;; be stored in a separate Org file.
(defvar prot-emacs-configuration-user-file "user-emacs"
  "Base name of user-specific configuration file.")

(defun prot-emacs--expand-file-name (file extension)
  "Return canonical path to FILE to Emacs config with EXTENSION."
  (locate-user-emacs-file
   (concat file extension)))

(defun prot-emacs-load-config ()
  "Load main Emacs configurations, either '.el' or '.org' file."
  (let* ((main-init prot-emacs-configuration-main-file)
         (main-init-el (prot-emacs--expand-file-name main-init ".el"))
         (main-init-org (prot-emacs--expand-file-name main-init ".org"))
         (user-init prot-emacs-configuration-user-file)
         (user-init-el (prot-emacs--expand-file-name user-init ".el"))
         (user-init-org (prot-emacs--expand-file-name user-init ".org")))
    (prot-emacs-basic-init-setup)
    (require 'org)
    (if (file-exists-p main-init-el)    ; FIXME 2021-02-16: this should be improved
        (load-file main-init-el)
      (when (file-exists-p main-init-org)
        (org-babel-load-file main-init-org)))
    (if (file-exists-p user-init-el)
        (load-file user-init-el)
      (when (file-exists-p user-init-org)
        (org-babel-load-file user-init-org)))))

;; Load configurations.
(prot-emacs-load-config)

;; The following as for when we close the Emacs session.
(declare-function org-babel-tangle-file "ob-tangle")

(defun prot-emacs-build-config ()
  "Produce Elisp init from my Org dotemacs.
Add this to `kill-emacs-hook', to use the newest file in the next
session.  The idea is to reduce startup time, though just by
rolling it over to the end of a session rather than the beginning
of it."
  (interactive)
  (let* ((main-init prot-emacs-configuration-main-file)
         (main-init-el (prot-emacs--expand-file-name main-init ".el"))
         (main-init-org (prot-emacs--expand-file-name main-init ".org"))
         (user-init prot-emacs-configuration-user-file)
         (user-init-el (prot-emacs--expand-file-name user-init ".el"))
         (user-init-org (prot-emacs--expand-file-name user-init ".org")))
    (when (file-exists-p main-init-el)
      (delete-file main-init-el))
    (when (file-exists-p user-init-el)
      (delete-file user-init-el))
    (require 'org)
    (when (file-exists-p main-init-org)
      (org-babel-tangle-file main-init-org main-init-el)
      (byte-compile-file main-init-el))
    (when (file-exists-p user-init-org)
      (org-babel-tangle-file user-init-org user-init-el)
      (byte-compile-file user-init-el))))

(add-hook 'kill-emacs-hook #'prot-emacs-build-config)

;;; init.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:874944d8-7ac0-4115-aa21-6ff4e005f6f6" class="outline-5">
<h5 id="h:874944d8-7ac0-4115-aa21-6ff4e005f6f6"><span class="section-number-5">1.2.1.1.</span> The "early init"</h5>
<div class="outline-text-5" id="text-h:874944d8-7ac0-4115-aa21-6ff4e005f6f6">
<p>
Starting with Emacs 27.1, an <code>early-init.el</code> is required to control things
with greater precision.  My code is as follows:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; early-init.el --- Early Init File -*- lexical-binding: t -*-

;; Copyright (c) 2020-2021  Protesilaos Stavrou &lt;info@protesilaos.com&gt;

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This file is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This file is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

;;; Commentary:

;; Prior to Emacs 27, the `init.el' was supposed to handle the
;; initialisation of the package manager, by means of calling
;; `package-initialize'.  Starting with Emacs 27, the default
;; behaviour is to start the package manager before loading the init
;; file.
;;
;; See my dotfiles: https://gitlab.com/protesilaos/dotfiles

;;; Code:

;; Initialise installed packages
(setq package-enable-at-startup t)

(defvar package-quickstart)

;; Allow loading from the package cache
(setq package-quickstart t)

;; Do not resize the frame at this early stage.
(setq frame-inhibit-implied-resize t)

;; Disable GUI elements
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(setq inhibit-splash-screen t)
(setq use-dialog-box t)                 ; only for mouse events
(setq use-file-dialog nil)

(setq inhibit-startup-echo-area-message user-login-name) ; read the docstring
(setq inhibit-startup-screen t)
(setq inhibit-startup-buffer-menu t)

(setq native-comp-async-report-warnings-errors 'silent) ; emacs28 with native compilation

;;; early-init.el ends here
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:f738cdfc-a6ff-46cb-9962-31f754280af5" class="outline-4">
<h4 id="h:f738cdfc-a6ff-46cb-9962-31f754280af5"><span class="section-number-4">1.2.2.</span> About the source code version of this document</h4>
<div class="outline-text-4" id="text-h:f738cdfc-a6ff-46cb-9962-31f754280af5">
<p>
In the <code>org-mode</code> version of this document, I make sure that the
above-referenced code blocks are not declared as an <code>emacs-lisp</code> source
but rather as mere examples, so they are not accidentally parsed by the
actual setup.
</p>

<p>
Actual code blocks are wrapped between <code>#+begin_src</code> and <code>#+end_src</code> tags
(not visible in the website version of this page).  For Emacs 27.1,
such templates can be quickly inserted with <code>C-c C-,</code> (this works both
for empty blocks and active regions).  For more on the matter, refer
to <a href="#h:4e8347de-415e-4804-b383-d61499e05ca1">Org's section further below</a>.
</p>

<p>
As for the various settings included herein, you can learn <i>even more</i>
about them by using Emacs' built-in documentation facilities (also read
my note on <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).
</p>

<p>
Additionally, you will notice some metadata tags specific to <code>org-mode</code>
below each heading.  These are generated by the functions that are
defined in the package configurations for Org mode.  The idea is to keep
anchor tags consistent when generating a new HTML version of this
document.
</p>

<p>
This metadata also makes it possible to create immutable internal links,
whenever a reference is needed.  To create such links, you can use <code>C-c l</code>
to capture the unique ID of the current section and then <code>C-c C-l</code> to
create a link.
</p>

<p>
Consult the section on <a href="#h:4e8347de-415e-4804-b383-d61499e05ca1">Org-mode (personal information manager)</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-h:1b9e6455-ba10-4683-88d4-738ecc41cdf6" class="outline-3">
<h3 id="h:1b9e6455-ba10-4683-88d4-738ecc41cdf6"><span class="section-number-3">1.3.</span> COPYING</h3>
<div class="outline-text-3" id="text-h:1b9e6455-ba10-4683-88d4-738ecc41cdf6">
<p>
Copyright (c) 2019-2021  Protesilaos Stavrou &lt;info@protesilaos.com&gt;
</p>

<p>
This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.
</p>

<p>
This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
</p>

<p>
You should have received a copy of the GNU General Public License
along with this file.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-h:4d42f3e3-e96f-4125-a819-0544a21d45f3" class="outline-2">
<h2 id="h:4d42f3e3-e96f-4125-a819-0544a21d45f3"><span class="section-number-2">2.</span> Base settings</h2>
<div class="outline-text-2" id="text-h:4d42f3e3-e96f-4125-a819-0544a21d45f3">
<p>
This section contains the relatively few configurations that are needed
prior to the setup of everything else.
</p>
</div>

<div id="outline-container-h:c82dcbfa-97d0-4f7c-85af-768ce90f1372" class="outline-3">
<h3 id="h:c82dcbfa-97d0-4f7c-85af-768ce90f1372"><span class="section-number-3">2.1.</span> Common auxiliary functions (prot-common.el)</h3>
<div class="outline-text-3" id="text-h:c82dcbfa-97d0-4f7c-85af-768ce90f1372">
<p>
There are a few utilities that I keep re-using in various parts of my
Emacs code base.  To keep things modular, I place them all in a
dedicated <code>prot-common.el</code> file, which can then be marked as a dependency
by other libraries of mine.  As such, all we do here is load the file.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Common auxiliary functions (prot-common.el)
(prot-emacs-builtin-package 'prot-common)
</pre>
</div>

<p>
And here is <code>prot-common.el</code> in its totality.  It is available as a file
in <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (same for all my Emacs libraries):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-common.el --- Common functions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Common functions for my Emacs: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile
  (require 'subr-x))

(defgroup prot-common ()
  "Auxiliary functions for my dotemacs."
  :group 'editing)

;;;###autoload
(defun prot-common-number-even-p (n)
  "Test if N is an even number."
  (if (numberp n)
      (= (% n 2) 0)
    (error "%s is not a number" n)))

;;;###autoload
(defun prot-common-number-integer-p (n)
  "Test if N is an integer."
  (if (integerp n)
      n
    (error "%s is not an integer" n)))

;;;###autoload
(defun prot-common-number-integer-positive-p (n)
  "Test if N is a positive integer."
  (if (prot-common-number-integer-p n)
      (&gt; n 0)
    (error "%s is not a positive integer" n)))

;; Thanks to Gabriel for providing a cleaner version of
;; `prot-common-number-negative': &lt;https://github.com/gabriel376&gt;.
;;;###autoload
(defun prot-common-number-negative (n)
  "Make N negative."
  (if (and (numberp n) (&gt; n 0))
      (* -1 n)
    (error "%s is not a valid positive number" n)))

;;;###autoload
(defun prot-common-reverse-percentage (number percent change-p)
  "Determine the original value of NUMBER given PERCENT.

CHANGE-P should specify the increase or decrease.  For simplicity,
nil means decrease while non-nil stands for an increase.

NUMBER must satisfy `numberp', while PERCENT must be `natnump'."
  (unless (numberp number)
    (user-error "NUMBER must satisfy numberp"))
  (unless (natnump percent)
    (user-error "PERCENT must satisfy natnump"))
  (let* ((pc (/ (float percent) 100))
         (pc-change (if change-p (+ 1 pc) pc))
         (n (if change-p pc-change (float (- 1 pc-change)))))
    ;; FIXME 2021-12-21: If float, round to 4 decimal points.
    (/ number n)))

;;;###autoload
(defun prot-common-percentage-change (n-original n-final)
  "Find percentage change between N-ORIGINAL and N-FINAL numbers.

When the percentage is not an integer, it is rounded to 4
floating points: 16.666666666666664 =&gt; 16.667."
  (unless (numberp n-original)
    (user-error "N-ORIGINAL must satisfy numberp"))
  (unless (numberp n-final)
    (user-error "N-FINAL must satisfy numberp"))
  (let* ((difference (float (abs (- n-original n-final))))
         (n (* (/ difference n-original) 100))
         (round (floor n)))
    ;; FIXME 2021-12-21: Any way to avoid the `string-to-number'?
    (if (&gt; n round) (string-to-number (format "%0.4f" n)) round)))

;;;###autoload
(defun prot-common-empty-buffer-p ()
  "Test whether the buffer is empty."
  (or (= (point-min) (point-max))
      (save-excursion
        (goto-char (point-min))
        (while (and (looking-at "^\\([a-zA-Z]+: ?\\)?$")
                    (zerop (forward-line 1))))
        (eobp))))

;;;###autoload
(defun prot-common-minor-modes-active ()
  "Return list of active minor modes for the current buffer."
  (let ((active-modes))
    (mapc (lambda (m)
            (when (and (boundp m) (symbol-value m))
              (push m active-modes)))
          minor-mode-list)
    active-modes))

;;;###autoload
(defun prot-common-truncate-lines-silently ()
  "Toggle line truncation without printing messages."
  (let ((inhibit-message t))
    (toggle-truncate-lines t)))

;;;###autoload
(defun prot-common-disable-hl-line ()
  "Disable Hl-Line-Mode (for hooks)."
  (hl-line-mode -1))

;;;###autoload
(defun prot-common-window-bounds ()
  "Determine start and end points in the window."
  (list (window-start) (window-end)))

;;;###autoload
(defun prot-common-read-data (file)
  "Read Elisp data from FILE."
  (with-temp-buffer
    (insert-file-contents file)
    (read (current-buffer))))

;; Thanks to Omar Antolín Camarena for providing this snippet!
;;;###autoload
(defun prot-common-completion-table (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES.

This is intended for bespoke functions that need to pass
completion metadata that can then be parsed by other
tools (e.g. `embark')."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category))
      (complete-with-action action candidates string pred))))

;; Thanks to Igor Lima for the `prot-common-crm-exclude-selected-p':
;; &lt;https://github.com/0x462e41&gt;.
;; This is used as a filter predicate in the relevant prompts.
(defvar crm-separator)

;;;###autoload
(defun prot-common-crm-exclude-selected-p (input)
  "Filter out INPUT from `completing-read-multiple'.
Hide non-destructively the selected entries from the completion
table, thus avoiding the risk of inputting the same match twice.

To be used as the PREDICATE of `completing-read-multiple'."
  (if-let* ((pos (string-match-p crm-separator input))
            (rev-input (reverse input))
            (element (reverse
                      (substring rev-input 0
                                 (string-match-p crm-separator rev-input))))
            (flag t))
      (progn
        (while pos
          (if (string= (substring input 0 pos) element)
              (setq pos nil)
            (setq input (substring input (1+ pos))
                  pos (string-match-p crm-separator input)
                  flag (when pos t))))
        (not flag))
    t))

;; The `prot-common-line-regexp-p' and `prot-common--line-regexp-alist'
;; are contributed by Gabriel: &lt;https://github.com/gabriel376&gt;.  They
;; provide a more elegant approach to using a macro, as shown further
;; below.
(defvar prot-common--line-regexp-alist
  '((empty . "[\s\t]*$")
    (indent . "^[\s\t]+")
    (non-empty . "^.+$")
    (list . "^\\([\s\t#*+]+\\|[0-9]+[^\s]?[).]+\\)")
    (heading . "^[=-]+"))
  "Alist of regexp types used by `prot-common-line-regexp-p'.")

(defun prot-common-line-regexp-p (type &amp;optional n)
  "Test for TYPE on line.
TYPE is the car of a cons cell in
`prot-common--line-regexp-alist'.  It matches a regular
expression.

With optional N, search in the Nth line from point."
  (save-excursion
    (goto-char (point-at-bol))
    (and (not (bobp))
         (or (beginning-of-line n) t)
         (save-match-data
           (looking-at
            (alist-get type prot-common--line-regexp-alist))))))

;; The `prot-common-shell-command-with-exit-code-and-output' function is
;; courtesy of Harold Carr, who also sent a patch that improved
;; `prot-eww-download-html' (from the `prot-eww.el' library).
;;
;; More about Harold: &lt;http://haroldcarr.com/about/&gt;.
(defun prot-common-shell-command-with-exit-code-and-output (command &amp;rest args)
  "Run COMMAND with ARGS.
Return the exit code and output in a list."
  (with-temp-buffer
    (list (apply 'call-process command nil (current-buffer) nil args)
          (buffer-string))))

(defvar prot-common-url-regexp
  (concat
   "\\b\\(\\(www\\.\\|\\(s?https?\\|ftp\\|file\\|gopher\\|"
   "nntp\\|news\\|telnet\\|wais\\|mailto\\|info\\):\\)"
   "\\(//[-a-z0-9_.]+:[0-9]*\\)?"
   (let ((chars "-a-z0-9_=#$@~%&amp;*+\\/[:word:]")
	     (punct "!?:;.,"))
     (concat
      "\\(?:"
      ;; Match paired parentheses, e.g. in Wikipedia URLs:
      ;; http://thread.gmane.org/47B4E3B2.3050402@gmail.com
      "[" chars punct "]+" "(" "[" chars punct "]+" ")"
      "\\(?:" "[" chars punct "]+" "[" chars "]" "\\)?"
      "\\|"
      "[" chars punct "]+" "[" chars "]"
      "\\)"))
   "\\)")
  "Regular expression that matches URLs.
Copy of variable `browse-url-button-regexp'.")

;; This was my old approach to the task:
;;
;; ;; Based on `org--line-empty-p'.
;; (defmacro prot-common--line-p (name regexp)
;;   "Make NAME function to match REGEXP on line n from point."
;;   `(defun ,name (n)
;;      (save-excursion
;;        (goto-char (point-at-bol))
;;        (and (not (bobp))
;; 	        (or (beginning-of-line n) t)
;; 	        (save-match-data
;; 	          (looking-at ,regexp))))))
;;
;; (prot-common--line-p
;;  prot-common-empty-line-p
;;  "[\s\t]*$")
;;
;; (prot-common--line-p
;;  prot-common-indent-line-p
;;  "^[\s\t]+")
;;
;; (prot-common--line-p
;;  prot-common-non-empty-line-p
;;  "^.+$")
;;
;; (prot-common--line-p
;;  prot-common-text-list-line-p
;;  "^\\([\s\t#*+]+\\|[0-9]+[^\s]?[).]+\\)")
;;
;; (prot-common--line-p
;;  prot-common-text-heading-line-p
;;  "^[=-]+")

(provide 'prot-common)
;;; prot-common.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:ae48fe61-a3c3-4132-8986-785f9bfbeafb" class="outline-3">
<h3 id="h:ae48fe61-a3c3-4132-8986-785f9bfbeafb"><span class="section-number-3">2.2.</span> Common custom functions (prot-simple.el)</h3>
<div class="outline-text-3" id="text-h:ae48fe61-a3c3-4132-8986-785f9bfbeafb">
<p>
<code>prot-simple.el</code> contains a wide range of commands that are broadly in
line with the built-in <code>simple.el</code> and <code>lisp.el</code> libraries.  While I could
offer an overview of each item in my library, I feel the code and
accompanying documentation strings are clear enough for you to peruse
the source directly (reproduced further below).
</p>

<p>
Still, here are some highlights for those who don't like studying the
source code:
</p>

<ul class="org-ul">
<li><code>prot-simple-insert-pair</code> will surround either the symbol-at-point or
the active region with a pair of delimiters.  It prompts for
completion on which pair to use, while the most recently used entry
becomes the default, so next time the user can just add it with <code>RET</code> at
the minibuffer prompt.  With an optional prefix argument (<code>C-u</code>) it asks
for how many times to insert the selected delimiters (e.g. you want to
wrap two angled brackets around the region).</li>

<li><code>prot-simple-scratch-buffer</code> produces a buffer with the major-mode of
the current one.  With a prefix argument (<code>C-u</code>) it instead applies the
major-mode which is stored in the user customisation option
<code>prot-simple-scratch-buffer-default-mode</code>.  With a double prefix
argument (<code>C-u C-u</code>) it prompts for completion on which major-mode to
use.  If the region is active, its contents are copied to the newly
created scratch buffer.  The idea is based on <a href="https://github.com/ieure/scratch-el">the scratch.el package</a>
by Ian Eure.</li>

<li><code>prot-simple-copy-line-or-region</code> copies the current line or the region,
if that is active.  With a prefix argument (<code>C-u</code>) it creates a
duplicate of it right below.</li>
</ul>

<p>
All of the other commands are optimisations for common motions or little
quality-of-life improvements for oft-required operations (such as
transposition of objects or marking of balanced expressions).
</p>

<p>
Given that this is a foundational piece of my Emacs setup, it is the
appropriate place to re-bind or free up some common key combinations for
use elsewhere.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Common custom functions (prot-simple.el)
(prot-emacs-builtin-package 'prot-simple
  (setq prot-simple-insert-pair-alist
        '(("' Single quote"        . (39 39))     ; ' '
          ("\" Double quotes"      . (34 34))     ; " "
          ("` Elisp quote"         . (96 39))     ; ` '
          ("‘ Single apostrophe"   . (8216 8217)) ; ‘ ’
          ("“ Double apostrophes"  . (8220 8221)) ; “ ”
          ("( Parentheses"         . (40 41))     ; ( )
          ("{ Curly brackets"      . (123 125))   ; { }
          ("[ Square brackets"     . (91 93))     ; [ ]
          ("&lt; Angled brackets"     . (60 62))     ; &lt; &gt;
          ("« Εισαγωγικά Gr quote" . (171 187))   ; « »
          ("= Equals signs"        . (61 61))     ; = =
          ("~ Tilde"               . (126 126))   ; ~ ~
          ("* Asterisks"           . (42 42))     ; * *
          ("/ Forward Slash"       . (47 47))     ; / /
          ("_ underscores"         . (95 95))))   ; _ _
  (setq prot-simple-date-specifier "%F")
  (setq prot-simple-time-specifier "%R %z")
  (setq delete-pair-blink-delay 0.15) ; Emacs28 -- see `prot-simple-delete-pair-dwim'
  (setq prot-simple-scratch-buffer-default-mode 'markdown-mode)
  (setq help-window-select t)

  ;; ;; DEPRECATED 2021-10-15: set `help-window-select' to non-nil.
  ;; (setq prot-simple-focusable-help-commands
  ;;       '( describe-symbol
  ;;          describe-function
  ;;          describe-mode
  ;;          describe-variable
  ;;          describe-key
  ;;          describe-char
  ;;          what-cursor-position
  ;;          describe-package
  ;;          view-lossage))
  ;; (prot-simple-focus-help-buffers 1)

  (prot-simple-rename-help-buffers 1)

  ;; General commands
  (let ((map global-map))
    (define-key map (kbd "&lt;insert&gt;") nil)
    (define-key map (kbd "C-z") nil)
    (define-key map (kbd "C-x C-z") nil)
    (define-key map (kbd "C-h h") nil)
    (define-key map (kbd "M-`") nil)
    (define-key map (kbd "C-h .") #'prot-simple-describe-symbol) ; overrides `display-local-help'
    (define-key map (kbd "C-h K") #'describe-keymap) ; overrides `Info-goto-emacs-key-command-node'
    (define-key map (kbd "C-h c") #'describe-char) ; overrides `describe-key-briefly'
    (define-key map (kbd "C-c s") #'prot-simple-scratch-buffer)
    ;; Commands for lines
    (define-key map (kbd "C-S-w") #'prot-simple-copy-line-or-region)
    (define-key map (kbd "C-S-y") #'prot-simple-yank-replace-line-or-region)
    (define-key map (kbd "M-SPC") #'cycle-spacing)
    (define-key map (kbd "M-o") #'delete-blank-lines)   ; alias for C-x C-o
    (define-key map (kbd "M-k") #'prot-simple-kill-line-backward)
    (define-key map (kbd "C-S-n") #'prot-simple-multi-line-next)
    (define-key map (kbd "C-S-p") #'prot-simple-multi-line-prev)
    (define-key map (kbd "&lt;C-return&gt;") #'prot-simple-new-line-below)
    (define-key map (kbd "&lt;C-S-return&gt;") #'prot-simple-new-line-above)
    ;; Commands for text insertion or manipulation
    (define-key map (kbd "C-=") #'prot-simple-insert-date)
    (define-key map (kbd "C-&lt;") #'prot-simple-escape-url)
    (define-key map (kbd "C-'") #'prot-simple-insert-pair)
    (define-key map (kbd "M-'") #'prot-simple-insert-pair)
    (define-key map (kbd "M-\\") #'prot-simple-delete-pair-dwim)
    (define-key map (kbd "C-M-;") #'prot-simple-cite-region)
    (define-key map (kbd "C-M-^") #'prot-simple-insert-undercaret)
    (define-key map (kbd "&lt;C-M-backspace&gt;") #'backward-kill-sexp)
    (define-key map (kbd "M-c") #'capitalize-dwim)
    (define-key map (kbd "M-l") #'downcase-dwim)        ; "lower" case
    (define-key map (kbd "M-u") #'upcase-dwim)
    ;; Commands for object transposition
    (define-key map (kbd "C-t") #'prot-simple-transpose-chars)
    (define-key map (kbd "C-x C-t") #'prot-simple-transpose-lines)
    (define-key map (kbd "C-S-t") #'prot-simple-transpose-paragraphs)
    (define-key map (kbd "C-x M-t") #'prot-simple-transpose-sentences)
    (define-key map (kbd "C-M-t") #'prot-simple-transpose-sexps)
    (define-key map (kbd "M-t") #'prot-simple-transpose-words)
    ;; Commands for marking objects
    (define-key map (kbd "M-@") #'prot-simple-mark-word)       ; replaces `mark-word'
    (define-key map (kbd "C-M-SPC") #'prot-simple-mark-construct-dwim)
    (define-key map (kbd "C-M-d") #'prot-simple-downward-list)
    ;; Commands for paragraphs
    (define-key map (kbd "M-Q") #'prot-simple-unfill-region-or-paragraph)
    ;; Commands for windows
    (define-key map (kbd "C-x n n") #'prot-simple-narrow-dwim) ; replaces `narrow-to-region'
    (define-key map (kbd "C-x M") #'prot-simple-monocle)
    ;; Commands for buffers
    (define-key map (kbd "M-=") #'count-words)
    (define-key map (kbd "&lt;C-f2&gt;") #'prot-simple-rename-file-and-buffer)
    (define-key map (kbd "C-x K") #'prot-simple-kill-buffer-current)))
</pre>
</div>

<p>
These are the contents of the <code>prot-simple.el</code> library (find the file in
<a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (as with all my Elisp code)):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-simple.el --- Common commands for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Common commands for my Emacs: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile
  (require 'cl-lib))
(require 'prot-common)

(defgroup prot-simple ()
  "Generic utilities for my dotemacs."
  :group 'editing)

;; Got those numbers from `string-to-char'
(defcustom prot-simple-insert-pair-alist
  '(("' Single quote"        . (39 39))     ; ' '
    ("\" Double quotes"      . (34 34))     ; " "
    ("` Elisp quote"         . (96 39))     ; ` '
    ("‘ Single apostrophe"   . (8216 8217)) ; ‘ ’
    ("“ Double apostrophes"  . (8220 8221)) ; “ ”
    ("( Parentheses"         . (40 41))     ; ( )
    ("{ Curly brackets"      . (123 125))   ; { }
    ("[ Square brackets"     . (91 93))     ; [ ]
    ("&lt; Angled brackets"     . (60 62))     ; &lt; &gt;
    ("« Εισαγωγικά Gr quote" . (171 187))   ; « »
    ("= Equals signs"        . (61 61))     ; = =
    ("~ Tilde"               . (126 126))   ; ~ ~
    ("* Asterisks"           . (42 42))     ; * *
    ("/ Forward Slash"       . (47 47))     ; / /
    ("_ underscores"         . (95 95)))    ; _ _
  "Alist of pairs for use with `prot-simple-insert-pair-completion'."
  :type 'alist
  :group 'prot-simple)

(defcustom prot-simple-date-specifier "%F"
  "Date specifier for `format-time-string'.
Used by `prot-simple-inset-date'."
  :type 'string
  :group 'prot-simple)

(defcustom prot-simple-time-specifier "%R %z"
  "Time specifier for `format-time-string'.
Used by `prot-simple-inset-date'."
  :type 'string
  :group 'prot-simple)

(defcustom prot-simple-focusable-help-commands
  '( describe-symbol describe-function
     describe-variable describe-key
     view-lossage)
  "Commands whose buffers should be focused when displayed.
This makes it easier to dismiss them at once.

Also see `prot-simple-focus-help-buffers'."
  :type '(repeat symbol)
  :group 'prot-simple)

(defcustom prot-simple-scratch-buffer-default-mode 'markdown-mode
  "Default major mode for `prot-simple-scratch-buffer'."
  :type 'symbol
  :group 'prot-simple)

;;; Generic setup

;;;; Scratch buffers
;; The idea is based on the `scratch.el' package by Ian Eure:
;; &lt;https://github.com/ieure/scratch-el&gt;.

;; Adapted from the `scratch.el' package by Ian Eure.
(defun prot-simple--scratch-list-modes ()
  "List known major modes."
  (cl-loop for sym the symbols of obarray
           for name = (symbol-name sym)
           when (and (functionp sym)
                     (not (member sym minor-mode-list))
                     (string-match "-mode$" name)
                     (not (string-match "--" name)))
           collect name))

(defun prot-simple--scratch-buffer-setup (region &amp;optional mode)
  "Add contents to `scratch' buffer and name it accordingly.

REGION is added to the contents to the new buffer.

Use the current buffer's major mode by default.  With optional
MODE use that major mode instead."
  (let* ((major (or mode major-mode))
         (string (format "Scratch buffer for: %s\n\n" major))
         (text (concat string region))
         (buf (format "*Scratch for %s*" major)))
    (with-current-buffer (get-buffer-create buf)
      (funcall major)
	  (save-excursion
        (insert text)
        (goto-char (point-min))
        (comment-region (point-at-bol) (point-at-eol)))
	  (vertical-motion 2))
    (pop-to-buffer buf)))

;;;###autoload
(defun prot-simple-scratch-buffer (&amp;optional arg)
  "Produce a bespoke scratch buffer matching current major mode.

With optional ARG as a prefix argument (\\[universal-argument]),
use `prot-simple-scratch-buffer-default-mode'.

With ARG as a double prefix argument, prompt for a major mode
with completion.

If region is active, copy its contents to the new scratch
buffer."
  (interactive "P")
  (let* ((default-mode prot-simple-scratch-buffer-default-mode)
         (modes (prot-simple--scratch-list-modes))
         (region (with-current-buffer (current-buffer)
                   (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning)
                        (region-end))
                     "")))
         (m))
    (pcase (prefix-numeric-value arg)
      (16 (progn
            (setq m (intern (completing-read "Select major mode: " modes nil t)))
            (prot-simple--scratch-buffer-setup region m)))
      (4 (prot-simple--scratch-buffer-setup region default-mode))
      (_ (prot-simple--scratch-buffer-setup region)))))

;; ;; DEPRECATED 2021-10-15: Just set `help-window-select' to non-nil.
;;
;; ;;;; Focus auxiliary buffers
;; 
;; ;; TODO 2021-08-27: Is there a more general way to do this without
;; ;; specifying the BUF?  That way we would only need one function.
;; (defmacro prot-simple--auto-focus-buffer (fn doc buf)
;;   "Produce FN with DOC for focusing BUF."
;;   `(defun ,fn (&amp;rest _)
;;     ,doc
;;     (when-let ((window (get-buffer-window ,buf)))
;;       (select-window window))))
;; 
;; (prot-simple--auto-focus-buffer
;;  prot-simple--help-focus
;;   "Select window with Help buffer.
;; Intended as :after advice for `describe-symbol' and friends."
;;   (help-buffer))
;; 
;; (prot-simple--auto-focus-buffer
;;  prot-simple--messages-focus
;;   "Select window with Help buffer.
;; Intended as :after advice for `view-echo-area-messages'."
;;   (messages-buffer))
;; 
;; ;;;###autoload
;; (define-minor-mode prot-simple-focus-help-buffers
;;   "Add advice to focus `prot-simple-focusable-help-commands'."
;;   :lighter nil
;;   (if prot-simple-focus-help-buffers
;;       (progn
;;         (dolist (fn prot-simple-focusable-help-commands)
;;           (advice-add fn :after 'prot-simple--help-focus))
;;         (advice-add 'view-echo-area-messages :after 'prot-simple--messages-focus))
;;     (dolist (fn prot-simple-focusable-help-commands)
;;       (advice-remove fn 'prot-simple--help-focus))
;;     (advice-remove 'view-echo-area-messages 'prot-simple--messages-focus)))

;;;; Rename Help buffers (EXPERIMENTAL)

(defvar prot-simple-help-mode-post-render-hook nil
  "Hook that runs after Help is rendered (via `advice-add').")

(defun prot-simple--help-mode-post-render (&amp;rest _)
  "Run `prot-simple-help-mode-post-render-hook'."
  (run-hooks 'prot-simple-help-mode-post-render-hook))

(defconst prot-simple--help-symbol-regexp
  ;; TODO 2021-10-12: Avoid duplication in regexp.
  (concat
   "^\\(.*?\\)\s\\(is an?\\|runs the\\)\s\\(command\\|function\\|variable\\|keymap variable"
   "\\|native compiled Lisp function\\|interactive native compiled Lisp function"
   "\\|built-in function\\|interactive built-in function\\|Lisp closure\\)\s"
   "\\(\\_&lt;.*?\\_&gt;\\)\\( (found in .*)\\)?")
  "Regexp to match Help buffer description.")

(defconst prot-simple--help-symbol-false-positives
  "\\(in\\|defined\\)"
  "False positives for `prot-simple--help-symbol-regexp'.")

(defun prot-simple--rename-help-buffer ()
  "Rename the current Help buffer."
  (with-current-buffer (help-buffer)
    (goto-char (point-min))
    (when (re-search-forward prot-simple--help-symbol-regexp nil t)
      (let* ((thing (match-string 1))
             (symbol (match-string 4))
             (scope (match-string 5))
             (description (cond
                           (scope
                            (concat symbol scope))
                           ((and (not (string-match-p prot-simple--help-symbol-false-positives symbol))
                                 (symbolp (intern symbol)))
                            symbol)
                           ((match-string 3)))))
        (rename-buffer
         (format "*%s (%s) # Help*" thing description)
         t)))))

;;;###autoload
(define-minor-mode prot-simple-rename-help-buffers
  "Rename Help buffers based on their contents."
  :init-value nil
  :global t
  (if prot-simple-rename-help-buffers
      (progn
        (advice-add #'help-window-setup :after #'prot-simple--help-mode-post-render)
        (add-hook 'prot-simple-help-mode-post-render-hook #'prot-simple--rename-help-buffer))
    (advice-remove #'help-window-setup #'prot-simple--help-mode-post-render)
    (remove-hook 'prot-simple-help-mode-post-render-hook #'prot-simple--rename-help-buffer)))

;;; Commands

;;;; General commands

(autoload 'symbol-at-point "thingatpt")

;;;###autoload
(defun prot-simple-describe-symbol ()
  "Run `describe-symbol' for the `symbol-at-point'."
  (interactive)
  (describe-symbol (symbol-at-point)))

;;;; Commands for lines

;;;###autoload
(defun prot-simple-new-line-below (&amp;optional arg)
  "Create an empty line below the current one.
Move the point to the absolute beginning.  Adapt indentation by
passing optional prefix ARG (\\[universal-argument]).  Also see
`prot-simple-new-line-above'."
  (interactive "P")
  (end-of-line)
  (if arg
      (newline-and-indent)
    (newline)))

;;;###autoload
(defun prot-simple-new-line-above (&amp;optional arg)
  "Create an empty line above the current one.
Move the point to the absolute beginning.  Adapt indentation by
passing optional prefix ARG (\\[universal-argument])."
  (interactive "P")
  (let ((indent (or arg nil)))
    (if (or (bobp)
            (line-number-at-pos (point-min)))
        (progn
          (beginning-of-line)
          (newline)
          (forward-line -1))
      (forward-line -1)
      (prot-simple-new-line-below indent))))

;;;###autoload
(defun prot-simple-copy-line-or-region (&amp;optional arg)
  "Kill-save the current line or active region.
With optional ARG (\\[universal-argument]) duplicate the target
instead.  When region is active, also apply context-aware
indentation while duplicating."
  (interactive "P")
  (unless mark-ring                  ; needed when entering a new buffer
    (push-mark (point) t nil))
  (let* ((rbeg (region-beginning))
         (rend (region-end))
         (pbol (point-at-bol))
         (peol (point-at-eol))
         (indent (if (eq (or rbeg rend) pbol) nil arg)))
    (cond
     ((use-region-p)
      (if arg
          (let ((text (buffer-substring rbeg rend)))
            (when (eq (point) rbeg)
              (exchange-point-and-mark))
            (prot-simple-new-line-below indent)
            (insert text))
        (copy-region-as-kill rbeg rend)
        (message "Current region copied")))
     (t
      (if arg
          (let ((text (buffer-substring pbol peol)))
            (goto-char (point-at-eol))
            (newline)
            (insert text))
        (copy-region-as-kill pbol peol)
        (message "Current line copied"))))))

;;;###autoload
(defun prot-simple-yank-replace-line-or-region ()
  "Replace line or region with latest kill.
This command can then be followed by the standard
`yank-pop' (default is bound to \\[yank-pop])."
  (interactive)
  (if (use-region-p)
      (delete-region (region-beginning) (region-end))
    (delete-region (point-at-bol) (point-at-eol)))
  (yank))

;;;###autoload
(defun prot-simple-multi-line-next ()
  "Move point 15 lines down."
  (interactive)
  (forward-line 15))

;;;###autoload
(defun prot-simple-multi-line-prev ()
  "Move point 15 lines up."
  (interactive)
  (forward-line -15))

;;;###autoload
(defun prot-simple-kill-line-backward ()
  "Kill from point to the beginning of the line."
  (interactive)
  (kill-line 0))

;;;; Commands for text insertion or manipulation

(defvar prot-simple--character-hist '()
  "History of inputs for `prot-simple-insert-pair-completion'.")

(defun prot-simple--character-prompt (chars)
  "Helper of `prot-simple-insert-pair-completion' to read CHARS."
  (let ((def (car prot-simple--character-hist)))
    (completing-read
     (format "Select character [%s]: " def)
     chars nil t nil 'prot-simple--character-hist def)))

(define-obsolete-function-alias
  'prot-simple-insert-pair-completion
  'prot-simple-insert-pair "2021-07-30")

;;;###autoload
(defun prot-simple-insert-pair (pair &amp;optional count)
  "Insert PAIR from `prot-simple-insert-pair-alist'.
Operate on the symbol at point.  If the region is active, use it
instead.

With optional COUNT (either as a natural number from Lisp or a
universal prefix argument (\\[universal-argument]) when used
interactively) prompt for the number of delimiters to insert."
  (interactive
   (list
    (prot-simple--character-prompt prot-simple-insert-pair-alist)
    current-prefix-arg))
  (let* ((data prot-simple-insert-pair-alist)
         (left (cadr (assoc pair data)))
         (right (caddr (assoc pair data)))
         (n (cond
             ((and count (natnump count))
              count)
             (count
              (read-number "How many delimiters?" 2))
             (1)))
         (beg)
         (end))
    (cond
     ((region-active-p)
      (setq beg (region-beginning)
            end (region-end)))
     ((when (thing-at-point 'symbol)
        (let ((bounds (bounds-of-thing-at-point 'symbol)))
          (setq beg (car bounds)
                end (cdr bounds)))))
     (t (setq beg (point)
              end (point))))
    (save-excursion
      (goto-char end)
      (dotimes (_ n)
        (insert right))
      (goto-char beg)
      (dotimes (_ n)
        (insert left)))))

;;;###autoload
(defun prot-simple-delete-pair-dwim ()
  "Delete pair following or preceding point.
For Emacs version 28 or higher, the feedback's delay is
controlled by `delete-pair-blink-delay'."
  (interactive)
  (if (eq (point) (cdr (bounds-of-thing-at-point 'sexp)))
      (delete-pair -1)
    (delete-pair 1)))

;;;###autoload
(defun prot-simple-insert-date (&amp;optional arg)
  "Insert the current date as `prot-simple-date-specifier'.

With optional prefix ARG (\\[universal-argument]) also append the
current time understood as `prot-simple-time-specifier'.

When region is active, delete the highlighted text and replace it
with the specified date."
  (interactive "P")
  (let* ((date prot-simple-date-specifier)
         (time prot-simple-time-specifier)
         (format (if arg (format "%s %s" date time) date)))
    (when (use-region-p)
      (delete-region (region-beginning) (region-end)))
    (insert (format-time-string format))))


(autoload 'ffap-url-at-point "ffap")
(defvar ffap-string-at-point-region)

;;;###autoload
(defun prot-simple-escape-url ()
  "Wrap URL (or email address) in angled brackets."
  (interactive)
  (when-let ((url (ffap-url-at-point)))
    (let* ((reg ffap-string-at-point-region)
           (beg (car reg))
           (end (cadr reg))
           (string (if (string-match-p "^mailto:" url)
                       (substring url 7)
                     url)))
      (delete-region beg end)
      (insert (format "&lt;%s&gt;" string)))))

;;;###autoload
(defun prot-simple-cite-region (beg end &amp;optional arg)
  "Cite text in region lines between BEG and END.

Region lines are always understood in absolute terms, regardless
of whether the region boundaries coincide with them.

With optional prefix ARG (\\[universal-argument]) prompt for a
description that will be placed on a new line at the top of the
newly formatted text."
  (interactive "*r\nP")
  (let* ((absolute-beg (if (&lt; beg end)
                           (progn (goto-char beg) (point-at-bol))
                         (progn (goto-char end) (point-at-eol))))
         (absolute-end (if (&lt; beg end)
                           (progn (goto-char end) (point-at-eol))
                         (progn (goto-char beg) (point-at-bol))))
         (prefix-text (if (&lt; beg end)
                          (buffer-substring-no-properties absolute-beg beg)
                        (buffer-substring-no-properties absolute-end end)))
         (prefix (if (string-match-p "\\`[\t\s]+\\'" prefix-text)
                     prefix-text
                   (replace-regexp-in-string "\\`\\([\t\s]+\\).*" "\\1" prefix-text)))
         (description (if arg
                          (format "+----[ %s ]\n"
                                  (read-string "Add description: "))
                        "+----\n"))
         (marked-text (buffer-substring-no-properties absolute-beg absolute-end))
         (marked-text-new (replace-regexp-in-string "^.*?" (concat prefix "|") marked-text))
         (text (with-temp-buffer
                 (insert marked-text-new)
                 (save-excursion
                   (goto-char (point-min))
                   (re-search-forward "^\\(^[\s\t]+\\)?.*?")
                   (forward-line -1)
                   (insert (concat prefix description))
                   (goto-char (point-max))
                   (forward-line 1)
                   (insert "\n")
                   (insert (concat prefix "+----")))
                 (buffer-substring-no-properties (point-min) (point-max)))))
    (delete-region absolute-beg absolute-end)
    (insert text)))

;; `prot-simple-insert-undercaret' was offered to me by Gregory
;; Heytings: &lt;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=45068#250&gt;.
;;;###autoload
(defun prot-simple-insert-undercaret (&amp;optional arg)
  "Draw carets below the characters on the current line or region."
  (interactive "p")
  (let* ((begin (if (region-active-p) (region-beginning) (line-beginning-position)))
         (end (if (region-active-p) (region-end) (line-end-position)))
         (lines (- (line-number-at-pos end) (line-number-at-pos begin) -1))
         (comment (and (/= arg 1) (= lines 1)))
         (final-forward-line -1))
    (goto-char begin)
    (dotimes (i lines)
      (let* ((line-begin (if (zerop i) begin (line-beginning-position)))
             (line-end (if (= (1+ i) lines) end (line-end-position)))
             (begin-column (progn (goto-char line-begin) (current-column)))
             (end-column (progn (goto-char line-end) (current-column)))
             (prefix-begin (line-beginning-position))
             (prefix-end (progn (beginning-of-line-text) (point)))
             (prefix-end-column (progn (goto-char prefix-end) (current-column)))
             (delta (if (&lt; begin-column prefix-end-column) (- prefix-end-column begin-column) 0))
             (prefix-string (buffer-substring-no-properties prefix-begin prefix-end))
             (prefix (if (string-match-p "\\` *\\'" prefix-string) "" prefix-string))
             (whitespace (make-string (- (+ begin-column delta) (string-width prefix)) ?\ ))
             (do-under (&lt; delta (- line-end line-begin)))
             (under (if do-under (make-string (- end-column begin-column delta) ?^) ""))
             (under-string (concat prefix whitespace under "\n")))
        (forward-line 1)
        (if do-under (insert under-string) (setq final-forward-line -2))
        (setq end (+ end (length under-string)))
        (when comment (insert prefix whitespace "\n"))))
    (forward-line final-forward-line)
    (goto-char (line-end-position))))

;;;; Commands for object transposition

(defmacro prot-simple-transpose (name scope &amp;optional doc)
  "Macro to produce transposition functions.
NAME is the function's symbol.  SCOPE is the text object to
operate on.  Optional DOC is the function's docstring.

Transposition over an active region will swap the object at
mark (region beginning) with the one at point (region end)"
  `(defun ,name (arg)
     ,doc
     (interactive "p")
     (let ((x (format "%s-%s" "transpose" ,scope)))
       (if (use-region-p)
           (funcall (intern x) 0)
         (funcall (intern x) arg)))))

(prot-simple-transpose
 prot-simple-transpose-lines
 "lines"
 "Transpose lines or swap over active region.")

(prot-simple-transpose
 prot-simple-transpose-paragraphs
 "paragraphs"
 "Transpose paragraphs or swap over active region.")

(prot-simple-transpose
 prot-simple-transpose-sentences
 "sentences"
 "Transpose sentences or swap over active region.")

(prot-simple-transpose
 prot-simple-transpose-sexps
 "sexps"
 "Transpose balanced expressions or swap over active region.")

;;;###autoload
(defun prot-simple-transpose-chars ()
  "Always transposes the two characters before point.
There is no 'dragging' the character forward.  This is the
behaviour of `transpose-chars' when point is at the end of the
line."
  (interactive)
  (transpose-chars -1)
  (forward-char))

;;;###autoload
(defun prot-simple-transpose-words (arg)
  "Transpose ARG words.

If region is active, swap the word at mark (region beginning)
with the one at point (region end).

Otherwise, and while inside a sentence, this behaves as the
built-in `transpose-words', dragging forward the word behind the
point.  The difference lies in its behaviour at the end or
beginnning of a line, where it will always transpose the word at
point with the one behind or ahead of it (effectively the
last/first two words)."
  (interactive "p")
  (cond
   ((use-region-p)
    (transpose-words 0))
   ((eq (point) (point-at-eol))
    (transpose-words -1))
   ((eq (point) (point-at-bol))
    (forward-word 1)
    (transpose-words 1))
   (t
    (transpose-words arg))))

;;;; Commands for marking syntactic constructs

(defmacro prot-simple-mark (name object &amp;optional docstring)
  "Produce function for marking small syntactic constructs.
NAME is how the function should be called.  OBJECT is its scope.
Optional DOCSTRING describes the resulting function.

This is a slightly modified version of the built-in `mark-word'."
  `(defun ,name (&amp;optional arg allow-extend)
     ,docstring
     (interactive "P\np")
     (let ((x (format "%s-%s" "forward" ,object)))
       (cond ((and allow-extend
                   (or (and (eq last-command this-command) (mark t))
                       (region-active-p)))
              (setq arg (if arg (prefix-numeric-value arg)
                          (if (&lt; (mark) (point)) -1 1)))
              (set-mark
               (save-excursion
                 (goto-char (mark))
                 (funcall (intern x) arg)
                 (point))))
             (t
              (let ((bounds (bounds-of-thing-at-point (intern ,object))))
                (unless (consp bounds)
                  (user-error "No %s at point" ,object))
                (if (&gt;= (prefix-numeric-value arg) 0)
                    (goto-char (car bounds))
                  (goto-char (cdr bounds)))
                (push-mark
                 (save-excursion
                   (funcall (intern x) (prefix-numeric-value arg))
                   (point)))
                (activate-mark)))))))

(prot-simple-mark
 prot-simple-mark-word
 "word"
 "Mark the whole word at point.
This function is a slightly modified version of the built-in
`mark-word', that I intend to use only in special circumstances,
such as when recording a keyboard macro where precision is
required.  For a general purpose utility, use `prot-simple-mark-symbol'
instead.")

(prot-simple-mark
 prot-simple-mark-symbol
 "symbol"
 "Mark the whole symbol at point.
With optional ARG, mark the current symbol and any remaining
ARGth symbols away from point.  A negative argument moves
backward. Repeated invocations of this command mark the next
symbol in the direction originally specified.

In the absence of a symbol and if a word is present at point,
this command will operate on it as described above.")

;;;###autoload
(defun prot-simple-mark-sexp-backward (&amp;optional arg)
  "Mark previous or ARGth balanced expression[s].
Just a convenient backward-looking `mark-sexp'."
  (interactive "P")
  (if arg
      (mark-sexp (- arg) t)
    (mark-sexp (- 1) t)))

;;;###autoload
(defun prot-simple-mark-construct-dwim (&amp;optional arg)
  "Mark symbol or balanced expression at point.
A do-what-I-mean wrapper for `prot-simple-mark-sexp-backward',
`mark-sexp', and `prot-simple-mark-symbol'.

When point is over a symbol, mark the entirety of it.  Regular
words are interpreted as symbols when an actual symbol is not
present.

For balanced expressions, a backward match will happen when point
is to the right of the closing delimiter.  A forward match is the
fallback condition and should work when point is before a
balanced expression, with or without whitespace in between it an
the opening delimiter.

Optional ARG will mark a total of ARGth objects while counting
the current one (so 3 would be 1+2 more).  A negative count moves
the mark backward (though that would invert the backward-moving
sexp matching of `prot-simple-mark-sexp-backward', so be mindful of
where the point is).  Repeated invocations of this command
incrementally mark objects in the direction originally
specified."
  (interactive "P")
  (cond
   ((symbol-at-point)
    (prot-simple-mark-symbol arg t))
   ((eq (point) (cdr (bounds-of-thing-at-point 'sexp)))
    (prot-simple-mark-sexp-backward arg))
   (t
    (mark-sexp arg t))))

;;;; Commands for code navigation (work in progress)

;;;###autoload
(defun prot-simple-downward-list (&amp;optional arg)
  "Like `backward-up-list' but defaults to a forward motion.
With optional ARG, move that many times in the given
direction (negative is forward due to this being a
'backward'-facing command)."
  (interactive "P")
  (backward-up-list (or arg -1)))

;;;; Commands for paragraphs

(defvar-local prot-simple--auto-fill-cycle-state 1
  "Representation of `prot-simple-auto-fill-cycle' state.")

;; Based on gungadin-cylocal.el (private communication with Christopher
;; Dimech---disclosed with permission).
;;;###autoload
(defun prot-simple-auto-fill-cycle ()
  "Cycles auto fill for comments, everything, nothing."
  (interactive)
  (let ((n prot-simple--auto-fill-cycle-state))
    (pcase n
      (2
       (message "Auto fill %s" (propertize "buffer" 'face 'warning))
       (setq-local comment-auto-fill-only-comments nil)
       (setq-local prot-simple--auto-fill-cycle-state (1+ n)))
      (3
       (message "Disable auto fill")
       (auto-fill-mode 0)
       (setq-local prot-simple--auto-fill-cycle-state (1+ n)))
      (_
       (message "Auto fill %s" (propertize "comments" 'face 'success))
       (setq-local comment-auto-fill-only-comments t)
       (auto-fill-mode 1)
       (setq-local prot-simple--auto-fill-cycle-state 2)))))

;;;###autoload
(defun prot-simple-unfill-region-or-paragraph (&amp;optional beg end)
  "Unfill paragraph or, when active, the region.
Join all lines in region delimited by BEG and END, if active,
while respecting any empty lines (so multiple paragraphs are not
joined, just unfilled).  If no region is active, operate on the
paragraph.  The idea is to produce the opposite effect of both
`fill-paragraph' and `fill-region'."
  (interactive "r")
  (let ((fill-column most-positive-fixnum))
    (if (use-region-p)
        (fill-region beg end)
      (fill-paragraph))))

;;;; Commands for windows

;;;###autoload
(defun prot-simple-narrow-visible-window ()
  "Narrow buffer to wisible window area.
Also check `prot-simple-narrow-dwim'."
  (interactive)
  (let* ((bounds (prot-common-window-bounds))
         (window-area (- (cadr bounds) (car bounds)))
         (buffer-area (- (point-max) (point-min))))
    (if (/= buffer-area window-area)
        (narrow-to-region (car bounds) (cadr bounds))
      (user-error "Buffer fits in the window; won't narrow"))))

;;;###autoload
(defun prot-simple-narrow-dwim ()
  "Do-what-I-mean narrowing.
If region is active, narrow the buffer to the region's
boundaries.

If no region is active, narrow to the visible portion of the
window.

If narrowing is in effect, widen the view."
  (interactive)
  (unless mark-ring                  ; needed when entering a new buffer
    (push-mark (point) t nil))
  (cond
   ((and (use-region-p)
         (null (buffer-narrowed-p)))
    (let ((beg (region-beginning))
          (end (region-end)))
      (narrow-to-region beg end)))
   ((null (buffer-narrowed-p))
    (prot-simple-narrow-visible-window))
   (t
    (widen)
    (recenter))))

;; Inspired by Pierre Neidhardt's windower:
;; https://gitlab.com/ambrevar/emacs-windower/-/blob/master/windower.el
(defvar prot-simple--windows-current nil
  "Current window configuration.")

;;;###autoload
(define-minor-mode prot-simple-monocle
  "Toggle between multiple windows and single window.
This is the equivalent of maximising a window.  Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
  :lighter " -M-"
  :global nil
  (let ((win prot-simple--windows-current))
    (if (one-window-p)
        (when win
          (set-window-configuration win))
      (setq prot-simple--windows-current (current-window-configuration))
      (delete-other-windows))))

(defun prot-simple--monocle-disable ()
  "Set variable `prot-simple-monocle' to nil, when appropriate.
To be hooked to `window-configuration-change-hook'."
  (when (and prot-simple-monocle (not (one-window-p)))
    (delete-other-windows)
    (prot-simple-monocle -1)
    (set-window-configuration prot-simple--windows-current)))

(add-hook 'window-configuration-change-hook #'prot-simple--monocle-disable)

;;;; Commands for buffers

;;;###autoload
(defun prot-simple-kill-buffer-current (&amp;optional arg)
  "Kill current buffer or abort recursion when in minibuffer.
With optional prefix ARG (\\[universal-argument]) delete the
buffer's window as well."
  (interactive "P")
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer)))
  (when (and arg
             (not (one-window-p)))
    (delete-window)))

;;;###autoload
(defun prot-simple-rename-file-and-buffer (name)
  "Apply NAME to current file and rename its buffer.
Do not try to make a new directory or anything fancy."
  (interactive
   (list (read-string "Rename current file: " (buffer-file-name))))
  (let ((file (buffer-file-name)))
    (if (vc-registered file)
        (vc-rename-file file name)
      (rename-file file name))
    (set-visited-file-name name t t)))

(provide 'prot-simple)
;;; prot-simple.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:6bbc41d6-da7c-4301-84c6-c5887c29283f" class="outline-4">
<h4 id="h:6bbc41d6-da7c-4301-84c6-c5887c29283f"><span class="section-number-4">2.2.1.</span> prot-pulse.el (highlight cursor position)</h4>
<div class="outline-text-4" id="text-h:6bbc41d6-da7c-4301-84c6-c5887c29283f">
<p>
<code>pulse.el</code> is a library that provides utilities for highlighting the
region or area around point.  It is meant to be used by other packages
as a means of offering visual feedback, as is the case with, for
example, <code>M-.</code> (<code>xref-find-definitions</code>).
</p>

<p>
While <code>prot-pulse.el</code> (complete code further below) is a thin wrapper that
provides some extensions that are useful to my workflow.  Specifically,
it declares a new face and defines a command that implements it:
<code>prot-pulse-pulse-line</code>.  This is useful to quickly highlight the line and
buffer I am on, but can also be utilised by other tools that move the
point an arbitrary distance.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-pulse.el (highlight cursor position)
(prot-emacs-builtin-package 'prot-pulse
  (setq prot-pulse-pulse-command-list
        '(recenter-top-bottom
          move-to-window-line-top-bottom
          reposition-window
          bookmark-jump
          other-window
          scroll-up-command
          scroll-down-command
          org-next-visible-heading
          org-previous-visible-heading
          org-forward-heading-same-level
          org-backward-heading-same-level
          org-tree-slide-move-next-tree
          org-tree-slide-move-previous-tree))
  (prot-pulse-advice-commands-mode 1)
  (define-key global-map (kbd "C-x l") #'prot-pulse-pulse-line)) ; override `count-lines-page'
</pre>
</div>

<p>
This is the code for <code>prot-pulse.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>, in case
you wish to get the file):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-pulse.el --- Extend pulse.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions to the built-in `pulse.el' library for my Emacs
;; configuration: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'pulse)

(defgroup prot-pulse ()
  "Extensions for `pulse.el'."
  :group 'editing)

(defcustom prot-pulse-pulse-command-list
  '(recenter-top-bottom reposition-window)
  "Commands that should automatically `prot-pulse-pulse-line'.
You must restart function `prot-pulse-advice-commands-mode' for
changes to take effect."
  :type 'list
  :group 'prot-pulse)

(defface prot-pulse-line
  '((default :extend t)
    (((class color) (min-colors 88) (background light))
     :background "#8eecf4")
    (((class color) (min-colors 88) (background dark))
     :background "#004065")
    (t :inverse-video t))
  "Default face for `prot-pulse-pulse-line'."
  :group 'prot-pulse)

;;;###autoload
(defun prot-pulse-pulse-line (&amp;optional face)
  "Temporarily highlight the current line with optional FACE."
  (interactive)
  (let ((start (if (eobp)
                   (line-beginning-position 0)
                 (line-beginning-position)))
        (end (line-beginning-position 2))
        (pulse-delay .04)
        (face (or face 'prot-pulse-line)))
    (pulse-momentary-highlight-region start end face)))

;;;###autoload
(defun prot-pulse-recentre-top ()
  "Reposition at the top and pulse line.
Add this to a hook, such as `imenu-after-jump-hook'."
  (let ((pulse-delay .05))
    (recenter 0)
    (prot-pulse-pulse-line)))

;;;###autoload
(defun prot-pulse-recentre-centre ()
  "Recentre and pulse line.
Add this to a hook, such as `imenu-after-jump-hook'."
  (let ((pulse-delay .05))
    (recenter nil)
    (prot-pulse-pulse-line)))

(autoload 'org-at-heading-p "org")
(autoload 'org-show-entry "org")
(autoload 'org-reveal "org")
(autoload 'outline-show-entry "outline")

;;;###autoload
(defun prot-pulse-show-entry ()
  "Reveal index at point in outline views.
To be used with a hook such as `imenu-after-jump-hook'."
  (cond
   ((and (eq major-mode 'org-mode)
         (org-at-heading-p))
    (org-show-entry)
    (org-reveal t))
   ((bound-and-true-p prot-outline-minor-mode)
    (outline-show-entry))))

(defvar prot-pulse-after-command-hook nil
  "Hook that runs after select commands.
To be used with `advice-add' after those functions declared in
`prot-pulse-pulse-command-list'.")

(defun prot-pulse-after-command (&amp;rest _)
  "Run `prot-pulse-after-command-hook'."
  (run-hooks 'prot-pulse-after-command-hook))

;;;###autoload
(define-minor-mode prot-pulse-advice-commands-mode
  "Set up for `prot-pulse-pulse-command-list'."
  :init-value nil
  :global t
  (if prot-pulse-advice-commands-mode
      (progn
        (dolist (fn prot-pulse-pulse-command-list)
          (advice-add fn :after #'prot-pulse-after-command))
        (add-hook 'prot-pulse-after-command-hook #'prot-pulse-pulse-line))
    (dolist (fn prot-pulse-pulse-command-list)
      (advice-remove fn #'prot-pulse-after-command))
    (remove-hook 'prot-pulse-after-command-hook #'prot-pulse-pulse-line)))

(provide 'prot-pulse)
;;; prot-pulse.el ends here
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:b24ce3fc-a12c-4d21-93d7-c1e7bd36a65d" class="outline-3">
<h3 id="h:b24ce3fc-a12c-4d21-93d7-c1e7bd36a65d"><span class="section-number-3">2.3.</span> Make Custom UI code disposable</h3>
<div class="outline-text-3" id="text-h:b24ce3fc-a12c-4d21-93d7-c1e7bd36a65d">
<p>
When you install a package or use the various customisation interfaces
to tweak things to your liking, Emacs will append a piece of Elisp to
your init file.  In my experience, this is a common source of
inconsistencies, arising from a conflict between the user's code and
what is stored in that <code>custom-*</code> snippet.
</p>

<p>
To avoid conflicts, I instruct Emacs to put all "custom" code in a
temporary file (the <code>/tmp</code> path on Linux).  Custom does its work as
expected, but its state does not persist to mess up with my carefully
designed (and version-controlled) configuration.
</p>

<p>
This feels kinda hacky though it gets the job done.
</p>

<p>
Together with Justin Schell we had experimented with using the
<code>null-device</code> instead of a temporary file.  However, that created problems
under certain conditions, as Emacs would issue warnings about it and
prompt on how to proceed.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Make Custom UI code disposable
(prot-emacs-builtin-package 'cus-edit
  ;; Disable the damn thing
  (setq custom-file (make-temp-file "emacs-custom-")))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:abe40d9f-e454-442a-9b9a-77e3b6c0b5db" class="outline-3">
<h3 id="h:abe40d9f-e454-442a-9b9a-77e3b6c0b5db"><span class="section-number-3">2.4.</span> Propagation of shell environment variables (exec-path-from-shell.el)</h3>
<div class="outline-text-3" id="text-h:abe40d9f-e454-442a-9b9a-77e3b6c0b5db">
<p>
Since 2021-09-21 I have been experimenting with Sway, a tiling window
manager for the Wayland display protocol.  One of the major changes to
how the older Xorg display server would handle the initialisation of the
environment is that Wayland does not have a login shell.  Instead,
programs are initialised by the session manager, which in my case is
controlled by systemd (check my dotfiles' git repo for the
technicalities).
</p>

<p>
To cut the long story short, Emacs needs to be made aware of the
environment variables that are available to my Bash shell but which
Wayland has obscured from this contexts.  Thankfully, Steve Purcell's
<code>exec-path-from-shell</code> handles the task splendidly.  In the user option
<code>exec-path-from-shell-variables</code> we specify the environment variables we
want to inform Emacs about.  Then we just invoke the function
<code>exec-path-from-shell-initialize</code> and are good to go.  Now we can get back
to using Emacs the way we did on Xorg.
</p>

<p>
Note that Steve's package is not specifically about Wayland.  Its
documentation makes references to other operating systems.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(prot-emacs-elpa-package 'exec-path-from-shell
  (setq exec-path-from-shell-variables
        '("PATH" "MANPATH" "SSH_AUTH_SOCK"))
  (exec-path-from-shell-initialize))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6" class="outline-3">
<h3 id="h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6"><span class="section-number-3">2.5.</span> Modus themes (my highly accessible themes)</h3>
<div class="outline-text-3" id="text-h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">
<p>
This is a project I started as soon as I switched to Emacs in July 2019.
About a year later the themes became part of upstream Emacs, available
for Emacs version 28 (as of version 0.12.0 of the themes).  I have
benefited a lot from community contributions, of which I am most
thankful of, as discussed in <a href="https://protesilaos.com/codelog/2020-08-27-emacs-modus-themes-core/">My Modus themes are now shipped with Emacs</a>
(2020-08-27).
</p>

<p>
The Modus themes are designed for accessible readability.  They conform
with the highest standard for colour contrast between foreground and
background values.  This stands for a minimum contrast ratio of 7:1,
also known as the WCAG AAA standard (the highest of its kind).
</p>

<p>
The themes are "Modus Operandi" (light) and "Modus Vivendi" (dark).  The
source code is available <a href="https://gitlab.com/protesilaos/modus-themes">on their GitLab page</a> while you can read the
HTML version of <a href="https://protesilaos.com/emacs/modus-themes">their manual on my website</a>.  If you have the package
installed or are using Emacs &gt;=28, you can read the manual from the
built-in Info reader.  Evaluate: <code>(info "(modus-themes) Top")</code>.
</p>

<p>
The manual covers everything from the basics to more advanced,
"do-it-yourself" cases.
</p>

<p>
The list of supported packages is comprehensive and a lot of work goes
into getting the details right.  Plus, there are <b>lots of customisation
options</b> to tweak the looks of the themes (note though that the values I
set for those variables in the following code block are not indicative
of my preferences, as I always try different combinations to test things
across a range of scenaria).
</p>

<p>
Lastly, if you are curious about the underlying methodology, read my
essay <a href="https://protesilaos.com/codelog/2020-03-17-design-modus-themes-emacs/">on the design of the Modus themes</a> (2020-03-17).  And here are some
more resources from my website for those who are really into the minutia
and wish to get a glimpse of how much work goes into this project:
</p>

<ul class="org-ul">
<li><a href="https://protesilaos.com/codelog/2020-05-10-modus-operandi-palette-review/">Modus Operandi theme subtle palette review</a> (2020-05-10)</li>
<li><a href="https://protesilaos.com/codelog/2020-06-13-modus-vivendi-palette-review/">Modus Vivendi theme subtle palette review</a> (2020-06-13)</li>
<li><a href="https://protesilaos.com/codelog/2020-07-04-modus-themes-faint-colours/">Modus themes: new "faint syntax" option</a> (2020-07-04)</li>
<li><a href="https://protesilaos.com/codelog/2020-07-08-modus-themes-nuanced-colours/">Modus themes: major review of "nuanced" colours</a> (2020-07-08)</li>
<li><a href="https://protesilaos.com/codelog/2020-08-09-modus-themes-paren-match/">Modus themes: review "paren-match" colours</a> (2020-08-09)</li>
<li><a href="https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/">Notes for aspiring Emacs theme developers</a> (2020-08-28)</li>
<li><a href="https://protesilaos.com/codelog/2020-09-14-modus-themes-review-blues/">Modus themes: report on the review of the main blue colours</a> (2020-09-14)</li>
<li><a href="https://protesilaos.com/codelog/2020-12-27-modus-themes-review-rainbow-delimiters/">Modus themes: review rainbow-delimiters faces</a> (2020-12-27)</li>
<li><a href="https://protesilaos.com/codelog/2021-01-11-modus-themes-review-select-faint-colours/">Modus themes: review of select "faint" colours</a> (2021-01-11)</li>
<li><a href="https://protesilaos.com/codelog/2021-02-25-modus-themes-diffs-deuteranopia/">The Modus themes now cover deuteranopia in diffs</a> (2021-02-25)</li>
<li><a href="https://protesilaos.com/codelog/2021-05-19-modus-themes-status-update/">Status update on the Modus themes for Emacs</a> (2021-05-19)</li>
<li><a href="https://protesilaos.com/codelog/2021-06-02-modus-themes-org-agenda/">Introducing the variable modus-themes-org-agenda</a> (2021-06-02)</li>
</ul>

<p>
And if you do enjoy reading such entries, then you may also wish to
check the <a href="https://protesilaos.com/emacs/modus-themes-changelog/">Change Log of the Modus themes</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Modus themes (my highly accessible themes)
(prot-emacs-builtin-package 'modus-themes
  ;; Add all your customizations prior to loading the themes
  ;;
  ;; NOTE: these are not my preferences!  I am always testing various
  ;; configurations.  Though I still like what I have here.
  (setq modus-themes-italic-constructs nil
        modus-themes-bold-constructs nil
        modus-themes-mixed-fonts nil
        modus-themes-subtle-line-numbers t
        modus-themes-intense-markup t
        modus-themes-deuteranopia nil
        modus-themes-tabs-accented nil
        modus-themes-variable-pitch-ui nil
        modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

        modus-themes-fringes nil ; {nil,'subtle,'intense}

        ;; Options for `modus-themes-lang-checkers' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `straight-underline', `text-also', `background',
        ;; `intense' OR `faint'.
        modus-themes-lang-checkers nil

        ;; Options for `modus-themes-mode-line' are either nil, or a list
        ;; that can combine any of `3d' OR `moody', `borderless',
        ;; `accented', and a natural number for extra padding
        modus-themes-mode-line '(borderless 4)

        ;; Options for `modus-themes-syntax' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
        modus-themes-syntax nil

        ;; Options for `modus-themes-hl-line' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `accented', `underline', `intense'
        modus-themes-hl-line nil

        ;; Options for `modus-themes-paren-match' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `bold', `intense', `underline'
        modus-themes-paren-match '(intense underline bold)

        ;; Options for `modus-themes-links' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
        ;; `bold', `italic', `background'
        modus-themes-links nil

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `background', `bold', `gray', `intense', `italic'
        modus-themes-prompts nil

        modus-themes-completions nil ; {nil,'moderate,'opinionated}

        modus-themes-mail-citations nil ; {nil,'faint,'monochrome}

        ;; Options for `modus-themes-region' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `no-extend', `bg-only', `accented'
        modus-themes-region '(no-extend)

        ;; Options for `modus-themes-diffs': nil, 'desaturated, 'bg-only
        modus-themes-diffs nil

        modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background}

        modus-themes-org-agenda ; this is an alist: read the manual or its doc string
        '((header-block . (variable-pitch regular 1.4))
          (header-date . (bold-today grayscale underline-today 1.2))
          (event . (accented varied))
          (scheduled . uniform)
          (habit . nil))

        modus-themes-headings nil ; this is an alist: read the manual or its doc string

        ;; ;; For example:
        ;; modus-themes-headings
        ;; '((1 . (variable-pitch light 1.8))
        ;;   (2 . (variable-pitch regular 1.6))
        ;;   (3 . (variable-pitch regular 1.3))
        ;;   (4 . (monochrome 1.2))
        ;;   (5 . (1.1))
        ;;   (t . (rainbow 1.05)))
        )

  ;; Load the theme files before enabling a theme (else you get an error).
  (modus-themes-load-themes)

  ;; Custom faces (for demo purposes---check the themes' manual for more
  ;; advanced uses).
  (defun prot/modus-themes-custom-faces ()
    (modus-themes-with-colors
      (custom-set-faces
       `(fill-column-indicator ((,class :background ,bg-inactive
                                        :foreground ,bg-inactive))))))

  (add-hook 'modus-themes-after-load-theme-hook #'prot/modus-themes-custom-faces)

  ;; Enable the theme at startup.  This is done after loading the files.
  ;; You only need `modus-themes-load-operandi' for the light theme or
  ;; `modus-themes-load-vivendi' for the dark one.  What I have here is
  ;; a simple test to load a light/dark theme based on some general time
  ;; ranges (just accounting for the hour and without checking for the
  ;; actual sunrise/sunset times).  Plus we have `modus-themes-toggle'
  ;; to switch themes at will.
  (let ((time (string-to-number (format-time-string "%H"))))
    (if (and (&gt; time 5) (&lt; time 18))
        (modus-themes-load-operandi)
      (modus-themes-load-vivendi)))

  ;; Also check my package configurations for `prot-fonts' because I use
  ;; the `modus-themes-after-load-theme-hook' for some typeface-related
  ;; tweaks (as those are made at the "face" level).
  (define-key global-map (kbd "&lt;f5&gt;") #'modus-themes-toggle))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:601027a1-7288-4dcd-bb78-435965df27ba" class="outline-3">
<h3 id="h:601027a1-7288-4dcd-bb78-435965df27ba"><span class="section-number-3">2.6.</span> LIN Is Noticeable (lin.el)</h3>
<div class="outline-text-3" id="text-h:601027a1-7288-4dcd-bb78-435965df27ba">
<p>
This is another package of mine.  LIN locally remaps the <code>hl-line</code> face to
a style that is optimal for major modes where line selection is the
primary mode of interaction.
</p>

<p>
The idea is that <code>hl-line</code> cannot work equally well for contexts with
competing priorities: (i) line selection, or (ii) simple line highlight.
In the former case, the current line needs to be made prominent because
it carries a specific meaning of some significance in the given context.
Whereas in the latter case, the primary mode of interaction does not
revolve around the line highlight itself: it may be because the focus is
on editing text or reading through the buffer's contents, so the current
line highlight is more of a gentle reminder of the point's location on
the vertical axis.
</p>

<p>
<code>lin-mode</code> only shows its effect when <code>hl-line-mode</code> is active or, more
specifically, when the <code>hl-line</code> face is used in the buffer.  <code>lin-mode</code>
DOES NOT activate <code>hl-line-mode</code> and does not do anything other than the
aforementioned face remapping.
</p>

<p>
I just enable LIN in contexts where I know it is useful (check the doc
string o <code>lin-add-to-many-modes</code> for the details).  For example:
</p>

<ul class="org-ul">
<li><a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el</a>.</li>
<li><a href="#h:a196812e-1644-4536-84ba-687366867def">Notmuch (mail indexer and mail user agent (MUA))</a>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(prot-emacs-builtin-package 'lin
  (setq lin-foreground-override nil)
  (setq lin-foreign-hooks lin--default-foreign-hooks)
  (lin-add-to-many-modes))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:7a4dd5b8-724d-4f7c-b5ee-01d8ac98bda9" class="outline-3">
<h3 id="h:7a4dd5b8-724d-4f7c-b5ee-01d8ac98bda9"><span class="section-number-3">2.7.</span> Typeface configurations</h3>
<div class="outline-text-3" id="text-h:7a4dd5b8-724d-4f7c-b5ee-01d8ac98bda9">
</div>
<div id="outline-container-h:e03b6415-a18f-4058-b9b0-5721d38c6c50" class="outline-4">
<h4 id="h:e03b6415-a18f-4058-b9b0-5721d38c6c50"><span class="section-number-4">2.7.1.</span> Font configurations (prot-fonts.el)</h4>
<div class="outline-text-4" id="text-h:e03b6415-a18f-4058-b9b0-5721d38c6c50">
<p>
Any font I choose must conform with the following:
</p>

<ul class="org-ul">
<li>support Latin and Greek character sets;</li>
<li>be readable at small sizes and look okay at large sizes;</li>
<li>offer both roman and italic variants, preferably with corresponding
bold weights;</li>
<li>not be too thin or at least have multiple weights from which to choose
from;</li>
<li>not have too short of an x-height, which makes combinations of text
and numbers or delimiters somewhat unbalanced;</li>
<li>not have a name that directly advertises some brand (e.g. "Helvetica"
is fine as a name, even though a certain corporation tried to be
identified with it; but "CORPORATION Sans" is not);</li>
<li>not be flamboyant by seeking to call too much attention to its
details or by exaggerating some glyph shapes;</li>
<li>be equally readable against light and dark backdrops (for instance,
bitmap fonts are not legible on a white background&#x2014;too bad because I
really like Terminus);</li>
<li>use the <code>*.ttf</code> spec which yields the best results on GNU/Linux.</li>
</ul>

<p>
While there are many good free/libre options available, only a handful
of them cover my fairly demanding needs.  Some look good at large point
sizes.  Others lack Greek characters.  Some do not have italics&#x2026;
Getting it right is very difficult.
</p>

<p>
The only font I could use over the years was Hack, which builds on the
skeleton of DejaVu Sans Mono.  Though there are issues with the default
version of Hack which I do not like, such as the default shape of the
zero and one numbers, the small shape of the backtick character&#x2026;
Little things which keep annoying me.  My <a href="https://gitlab.com/protesilaos/hack-font-mod">custom build of Hack</a> uses some
alternative glyphs from a variety of sources that alleviate most of
those problems (though it obviously cannot alter the overall character
of the typeface).
</p>

<p>
Moving on to my configurations, <code>prot-fonts.el</code> covers my elaborate
typeface requirements.  At its heart is <code>prot-fonts-typeface-sets-alist</code>.
It contains associations of property lists (an alist of plists), each of
which pertains to a give display type.  For example, when I am doing a
video presentation, I require font configurations that differ from what
I normally use.  So I have a <code>large</code> key in the alist to accommodate that
particular need.  Those associations provide granular control over font
attributes, as they specify both mono and proportionately spaced font
families, each with their corresponding weights and heights.
</p>

<p>
The command <code>prot-fonts-set-fonts</code> prompts with completion for a display
type.  It gives options like <code>small</code>, <code>regular</code>, <code>large</code>, which are drawn from
the <code>prot-fonts-typeface-sets-alist</code> (more on completion in the section
<a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>).  When called from Lisp it expects a
<code>DISPLAY</code> argument, which is a symbol that matches the car of a cons cell
in the aforementioned alist.
</p>

<p>
<code>prot-fonts-fonts-per-monitor</code> is not useful with my current hardware, as
I had designed it when I had a laptop (see <a href="#h:e134a8b2-224e-4383-bf03-b080ab6659c7">What hardware do you use?</a>).
Still, the idea is interesting and I keep it around in case someone has
a need for it.  It sets the appropriate font family and size depending
on whether the maximum width of the monitor is below a certain threshold
defined in <code>prot-fonts-max-small-resolution-width</code>.  So it will use the
two first presets defined in the aforementioned alist, with the
assumption that the first is the smallest, laptop-specific one.
</p>

<p>
As noted above, <code>prot-fonts-typeface-sets-alist</code> associates a list of
typefaces with desired weights, including for their bold variation.
This is useful when the active theme (e.g. <a href="#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">my Modus themes</a>) is designed
in a way that parameterises or abstracts the exact value of a bold
weight, by calling <code>:inherit bold</code> instead of specifying <code>:weight bold</code>.
The former applies the attributes of the <code>bold</code> face, whereas the latter
sets the weight at a constant value.  When the theme is designed that
way, we can configure the <code>:weight</code> of the <code>bold</code> face to, e.g., <code>extrabold</code>
and have that propagate across all the faces that the theme defines.
</p>

<p>
Now a few general notes about setting fonts in Emacs.
</p>

<p>
While there are many ways to define a baseline or fallback font family,
I find that the most consistent one in terms of overall configuration is
to do it at the "face" level (read the docstring of <code>set-face-attribute</code>).
Faces are understood as the domain of themes, though themes are just
Elisp programs so there is no real distinction here and it is perfectly
fine to have one program define some properties of a face while another
specifies a few others.  The key is to make those complementary.  Put
concretely, <code>prot-fonts.el</code> sets properties such as <code>:family</code>, while my
themes handle things like colours.
</p>

<p>
To appreciate this point, consider that in Emacs parlance a "face"
signifies a construct that bundles up together several display
attributes, such as a foreground and a background colour, as well as all
typography-related values.  Multiple assignments are stacked, unless one
new attribute explicitly overrules an existing one.
</p>

<p>
There are three faces that are of immediate interest to <code>prot-fonts.el</code>:
the <code>default</code>, <code>variable-pitch</code>, and <code>fixed-pitch</code>.  The first is the Emacs
frame's main typeface, the second specifies a proportionately spaced
font, and the third does the same for a monospaced family.  There are
various scenaria where text on display needs to be rendered in
<code>variable-pitch</code>, while others must remain in <code>fixed-pitch</code>.  For example,
let <code>org-mode</code> inline code be presented in its monospaced font while using
a variable width typeface for the main text, or just use <code>variable-pitch</code>
for User Interface elements such as the mode line to economise on
spacing, and so on.  Again, my Modus themes cover that niche
out-of-the-box (and offer relevant customisation options).  We call this
a "mixed font" setup: the easiest way to get to it is to enable
<code>variable-pitch-mode</code> (read: <a href="#h:77d14350-978d-4820-ab7f-4641706c445a">Extensions for "focus mode" (prot-logos.el)</a>).
</p>

<p>
Relevant publications of mine that are not part of this document:
</p>

<ul class="org-ul">
<li><a href="https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/">Notes for aspiring Emacs theme developers</a> (2020-08-28).</li>
<li><a href="https://protesilaos.com/codelog/2020-09-05-emacs-note-mixed-font-heights/">Emacs: note on mixed font heights</a> (2020-09-05).</li>
<li><a href="https://protesilaos.com/emacs/modus-themes/#h:defcf4fc-8fa8-4c29-b12e-7119582cc929">Modus themes' manual on font configurations</a>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Font configurations (prot-fonts.el)
(prot-emacs-builtin-package 'prot-fonts
  ;; This is defined in Emacs C code: it belongs to font settings.
  (setq x-underline-at-descent-line t)

  ;; And this is for Emacs28.
  (setq-default text-scale-remap-header-line t)

  ;; Make sure to read the `prot-fonts-typeface-sets-alist' doc string,
  ;; as it explains what those property lists should contain.
  ;;
  ;; The version of "Hack" that I custom is a custom build on mine:
  ;; &lt;https://gitlab.com/protesilaos/hack-font-mod&gt;.  Same principle for
  ;; Iosevka: &lt;https://gitlab.com/protesilaos/iosevka-comfy&gt;.
  (setq prot-fonts-typeface-sets-alist
        '((small . ( :fixed-pitch-family "Hack"
                     :fixed-pitch-regular-weight regular
                     :fixed-pitch-heavy-weight bold
                     :fixed-pitch-height 75
                     :fixed-pitch-line-spacing 1
                     :variable-pitch-family "FiraGO"
                     :variable-pitch-height 1.05
                     :variable-pitch-regular-weight normal))

          (regular . ( :fixed-pitch-family "Hack"
                       :fixed-pitch-regular-weight regular
                       :fixed-pitch-heavy-weight bold
                       :fixed-pitch-height 90
                       :fixed-pitch-line-spacing nil
                       :variable-pitch-family "FiraGO"
                       :variable-pitch-height 1.05
                       :variable-pitch-regular-weight normal))

          (large . ( :fixed-pitch-family "Hack"
                     :fixed-pitch-regular-weight normal
                     :fixed-pitch-heavy-weight bold
                     :fixed-pitch-height 130
                     :fixed-pitch-line-spacing nil
                     :variable-pitch-family "FiraGO"
                     :variable-pitch-height 1.05
                     :variable-pitch-regular-weight normal))

          (large-alt . ( :fixed-pitch-family "Iosevka Comfy"
                         :fixed-pitch-regular-weight book
                         :fixed-pitch-heavy-weight extrabold
                         :fixed-pitch-height 135
                         :fixed-pitch-line-spacing nil
                         :variable-pitch-family "Noto Sans"
                         :variable-pitch-height 1.0
                         :variable-pitch-regular-weight normal))))

  ;; TODO 2021-08-27: I no longer have a laptop.  Those configurations
  ;; are not relevant, but I keep them around as the idea is still good.

  ;; The value of `prot-fonts-laptop-desktop-keys-list' becomes '(small
  ;; regular) based on the car of the first two cons cells found in
  ;; `prot-fonts-typeface-sets-alist'.  The assumption is that those
  ;; contain sets from smaller to larger display types.
  (setq prot-fonts-laptop-desktop-keys-list
        (prot-fonts-laptop-desktop-keys))

  ;; This is the breakpoint, in pixels, for determining whether we are
  ;; on the small or large screen layout.  The number here is my
  ;; laptop's screen width, while it expands beyond that when I connect
  ;; it to an external monitor (how I normally set it up on my desk).
  (setq prot-fonts-max-small-resolution-width 1366)

  ;; And this just sets the right font depending on whether my laptop is
  ;; connected to an external monitor or not.
  (prot-fonts-fonts-per-monitor)

  ;; See theme section for this hook and also read the doc string of
  ;; `prot-fonts-restore-last'.
  (add-hook 'modus-themes-after-load-theme-hook #'prot-fonts-restore-last)

  (define-key global-map (kbd "C-c f") #'prot-fonts-set-fonts))
</pre>
</div>

<p>
This is the source code of <code>prot-fonts.el</code> (you can always find the file
if you directly clone <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-fonts.el --- Font configurations for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This set of configurations pertains to my font settings, for use in
;; my Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

;;; Customisation options
(defgroup prot-fonts ()
  "Font-related configurations for my dotemacs."
  :group 'font)

;; NOTE: "Hack" and "Iosevka Comfy" are personal builds of Hack and
;; Iosevka respectively:
;;
;; 1. https://gitlab.com/protesilaos/hack-font-mod
;; 2. https://gitlab.com/protesilaos/iosevka-comfy
(defcustom prot-fonts-typeface-sets-alist
  '((laptop  . ( :fixed-pitch-family "Hack"
                 :fixed-pitch-regular-weight normal
                 :fixed-pitch-heavy-weight bold
                 :fixed-pitch-height 90
                 :fixed-pitch-line-spacing 1
                 :variable-pitch-family "DejaVu Sans"
                 :variable-pitch-height 1.0
                 :variable-pitch-regular-weight normal))

    (desktop . ( :fixed-pitch-family "Iosevka Comfy"
                 :fixed-pitch-regular-weight book
                 :fixed-pitch-heavy-weight extrabold
                 :fixed-pitch-height 105
                 :fixed-pitch-line-spacing nil
                 :variable-pitch-family "FiraGO"
                 :variable-pitch-height 0.95
                 :variable-pitch-regular-weight normal))

    (video   . ( :fixed-pitch-family "Iosevka Comfy"
                 :fixed-pitch-regular-weight normal
                 :fixed-pitch-heavy-weight bold
                 :fixed-pitch-height 135
                 :fixed-pitch-line-spacing nil
                 :variable-pitch-family "Source Sans Pro"
                 :variable-pitch-height 1.0
                 :variable-pitch-regular-weight normal)))
  "Alist of desired typeface properties.

The car of each cons cell is an arbitrary key that broadly
describes the display type.  We use 'laptop', 'desktop' though
any symbol will do, e.g. 'video'.

The cdr is a plist that specifies the typographic properties of
fixed-pitch and variable-pitch fonts.  A few notes about those
properties:

- We specify typographic properties both for the `fixed-pitch'
  and `variable-pitch' faces.  This allows us to be explicit
  about all font families that may be used by the active
  theme (Modus themes) under various circumstances (e.g. enabling
  `variable-pitch' for the UI, or using `variable-pitch-mode').

- A semibold weight can only be used by font families that have
  one.  Otherwise it is better to specify bold, in order to avoid
  any potential unpredictable behaviour.

- Never set the :variable-pitch-height to an absolute number
  because that will break the layout of `text-scale-adjust'.  Use
  a floating point instead, so that when the text scale is
  adjusted those expand or contract accordingly.

- An absolute height is only need for the `default' face, which
  we here designated as a fixed-pitch typeface (so the faces
  `fixed-pitch' and `default' share the same font family, though
  their role remains distinct).

- The line height applies to the entirety of the Emacs session.
  We declare it as :fixed-pitch-line-spacing because the face
  `default' starts with a fixed-pitch font family.

- No tests are performed to determined the presence of the font
  families specified herein.  It is assumed that those always
  exist.

It is recommended that the order of the cons cells follows from
the smallest to largest font heights, to simplify the process of
identifying the set that belongs to the small and larger display
respectively (see code of `prot-fonts-laptop-desktop-keys')."
  :group 'prot-fonts
  :type 'alist)

(defun prot-fonts-laptop-desktop-keys ()
  "List laptop and desktop fontsets.
The elements of the list are the cars of the first two cons cells
of `prot-fonts-laptop-desktop-keys-list'"
  (let ((sets (mapcar #'car prot-fonts-typeface-sets-alist)))
    (list (nth 0 sets) (nth 1 sets))))

(defcustom prot-fonts-laptop-desktop-keys-list
  (prot-fonts-laptop-desktop-keys) ; '(laptop desktop)
  "Symbols for `prot-fonts-fonts-per-monitor'.
This is a list whose first item denotes the smallest desirable
entry in `prot-fonts-typeface-sets-alist' for use on a laptop or
just smaller monitor, while the second points to a larger
display's key in that same alist.

The helper function `prot-fonts-laptop-desktop-keys' picks the
first two entries in `prot-fonts-typeface-sets-alist'."
  :group 'prot-fonts
  :type 'list)

(defcustom prot-fonts-max-small-resolution-width 1366
  "Maximum width for use in `prot-fonts-fonts-per-monitor'.
If the screen width is higher than this value (measuring pixels),
then the larger fonts will be used, as specified by the nth 1 of
`prot-fonts-laptop-desktop-keys-list'.  Otherwise the smaller
fonts, else nth 0, are applied."
  :group 'prot-fonts
  :type 'integer)

(defvar prot-fonts--font-display-hist '()
  "History of inputs for display-related font associations.")

(defun prot-fonts--set-face-attribute (face family &amp;optional weight height)
  "Set FACE font to FAMILY, with optional HEIGHT and WEIGHT."
  (let* ((u (if (eq face 'default) 100 1.0))
         (h (or height u))
         (w (or weight 'normal)))
    ;; ;; Read this: &lt;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=45920&gt;
    ;; ;; Hence why the following fails.  Keeping it for posterity...
    ;; (set-face-attribute face nil :family family :weight w :height h)
    (if (eq (face-attribute face :weight) w)
          (internal-set-lisp-face-attribute face :family family 0)
      (internal-set-lisp-face-attribute face :weight w 0)
      (internal-set-lisp-face-attribute face :family family 0)
      (internal-set-lisp-face-attribute face :weight w 0))
    (internal-set-lisp-face-attribute face :height h 0)))

(defun prot-fonts--set-fonts-prompt ()
  "Promp for font set (used by `prot-fonts-set-fonts')."
  (let ((def (nth 1 prot-fonts--font-display-hist)))
    (completing-read
     (format "Select font set for DISPLAY [%s]: " def)
     (mapcar #'car prot-fonts-typeface-sets-alist)
     nil t nil 'prot-fonts--font-display-hist def)))

(defvar prot-fonts-set-typeface-hook nil
  "Hook that runs after `prot-fonts-set-fonts'.")

(defvar prot-fonts--current-spec nil
  "Current font set in `prot-fonts-typeface-sets-alist'.")

;;;###autoload
(defun prot-fonts-set-fonts (display)
  "Set fonts based on font set associated with DISPLAY.

DISPLAY is a symbol that represents the car of a cons cell in
`prot-fonts-typeface-sets-alist'."
  (interactive (list (prot-fonts--set-fonts-prompt)))
  (if window-system
      (let* ((fonts (if (stringp display) (intern display) display))
             (properties (alist-get fonts prot-fonts-typeface-sets-alist))
             (fixed-pitch-family (plist-get properties :fixed-pitch-family))
             (fixed-pitch-height (plist-get properties :fixed-pitch-height))
             (fixed-pitch-regular-weight (plist-get properties :fixed-pitch-regular-weight))
             (fixed-pitch-heavy-weight (plist-get properties :fixed-pitch-heavy-weight))
             (fixed-pitch-line-spacing (plist-get properties :fixed-pitch-line-spacing))
             (variable-pitch-family (plist-get properties :variable-pitch-family))
             (variable-pitch-height (plist-get properties :variable-pitch-height))
             (variable-pitch-regular-weight (plist-get properties :variable-pitch-regular-weight)))
        (prot-fonts--set-face-attribute
         'default fixed-pitch-family fixed-pitch-regular-weight fixed-pitch-height)
        (prot-fonts--set-face-attribute
         'fixed-pitch fixed-pitch-family fixed-pitch-regular-weight)
        (prot-fonts--set-face-attribute
         'variable-pitch variable-pitch-family variable-pitch-regular-weight variable-pitch-height)
        (set-face-attribute 'bold nil :weight fixed-pitch-heavy-weight)
        (setq-default line-spacing fixed-pitch-line-spacing)
        (add-to-history 'prot-fonts--font-display-hist (format "%s" display))
        (setq prot-fonts--current-spec (format "%s" display))
        (run-hooks 'prot-fonts-set-typeface-hook))
    (error "Not running a graphical Emacs; cannot set fonts")))

(defun prot-fonts-restore-last ()
  "Restore last fontset.
This is necessary when/if changes to face specs alter some
typographic properties.  For example, when switching themes the
:weight of the `bold' face will be set to whatever the theme
specifies, typically 'bold', which is not what we always have on
our end."
  (let ((ultimate (nth 0 prot-fonts--font-display-hist))
        (penultimate (nth 1 prot-fonts--font-display-hist)))
    (if (string= ultimate prot-fonts--current-spec)
        (prot-fonts-set-fonts ultimate)
      (prot-fonts-set-fonts penultimate))))

(defun prot-fonts--display-type-for-monitor (&amp;optional smaller larger)
  "Determine typeface specs based on monitor width.
Optional SMALLER and LARGER are two keys that point to entries in
`prot-fonts-typeface-sets-alist'.  The default uses the relevant
keys from `prot-fonts-laptop-desktop-keys-list'."
  (let* ((keys prot-fonts-laptop-desktop-keys-list)
         (face-specs prot-fonts-typeface-sets-alist)
         (small (or smaller (nth 0 keys)))
         (large (or larger (nth 1 keys)))
         (max-width prot-fonts-max-small-resolution-width)
         (spec (if (&lt;= (display-pixel-width) max-width)
                   small
                 large)))
    (unless (assoc spec face-specs)
      (error (concat "Key &lt;&lt;%s&gt;&gt; in `prot-fonts-laptop-desktop-keys-list' "
                     "does not reference anything in "
                     "`prot-fonts-typeface-sets-alist'")
             spec))
    spec))

;;;###autoload
(defun prot-fonts-fonts-per-monitor ()
  "Use font settings based on screen size.
The breakpoint is `prot-fonts-max-small-resolution-width', while
`prot-fonts-laptop-desktop-keys-list' contains the keys of the
two font sets to be used: its first element should point at
smaller fonts than the second element."
  (when window-system
    (let ((display (prot-fonts--display-type-for-monitor)))
      (prot-fonts-set-fonts display))))

(provide 'prot-fonts)
;;; prot-fonts.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:9035a1ed-e988-4731-89a5-0d9e302c3dea" class="outline-4">
<h4 id="h:9035a1ed-e988-4731-89a5-0d9e302c3dea"><span class="section-number-4">2.7.2.</span> Simple font suitability test</h4>
<div class="outline-text-4" id="text-h:9035a1ed-e988-4731-89a5-0d9e302c3dea">
<p>
Here is a test I have come up with to make an initial assessment of the
overall quality of a monospaced font that is meant to work well in a
programming context: <i>can you discern each character at a quick glance?</i>
If yes, your choice of typeface is good <i>prima facie</i>, otherwise search
for something else.
</p>

<p>
Note that this test is not perfect, since many typefaces fall short in
less obvious ways, such as the space between the characters.  Also note
that the website version of this document may not accurately represent
the typeface I am using.
</p>

<pre class="example" id="org323db54">
()[]{}&lt;&gt;«»‹›
6bB8&amp;
0ODdoaoOQGC
I1tilIJL|
!¡ij
5$§SsS5
17ZzZ2
9gqpG6
hnmMN
uvvwWuuwvy
x×X
.,·°%
¡!¿?
:;
`''"‘’“”
—-~≈=≠+*_
…⋯
...

Sample character set
Check for monospacing and Greek glyphs

ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
~!@#$%^&amp;*+
`'"‘’“”.,;:…
()[]{}—-_=|&lt;&gt;/\
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
αβγδεζηθικλμνξοπρστυφχψω

// NOTE that I got this from Hack's website:
// https://source-foundry.github.io/Hack/font-specimen.html
//  The four boxing wizards jump
#include &lt;stdio.h&gt; // &lt;= quickly.
int main(int argc, char **argv) {
  long il1[]={1-2/3.4,5+6==7/8};
  int OxFaced=0xBAD||"[{(CQUINE";
  unsigned O0,l1,Z2,S5,G6,B8__XY;
  printf("@$Hamburgefo%c`",'\n');
  return ~7&amp;8^9?0:l1|!"j-&gt;k+=*w";
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0" class="outline-3">
<h3 id="h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0"><span class="section-number-3">2.8.</span> Repeatable key chords (repeat-mode)</h3>
<div class="outline-text-3" id="text-h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0">
<p>
Emacs28 comes with a built-in utility for repeating selected commands in
a more convenient fashion.  Once <code>repeat-mode</code> is enabled, a key binding
or chord that invokes a command successfully can be repeated by typing
in its tail or whatever the developer specifies.  So <code>other-window</code> may be
used like this: <code>C-x o</code>, <code>o</code>, <code>o</code> to switch three windows, instead of <code>C-x o</code>,
<code>C-x o</code>, <code>C-x o</code>.
</p>

<p>
This is achieved by furnishing transient keymaps that get activated
right after the command they belong to and only once the command in
question has been added to the <code>repeat-map</code>.  Here is a sample from
<code>window.el</code>:
</p>

<pre class="example" id="orge9137b0">
(defvar resize-window-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "^" 'enlarge-window)
    (define-key map "}" 'enlarge-window-horizontally)
    (define-key map "{" 'shrink-window-horizontally) ; prot note: those three are C-x KEY
    ;; Additional keys:
    (define-key map "v" 'shrink-window) ; prot note: this is not bound by default
    map)
  "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")
(put 'enlarge-window 'repeat-map 'resize-window-repeat-map)
(put 'enlarge-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window 'repeat-map 'resize-window-repeat-map)
</pre>

<p>
Once the keymap exists and its commands are in the <code>repeat-map</code>, such as
with the above example, we do not have to recreate the entire setup if
all we need is to change key bindings: we just have to rebind the
commands to where it makes sense for us.  I actually do this for
<code>resize-window-repeat-map</code> (<a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">Window rules and basic tweaks (window.el)</a>).
</p>

<p>
At any rate, all we need here is to activate <code>repeat-mode</code> and then
implement the repetition mechanism wherever we want.
</p>

<p>
The <code>repeat</code> command is bound by default to <code>C-x z</code>, with <code>s-z</code> serving as my
alias for it (read <a href="#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703">What is the meaning of the `s-KEY' bindings?</a>).  With
the two variables I set in the following configurations, I make it so
that subsequent repetitions require only hitting another <code>z</code>.  Depending
on what you do, a <code>repeat</code> can save you from multiple key presses.  For
more demanding tasks you are better off with keyboard macros.
</p>

<p>
<b>Pro tip:</b> to make a keyboard macro out of your most recent commands, use
<code>C-x C-k l</code> which calls <code>kmacro-edit-lossage</code>.  The list is editable, so
remove any line that is not required and then save what is left.  The
result is stored as the latest keyboard macro (and you also have the
power to cycle through kmacros, store them in specific keys, etc.).
</p>

<p>
Moving on to the mark, which is affected by <code>set-mark-command-repeat-pop</code>,
practically every Emacs motion that operates on a portion of text will
set the mark automatically.  You can also do it manually with <code>C-SPC</code> (hit
it twice if you do not wish to activate the region).  It is then
possible to cycle through the marks in reverse order by passing a prefix
argument <code>C-u C-SPC</code>.  With <code>set-mark-command-repeat-pop</code> we can continue
cycling by repeated presses of <code>C-SPC</code>.  Again though, this is not the
type of functionality I rely on: for more deliberate actions of this
sort, consider Emacs' registers or bookmarks.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Repeatable key chords (repeat-mode)
(prot-emacs-builtin-package 'repeat
  (setq repeat-on-final-keystroke t)
  (setq set-mark-command-repeat-pop t)

  (repeat-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:1d0e8ab3-d779-41d4-b478-d735dc3ad7ae" class="outline-3">
<h3 id="h:1d0e8ab3-d779-41d4-b478-d735dc3ad7ae"><span class="section-number-3">2.9.</span> Handle performance for very long lines (so-long.el)</h3>
<div class="outline-text-3" id="text-h:1d0e8ab3-d779-41d4-b478-d735dc3ad7ae">
<p>
When you visit a file with very long lines, such as a minified
javascript on a web page's source, Emacs will have trouble fontifying
everything properly and performance will suffer as a result.  We can
prevent Emacs from even attempting to deal with such longs lines by
enabling the built-in <code>global-so-long-mode</code> (for Emacs versions &gt;= 27).
It allows the active major mode to gracefully adapt to buffers with very
long lines.  What "very long" means is, of course, configurable: invoke
<code>M-x find-library</code> and search for <code>so-long</code> to find several customisation
options (declared with <code>defcustom</code>).  Personally, I find that the defaults
require no further intervention from my part.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Handle performance for very long lines (so-long.el)
(prot-emacs-builtin-package 'so-long
  (global-so-long-mode 1))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:5c060e2e-231d-4896-a5d2-b3fb4134764e" class="outline-2">
<h2 id="h:5c060e2e-231d-4896-a5d2-b3fb4134764e"><span class="section-number-2">3.</span> Selection candidates and search methods</h2>
<div class="outline-text-2" id="text-h:5c060e2e-231d-4896-a5d2-b3fb4134764e">
</div>
<div id="outline-container-h:98d3abcc-f34e-4029-aabc-740f0b6421f8" class="outline-3">
<h3 id="h:98d3abcc-f34e-4029-aabc-740f0b6421f8"><span class="section-number-3">3.1.</span> Completion framework and extras</h3>
<div class="outline-text-3" id="text-h:98d3abcc-f34e-4029-aabc-740f0b6421f8">
<p>
Unlike the desktop metaphor, the optimal way to use Emacs is through
searching and narrowing selection candidates.  Spend less time worrying
about where things are on the screen and more on how fast you can bring
them into focus.  This is, of course, a matter of realigning priorities,
as we still wish to control every aspect of the interface, as we do
elsewhere in this document.
</p>

<p>
To get a sense of my current completion framework, watch my presentation
on <a href="https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/">Default Emacs completion and extras</a> (2021-01-06).  There have been
some changes since then, but the core idea stands.
</p>
</div>

<div id="outline-container-h:7b1374dd-6b1f-4548-8fbf-1034230c80e0" class="outline-4">
<h4 id="h:7b1374dd-6b1f-4548-8fbf-1034230c80e0"><span class="section-number-4">3.1.1.</span> Orderless completion style (and prot-orderless.el)</h4>
<div class="outline-text-4" id="text-h:7b1374dd-6b1f-4548-8fbf-1034230c80e0">
<p>
The, dare I say, <i>sublime</i> <a href="https://github.com/oantolin/orderless">“orderless” package</a> is developed by Omar
Antolín Camarena.  It provides the <code>orderless</code> completion style for
efficient, out-of-order grouped pattern matching.  The components can be
determined using several styles, such as regexp, flex, prefix,
initialism (check its README because there are lots of variations).
Delimiters are literal spaces by default, but can be configured to match
other characters, with hyphens and slashes being likely choices.  As
such, Orderless can supersede&#x2014;and for most part improve upon&#x2014;the
completion styles that come built into Emacs, adding to them the
powerful out-of-order capability.
</p>

<p>
All we do here is set up Orderless.  The <code>orderless</code> completion style is
appended to the minibuffer's customisation option for <code>completion-styles</code>.
That is defined in <a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and extras</a>.
</p>

<p>
My <code>prot-orderless.el</code> contains the few minor tweaks I introduce (full
code further below).
</p>

<ol class="org-ol">
<li>It defines three style dispatchers. Those are single characters that
acquire a special meaning while at the end of a given input:

<ul class="org-ul">
<li>With the equals sign appended to a sequence of characters, we call
<code>prot-orderless-literal-dispatcher</code> which instructs orderless to match
that sequence as a literal string.</li>

<li>A comma at the end of a string of characters treats that group as
an initialism, per <code>prot-orderless-initialism-dispatcher</code>.</li>

<li>While a tilde (<code>prot-orderless-flex-dispatcher</code>) makes it makes it a
flex match.</li>
</ul></li>

<li><code>prot-orderless-with-styles</code> is a function that changes the default
pattern-matching styles on a per-command basis.  The idea is to use a
certain style for most completion sessions, but prioritise an
alternative when needed.  I use this with some Consult commands
(<a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el and prot-consult.el)</a>).  The
<code>prot-orderless-default-styles</code> and <code>prot-orderless-alternative-styles</code>
variables are designed for this particular task.</li>
</ol>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Orderless completion style (and prot-orderless.el)
(prot-emacs-builtin-package 'prot-orderless
  (setq prot-orderless-default-styles
        '(orderless-prefixes
          orderless-strict-leading-initialism
          orderless-regexp))
  (setq prot-orderless-alternative-styles
        '(orderless-literal
          orderless-prefixes
          orderless-strict-leading-initialism
          orderless-regexp)))

(prot-emacs-elpa-package 'orderless
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles prot-orderless-default-styles)
  (setq orderless-style-dispatchers
        '(prot-orderless-literal-dispatcher
          prot-orderless-initialism-dispatcher
          prot-orderless-flex-dispatcher))
  ;; SPC should never complete: use it for `orderless' groups.
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "SPC") nil)
    (define-key map (kbd "?") nil)))
</pre>
</div>

<p>
These are the contents of the <code>prot-orderless.el</code> library (get the file
from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (as with all my Elisp code)):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-orderless.el --- Extensions for Orderless -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for the Orderless completion style for use in my Emacs
;; setup: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-orderless ()
  "Tweaks for the Orderless completion style."
  :group 'minibuffer)

(defcustom prot-orderless-default-styles
  '(orderless-flex
    orderless-strict-leading-initialism
    orderless-regexp
    orderless-prefixes
    orderless-literal)
  "List that should be assigned to `orderless-matching-styles'."
  :type 'list
  :group 'prot-orderless)

(defcustom prot-orderless-alternative-styles
  '(orderless-literal
    orderless-prefixes
    orderless-strict-leading-initialism
    orderless-regexp)
  "Alternative list for `orderless-matching-styles'.

Unlike `prot-orderless-default-styles', this variable is intended
for use on a case-by-case basis, with the help of the function
`prot-orderless-with-styles'."
  :type 'list
  :group 'prot-orderless)

(defun prot-orderless-literal-dispatcher (pattern _index _total)
  "Literal style dispatcher using the equals sign as a suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
  (when (string-suffix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 0 -1))))

(defun prot-orderless-initialism-dispatcher (pattern _index _total)
  "Leading initialism  dispatcher using the comma suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
  (when (string-suffix-p "," pattern)
    `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))

(defun prot-orderless-flex-dispatcher (pattern _index _total)
  "Flex  dispatcher using the tilde suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
  (when (string-suffix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 0 -1))))

(defvar orderless-matching-styles)

;;;###autoload
(defun prot-orderless-with-styles (cmd &amp;optional styles)
  "Call CMD with optional orderless STYLES.

STYLES is a list of pattern matching methods that is passed to
`orderless-matching-styles'.  Its fallback value is that of
`prot-orderless-alternative-styles'."
  (let ((orderless-matching-styles (or styles prot-orderless-alternative-styles))
        (this-command cmd))
    (call-interactively cmd)))

(provide 'prot-orderless)
;;; prot-orderless.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40" class="outline-4">
<h4 id="h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40"><span class="section-number-4">3.1.2.</span> Completion annotations (marginalia)</h4>
<div class="outline-text-4" id="text-h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40">
<p>
This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be framework-agnostic, so it works with Selectrum, Icomplete
vertical, Embark's completions buffer, as well as the default
completions' buffer (as of 2021-04-02, the latter is my choice for
visualising the standard minibuffer completion candidates&#x2014;refer to
<a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and my extras (mct.el)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Completion annotations (marginalia)
(prot-emacs-elpa-package 'marginalia
  (setq marginalia-max-relative-age 0)  ; time is absolute here!
  (marginalia-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:c110e399-3f43-4555-8427-b1afe44c0779" class="outline-4">
<h4 id="h:c110e399-3f43-4555-8427-b1afe44c0779"><span class="section-number-4">3.1.3.</span> Minibuffer configurations and my extras (mct.el)</h4>
<div class="outline-text-4" id="text-h:c110e399-3f43-4555-8427-b1afe44c0779">
<p>
NOTE 2021-12-29: There are experiments to make MCT perform completion in
region (the job that Corfu handles).  The feature is not fully fleshed
out and there will be changes over the coming days and weeks.
</p>

<p>
UPDATE 2021-10-23: Watch my video demonstration of the package I wrote
<a href="https://protesilaos.com/codelog/2021-10-22-emacs-mct-demo/">Minibuffer and Completions in Tandem (mct.el)</a>.
</p>

<p>
The minibuffer is the epicentre of extended interactivity with all sorts
of Emacs workflows: to select a buffer, open a file, provide an answer
to some prompt, such as a number, regular expression, password, and so
on.
</p>

<p>
Emacs has built-in capabilities to perform two distinct tasks related to
such interactions:
</p>

<dl class="org-dl">
<dt>Narrowing</dt><dd>Use pattern matching algorithms to limit the list of
choices (known as "candidates" or "completion candidates") to those
matching the given input.  There are several pattern matching styles
already built-in, while we can opt to extend them further.</dd>

<dt>Selecting</dt><dd>Visualise the list of completion candidates and pick an
item out of it using regular motions or concomitant extras.  By
default, Emacs visualises results in a special <code>*Completions*</code> buffer,
which does not have lots of features and is not particularly pleasing
to use.</dd>
</dl>

<p>
There are third party completion frameworks that accomplish both of the
aforementioned, such as Ivy and Helm.  While others focus on the latter,
namely, Selectrum, Vertico, and the built-in Icomplete.  Then, there is
also Embark which has a facility to display completion candidates in a
live updating buffer (Embark is not limited to task&#x2014;read the details
of <a href="#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">Extended minibuffer actions and more (embark.el and prot-embark.el)</a>).
</p>

<p>
I have used Ivy and Icomplete in the past, though I felt that the best
experience was with Embark.  However, as of 2021-04-02 I realised that
Emacs version 28 comes with a built-in way to render <code>*Completions*</code> in a
vertical list, one item per line.  So equipped with my knowledge of
extending Embark, I implemented a layer of interactivity that, I feel,
is just as good as what other frameworks provide.  As of 2021-10-22 this
is its own package, called "Minibuffer and Completions in Tandem", else
MCT (or variants).  The technicalities are in the <code>mct.el</code> file, which is
reproduced after the following code block.
</p>

<p>
Read <a href="https://protesilaos.com/emacs/mct">the official manual of MCT</a> as it covers its basics, explains its
key bindings, and shows how to configure it further.
</p>

<p>
Finally, here is an overview of the settings covered herein:
</p>

<dl class="org-dl">
<dt>Completion styles</dt><dd><p>
I rely on a mixture of built-in styles as well as
the external <code>orderless</code> package by Omar Antolín Camarena.  Orderless is
placed last on the list because simpler searches work fine with the
other styles.  Orderless is better suited for complex pattern
matching.  The way completion styles work, when one style cannot match
anything, Emacs tries the next one on the list, until one of them
yields results.  As such, it is easy to activate Orderless on demand,
either by separate input groups by spaces or passing one of the style
dispatchers that are acceptable (read <a href="#h:7b1374dd-6b1f-4548-8fbf-1034230c80e0">the Orderless completion style</a>).
</p>

<p>
For file queries in particular, there exists a niche functionality in
the built-in <code>initials</code> and <code>partial-completion</code> styles to navigate
abbreviated paths.  Here is an example with the latter: you can type
<code>~/.l/s/fo</code> which will match <code>~/.local/share/fonts</code> (combine that with the
file shadowing mentioned above, for a minimalist, decluttered flow).
The variable <code>completion-category-overrides</code> can control the standard
option of <code>completion-styles</code> on a per-category basis.
</p></dd>

<dt>Recursive minibuffers</dt><dd><p>
I enable recursive minibuffers.  This
practically means that you can start something in the minibuffer,
switch to another window, call the minibuffer again, run some
commands, and then move back to what you initiated in the original
minibuffer.  Or simply call an <code>M-x</code> command while in the midst of a
minibuffer session.  To exit, hit <code>C-]</code> (<code>abort-recursive-edit</code>), though
the regular <code>C-g</code> should also do the trick.
</p>

<p>
The <code>minibuffer-depth-indicate-mode</code> will show a recursion indicator,
represented as a number, next to the minibuffer prompt, if a recursive
edit is in progress (also check <a href="#h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b">Mode line recursion indicators</a>).
</p></dd>
</dl>

<p>
Also check my setup for the <a href="#h:2733674b-51f9-494e-b34d-e8842ac4ef96">Minibuffer history (savehist-mode)</a>.  After
several months of full time usage, I am confident in the built-in
mechanism's ability to sort things well enough and to surface the
results I am most likely interested in, based on previous selections.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Minibuffer configurations and my extras (mct.el)
(prot-emacs-builtin-package 'minibuffer
  ;; NOTE 2021-10-25: I am adding `basic' because it works better as a
  ;; default for some contexts.  Read:
  ;; &lt;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=50387&gt;.
  (setq completion-styles
        '(basic substring initials flex partial-completion orderless))
  (setq completion-category-overrides
        '((file (styles . (basic partial-completion orderless)))))
  (setq completion-cycle-threshold 2)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters nil)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-ignore-case t)
  (setq completions-detailed t)
  (setq-default case-fold-search t)   ; For general regexp

  ;; Grouping of completions for Emacs 28
  (setq completions-group t)
  (setq completions-group-sort nil)
  (setq completions-group-format
        (concat
         (propertize "    " 'face 'completions-group-separator)
         (propertize " %s " 'face 'completions-group-title)
         (propertize " " 'face 'completions-group-separator
                     'display '(space :align-to right))))

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t) ; also check `use-short-answers' for Emacs28
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (setq echo-keystrokes 0.25)           ; from the C source code

  ;; Do not allow the cursor to move inside the minibuffer prompt.  I
  ;; got this from the documentation of Daniel Mendler's Vertico
  ;; package: &lt;https://github.com/minad/vertico&gt;.
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; I use this prefix for other searches
  (define-key minibuffer-local-must-match-map (kbd "M-s") nil))

;; Source: &lt;https://gitlab.com/protesilaos/mct.el&gt;.
;; Manual: &lt;https://protesilaos.com/emacs/mct&gt;.
(prot-emacs-builtin-package 'mct
  (setq mct-remove-shadowed-file-names t) ; when `file-name-shadow-mode' is enabled
  (setq mct-hide-completion-mode-line t)
  (setq mct-show-completion-line-numbers nil)
  (setq mct-apply-completion-stripes nil)
  (setq mct-minimum-input 3)
  (setq mct-live-update-delay 0.6)
  (setq mct-completion-blocklist nil)
  (setq mct-completion-passlist
        '( embark-prefix-help-command Info-goto-node
           Info-index Info-menu vc-retrieve-tag
           prot-bookmark-cd-bookmark
           prot-bongo-playlist-insert-playlist-file
           project-switch-to-buffer))

  ;; You can place the Completions' buffer wherever you want, by
  ;; following the syntax of `display-buffer-alist' (check elsewhere in
  ;; this file).  For example, try this:

  ;; (setq mct-display-buffer-action
  ;;       (quote ((display-buffer-reuse-window
  ;;                display-buffer-in-side-window)
  ;;               (side . left)
  ;;               (slot . 99)
  ;;               (window-width . 0.3))))

  (mct-region-global-mode 1) ; Or use `mct-region-mode' per major-mode
  (mct-minibuffer-mode 1)

  (define-key minibuffer-local-completion-map (kbd "&lt;tab&gt;") #'minibuffer-force-complete)
  (define-key global-map (kbd "C-x :") #'mct-focus-mini-or-completions))
</pre>
</div>

<p>
And here is <code>mct.el</code> (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; mct.el --- Minibuffer and Completions in Tandem -*- lexical-binding: t -*-

;; Copyright (C) 2021  Free Software Foundation, Inc.

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://gitlab.com/protesilaos/mct
;; Version: 0.3.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; MCT enhances the default Emacs completion.  It makes the minibuffer
;; and Completions' buffer work together and look like a vertical
;; completion UI.
;;
;; Read the documentation for basic usage and configuration.

;;; Code:

;;;; General utilities

(defgroup mct ()
  "Extensions for the minibuffer."
  :group 'minibuffer)

(defcustom mct-completion-windows-regexp
  "\\`\\*Completions.*\\*\\'"
  "Regexp to match window names with completion candidates.
Used by `mct--get-completion-window'."
  :type 'string
  :group 'mct)

(defcustom mct-remove-shadowed-file-names nil
  "Delete shadowed parts of file names.

For example, if the user types ~/ after a long path name,
everything preceding the ~/ is removed so the interactive
selection process starts again from the user's $HOME.

Only works when variable `file-name-shadow-mode' is non-nil."
  :type 'boolean
  :group 'mct)

(defcustom mct-hide-completion-mode-line nil
  "Do not show a mode line in the Completions' buffer."
  :type 'boolean
  :group 'mct)

(defcustom mct-show-completion-line-numbers nil
  "Display line numbers in the Completions' buffer."
  :type 'boolean
  :group 'mct)

(defcustom mct-apply-completion-stripes nil
  "Display alternating backgrounds the Completions' buffer."
  :type 'boolean
  :group 'mct)

(defcustom mct-live-completion t
  "Control auto-display and live-update of Completions' buffer.

When nil, the user has to manually request completions, using the
regular activating commands.  The Completions' buffer is never
updated live to match user input.  Updating has to be handled
manually.  This is like the out-of-the-box minibuffer completion
experience.

When set to the value `visible', the Completions' buffer is live
updated only if it is visible.  The actual display of the
completions is still handled manually.  For this reason, the
`visible' style does not read the `mct-minimum-input', meaning
that it will always try to live update the visible completions,
regardless of input length.

When non-nil (the default), the Completions' buffer is
automatically displayed once the `mct-minimum-input' is met and
is hidden if the input drops below that threshold.  While
visible, the buffer is updated live to match the user input.

Note that every function in the `mct-completion-passlist' ignores
this option altogether.  This means that every such command will
always show the Completions' buffer automatically and will always
update its contents live.  Same principle for every function
declared in the `mct-completion-blocklist', which will always
disable both the automatic display and live updating of the
Completions' buffer."
  :type '(choice
          (const :tag "Disable live-updating" nil)
          (const :tag "Enable live-updating" t)
          (const :tag "Live update only visible Completions" 'visible))
  :group 'mct)

(defcustom mct-minimum-input 3
  "Live update completions when input is &gt;= N.

Setting this to a value greater than 1 can help reduce the total
number of candidates that are being computed."
  :type 'natnum
  :group 'mct)

(defcustom mct-live-update-delay 0.3
  "Delay in seconds before updating the Completions' buffer.

Set this to 0 to disable the delay."
  :type 'number
  :group 'mct)

(defcustom mct-completion-blocklist nil
  "Functions that disable live completions.
This means that they ignore `mct-live-completion'.  They do not
automatically display the Completions' buffer, nor do they update
it to match user input.

The Completions' buffer can still be accessed with commands that
place it in a window (such as `mct-list-completions-toggle',
`mct-switch-to-completions-top').

A less drastic measure is to set `mct-minimum-input' to an
appropriate value."
  :type '(repeat symbol)
  :group 'mct)

(defcustom mct-completion-passlist nil
  "Functions that do live updating of completions from the start.
This means that they ignore the value of `mct-live-completion'
and the `mct-minimum-input'.  They also bypass any possible delay
introduced by `mct-live-update-delay'."
  :type '(repeat symbol)
  :group 'mct)

(defcustom mct-display-buffer-action
  '((display-buffer-reuse-window display-buffer-at-bottom))
  "The action used to display the Completions' buffer.

The value has the form (FUNCTION . ALIST), where FUNCTIONS is
either an \"action function\" or a possibly empty list of action
functions.  ALIST is a possibly empty \"action alist\".

Sample configuration:

    (setq mct-display-buffer-action
          (quote ((display-buffer-reuse-window
                   display-buffer-in-side-window)
                  (side . left)
                  (slot . 99)
                  (window-width . 0.3))))

See Info node `(elisp) Displaying Buffers' for more details
and/or the documentation string of `display-buffer'."
  :type '(cons (choice (function :tag "Display Function")
                       (repeat :tag "Display Functions" function))
               alist)
  :group 'mct)

(defcustom mct-completions-format 'one-column
  "The appearance and sorting used by `mct-minibuffer-mode'.
See `completions-format' for possible values."
  :type '(choice (const horizontal) (const vertical) (const one-column))
  :group 'mct)

(defcustom mct-region-excluded-modes nil
  "List of modes excluded by `mct-region-global-mode'."
  :type '(repeat symbol))

;;;; Completion metadata

(defun mct--completion-category ()
  "Return completion category."
  (when-let ((window (active-minibuffer-window)))
    (with-current-buffer (window-buffer window)
      (completion-metadata-get
       (completion-metadata (buffer-substring-no-properties
                             (minibuffer-prompt-end)
                             (max (minibuffer-prompt-end) (point)))
                            minibuffer-completion-table
                            minibuffer-completion-predicate)
       'category))))

;;;; Basics of intersection between minibuffer and Completions' buffer

(define-obsolete-variable-alias
  'mct-hl-line 'mct-highlight-candidate "0.3.0")

(defface mct-highlight-candidate
  '((default :extend t)
    (((class color) (min-colors 88) (background light))
     :background "#b0d8ff" :foreground "#000000")
    (((class color) (min-colors 88) (background dark))
     :background "#103265" :foreground "#ffffff")
    (t :inherit highlight))
  "Face for current candidate in the completions' buffer."
  :group 'mct)

(declare-function display-line-numbers-mode "display-line-numbers")

(defun mct--setup-line-numbers ()
  "Set up line numbers for the completions' buffer."
  (when (and (derived-mode-p 'completion-list-mode)
             mct-show-completion-line-numbers)
    (display-line-numbers-mode 1)))

(defun mct--first-line-completion-p ()
  "Return non-nil if first line has completion candidates."
  (eq (line-number-at-pos (point-min))
      (line-number-at-pos (mct--first-completion-point))))

;; Thanks to Omar Antolín Camarena for recommending the use of
;; `cursor-sensor-functions' and the concomitant hook with
;; `cursor-censor-mode' instead of the dirty hacks I had before to
;; prevent the cursor from moving to that position where no completion
;; candidates could be found at point (e.g. it would break `embark-act'
;; as it could not read the topmost candidate when point was at the
;; beginning of the line, unless the point was moved forward).
(defun mct--setup-clean-completions ()
  "Keep only completion candidates in the Completions."
  (with-current-buffer standard-output
    (unless (mct--first-line-completion-p)
      (goto-char (point-min))
      (let ((inhibit-read-only t))
        (delete-region (point-at-bol) (1+ (point-at-eol)))
        (insert (propertize " "
                            'cursor-sensor-functions
                            (list
                             (lambda (_win prev dir)
                               (when (eq dir 'entered)
                                 (goto-char prev))))))
        (put-text-property (point-min) (point) 'invisible t)))))

(defun mct--fit-completions-window (&amp;rest _args)
  "Fit Completions' buffer to its window."
  (when-let ((window (mct--get-completion-window)))
    (with-current-buffer (window-buffer window)
      (setq-local window-resize-pixelwise t))
    (fit-window-to-buffer window (floor (frame-height) 2) 1)))

(defun mct--minimum-input ()
  "Test for minimum requisite input for live completions.
See `mct-minimum-input'."
  (&gt;= (- (point-max) (minibuffer-prompt-end)) mct-minimum-input))

;;;;; Live-updating Completions' buffer

;; Adapted from Omar Antolín Camarena's live-completions library:
;; &lt;https://github.com/oantolin/live-completions&gt;.
(defun mct--live-completions (&amp;rest _)
  "Update the *Completions* buffer.
Meant to be added to `after-change-functions'."
  (when (minibufferp) ; skip if we've exited already
    (while-no-input
      (if (or (mct--minimum-input)
              (eq mct-live-completion 'visible))
          (condition-case nil
              (save-match-data
                (save-excursion
                  (goto-char (point-max))
                  (mct--show-completions)))
            (quit (abort-recursive-edit)))
        (minibuffer-hide-completions)))))

(defun mct--live-completions-timer (&amp;rest _)
  "Update Completions with `mct-live-update-delay'."
  (let ((delay mct-live-update-delay))
    (when (&gt;= delay 0)
      (run-with-idle-timer delay nil #'mct--live-completions))))

(defun mct--live-completions-visible-timer (&amp;rest _)
  "Update visible Completions' buffer."
  (when (window-live-p (mct--get-completion-window))
    (mct--live-completions-timer)))

(defun mct--this-command ()
  "Return this command."
  (or (bound-and-true-p current-minibuffer-command) this-command))

(defun mct--setup-live-completions ()
  "Set up the completions' buffer."
  (cond
   ((memq (mct--this-command) mct-completion-passlist)
    (setq-local mct-minimum-input 0)
    (setq-local mct-live-update-delay 0)
    (mct--show-completions)
    (add-hook 'after-change-functions #'mct--live-completions nil t))
   ((null mct-live-completion))
   ((not (memq (mct--this-command) mct-completion-blocklist))
    (if (eq mct-live-completion 'visible)
        (add-hook 'after-change-functions #'mct--live-completions-visible-timer nil t)
      (add-hook 'after-change-functions #'mct--live-completions-timer nil t)))))

(defvar-local mct--active nil
  "Minibuffer local variable, t if Mct is active.")

(defun mct--active-p ()
  "Return t if Mct is active."
  (when-let* ((win (active-minibuffer-window))
              (buf (window-buffer win)))
      (buffer-local-value 'mct--active buf)))

(defun mct--region-p ()
  "Return non-nil if Mct is completing in region."
  (when-let ((buf (mct--region-current-buffer)))
    (with-current-buffer buf
      (bound-and-true-p mct-region-mode))))

(defun mct--display-completion-list-advice (&amp;rest app)
  "Prepare advice around `display-completion-list'.
Apply APP by first let binding the `completions-format' to
`mct-completions-format'."
  (if (or (mct--active-p) (mct--region-p))
      (let ((completions-format mct-completions-format))
        (apply app))
    (apply app)))

(defun mct--completing-read-advice (&amp;rest app)
  "Prepare advice around `completing-read-default'.
Apply APP by first setting up the minibuffer to work with Mct."
  (minibuffer-with-setup-hook
      (lambda ()
        (setq-local resize-mini-windows t
                    completion-auto-help t)
        (setq mct--active t)
        (mct--setup-live-completions)
        (mct--setup-keymap)
        (mct--setup-shadow-files))
    (apply app)))

;;;;; Alternating backgrounds (else "stripes")

;; Based on `stripes.el' (maintained by Štěpán Němec) and the
;; `embark-collect-zebra-minor-mode' from Omar Antolín Camarena's
;; Embark:
;;
;; 1. &lt;https://gitlab.com/stepnem/stripes-el&gt;
;; 2. &lt;https://github.com/oantolin/embark&gt;
(defface mct-stripe
  '((default :extend t)
    (((class color) (min-colors 88) (background light))
     :background "#f0f0f0")
    (((class color) (min-colors 88) (background dark))
     :background "#191a1b"))
  "Face for alternating backgrounds in the Completions' buffer."
  :group 'mct)

(defun mct--remove-stripes ()
  "Remove `mct-stripe' overlays."
  (remove-overlays nil nil 'face 'mct-stripe))

(defun mct--add-stripes ()
  "Overlay alternate rows with the `mct-stripe' face."
  (when (derived-mode-p 'completion-list-mode)
    (mct--remove-stripes)
    (save-excursion
      (goto-char (point-min))
      (when (overlays-at (point)) (forward-line))
      (while (not (eobp))
        (condition-case nil
            (forward-line 1)
          (user-error (goto-char (point-max))))
        (unless (eobp)
          (let ((pt (point)))
            (condition-case nil
                (forward-line 1)
              (user-error (goto-char (point-max))))
            ;; We set the overlay this way and give it a low priority so
            ;; that `mct--highlight-overlay' and/or the active region
            ;; can override it.
            (let ((stripe (make-overlay pt (point))))
              (overlay-put stripe 'priority -100)
              (overlay-put stripe 'face 'mct-stripe))))))))

;;;; Commands and helper functions

;; TODO 2021-11-17: We must `autoload' instead of `declare-function' for
;; things to work on Emacs 27.  Perhaps we should keep the latter but
;; add (eval-when-compile (require 'text-property-search))?  That should
;; work for packages, but not if we just `eval-buffer', right?

(autoload 'text-property-search-backward "text-property-search")
(autoload 'text-property-search-forward "text-property-search")
(autoload 'prop-match-beginning "text-property-search")
(autoload 'prop-match-end "text-property-search")

;; (declare-function text-property-search-backward "text-property-search" (property &amp;optional value predicate not-current))
;; (declare-function text-property-search-forward "text-property-search" (property &amp;optional value predicate not-current))
;; (declare-function prop-match-beginning "text-property-search" (cl-x))
;; (declare-function prop-match-end "text-property-search" (cl-x))

;; We need this to make things work on Emacs 27.
(defun mct--one-column-p ()
  "Test if we have a one-column view available."
  (and (eq mct-completions-format 'one-column)
       (&gt;= emacs-major-version 28)))

;;;;; Focus minibuffer and/or show completions

;;;###autoload
(defun mct-focus-minibuffer ()
  "Focus the active minibuffer."
  (interactive nil mct-minibuffer-mode)
  (when-let ((mini (active-minibuffer-window)))
    (select-window mini)))

(defun mct--get-completion-window ()
  "Find a live window showing completion candidates."
  (get-window-with-predicate
   (lambda (window)
     (string-match-p
      mct-completion-windows-regexp
      (buffer-name (window-buffer window))))))

(defun mct--show-completions ()
  "Show the completions' buffer."
  (let ((display-buffer-alist
         (cons (cons mct-completion-windows-regexp mct-display-buffer-action)
               display-buffer-alist))
        ;; don't ring the bell in `minibuffer-completion-help'
        ;; when &lt;= 1 completion exists.
        (ring-bell-function #'ignore)
        (message-log-max nil)
        (inhibit-message t))
    (save-excursion
      (pcase (and completion-in-region-mode completion-in-region--data)
        (`(,start ,end ,collection . ,plist)
         (let ((minibuffer-completion-table collection)
               (minibuffer-completion-predicate (plist-get plist :predicate))
               (completion-extra-properties plist))
           (minibuffer-completion-help start end)))
        (_ (minibuffer-completion-help))))))

;;;###autoload
(defun mct-focus-mini-or-completions ()
  "Focus the active minibuffer or the completions' window.

If both the minibuffer and the Completions are present, this
command will first move per invocation to the former, then the
latter, and then continue to switch between the two.

The continuous switch is essentially the same as running
`mct-focus-minibuffer' and `switch-to-completions' in
succession.

What constitutes a completions' window is ultimately determined
by `mct-completion-windows-regexp'."
  (interactive nil mct-minibuffer-mode)
  (let* ((mini (active-minibuffer-window))
         (completions (mct--get-completion-window)))
    (cond
     ((and mini (not (minibufferp)))
      (select-window mini nil))
     ((and completions (not (eq (selected-window) completions)))
      (select-window completions nil)))))

;;;###autoload
(defun mct-list-completions-toggle ()
  "Toggle the presentation of the completions' buffer."
  (interactive nil mct-minibuffer-mode)
  (if (mct--get-completion-window)
      (minibuffer-hide-completions)
    (mct--show-completions)))

;;;;; Commands for file completion

;; Adaptation of `icomplete-fido-backward-updir'.
(defun mct-backward-updir ()
  "Delete char before point or go up a directory."
  (interactive nil mct-minibuffer-mode)
  (cond
   ((and (eq (char-before) ?/)
         (eq (mct--completion-category) 'file))
    (when (string-equal (minibuffer-contents) "~/")
      (delete-minibuffer-contents)
      (insert (expand-file-name "~/"))
      (goto-char (line-end-position)))
    (save-excursion
      (goto-char (1- (point)))
      (when (search-backward "/" (point-min) t)
        (delete-region (1+ (point)) (point-max)))))
   (t (call-interactively 'backward-delete-char))))

;;;;; Cyclic motions between minibuffer and completions' buffer

(defun mct--completions-completion-p ()
  "Return non-nil if there is a completion at point."
  (let ((point (point)))
    ;; The `or' is for Emacs 27 where there were no completion--string
    ;; properties.
    (or (get-text-property point 'completion--string)
        (get-text-property point 'mouse-face))))

(defun mct--first-completion-point ()
  "Return the `point' of the first completion."
  (save-excursion
    (goto-char (point-min))
    (next-completion 1)
    (point)))

(defun mct--last-completion-point ()
  "Return the `point' of the last completion."
  (save-excursion
    (goto-char (point-max))
    (next-completion -1)
    (point)))

(defun mct--completions-line-boundary (boundary)
  "Determine if current line has reached BOUNDARY.
BOUNDARY is a line position at the top or bottom of the
Completions' buffer.  See `mct--first-completion-point' or
`mct--last-completion-point'.

This check only applies when `completions-format' is not assigned
a `one-column' value."
  (and (= (line-number-at-pos) (line-number-at-pos boundary))
       (not (mct--one-column-p))))

(defun mct--completions-no-completion-line-p (arg)
  "Check if ARGth line has a completion candidate."
  (save-excursion
    (vertical-motion arg)
    (eq 'completions-group-separator (get-text-property (point) 'face))))

(defun mct--switch-to-completions ()
  "Subroutine for switching to the completions' buffer."
  (unless (mct--get-completion-window)
    (mct--show-completions))
  (switch-to-completions))

(defun mct--restore-old-point-in-grid (line)
  "Restore old point in window if LINE is on its line."
  (unless (mct--one-column-p)
    (let (old-line old-point)
      (when-let ((window (mct--get-completion-window)))
        (setq old-point (window-old-point window)
              old-line (line-number-at-pos old-point))
        (when (= (line-number-at-pos line) old-line)
          (if (eq old-point (point-min))
              (goto-char (mct--first-completion-point))
            (goto-char old-point)))))))

(defun mct-switch-to-completions-top ()
  "Switch to the top of the completions' buffer."
  (interactive nil mct-minibuffer-mode mct-region-mode)
  (mct--switch-to-completions)
  (goto-char (mct--first-completion-point))
  (mct--restore-old-point-in-grid (point)))

(defun mct-switch-to-completions-bottom ()
  "Switch to the bottom of the completions' buffer."
  (interactive nil mct-minibuffer-mode mct-region-mode)
  (mct--switch-to-completions)
  (goto-char (point-max))
  (next-completion -1)
  (goto-char (point-at-bol))
  (unless (mct--completions-completion-p)
    (next-completion 1))
  (mct--restore-old-point-in-grid (point))
  (recenter
   (- -1
      (min (max 0 scroll-margin)
           (truncate (/ (window-body-height) 4.0))))
   t))

(defun mct--bottom-of-completions-p (arg)
  "Test if point is at the notional bottom of the Completions.
ARG is a numeric argument for `next-completion', as described in
`mct-next-completion-or-mini'."
  (or (eobp)
      (mct--completions-line-boundary (mct--last-completion-point))
      (= (save-excursion (next-completion arg) (point)) (point-max))
      ;; The empty final line case...
      (save-excursion
        (goto-char (point-at-bol))
        (and (not (bobp))
	         (or (beginning-of-line (1+ arg)) t)
	         (save-match-data
	           (looking-at "[\s\t]*$"))))))

(defun mct--next-completion (arg)
  "Routine to move to the next ARGth completion candidate."
  (if (not (mct--one-column-p))
      ;; Retaining the column number ensures that things work
      ;; intuitively in a grid view.
      (let ((col (current-column)))
        ;; The `when' is meant to skip past lines that do not
        ;; contain completion candidates, such as those with
        ;; `completions-group-format'.
        (when (mct--completions-no-completion-line-p (or arg 1))
          (if arg
              (setq arg 2)
            (setq arg (1+ arg))))
        (vertical-motion (or arg 1))
        (unless (eq col (save-excursion (goto-char (point-at-bol)) (current-column)))
          (line-move-to-column col))
        (when (or (&gt; (current-column) col)
                  (not (mct--completions-completion-p)))
          (next-completion -1)))
    (next-completion (or arg 1))))

(defun mct-next-completion-or-mini (&amp;optional arg)
  "Move to the next completion or switch to the minibuffer.
This performs a regular motion for optional ARG candidates, but
when point can no longer move in that direction it switches to
the minibuffer."
  (interactive "p" mct-minibuffer-mode)
  (let ((count (or arg 1)))
    (cond
     ((mct--bottom-of-completions-p count)
      (mct-focus-minibuffer))
     (t
      (mct--next-completion count))
     (setq this-command 'next-line))))

(defun mct--top-of-completions-p (arg)
  "Test if point is at the notional top of the Completions.
ARG is a numeric argument for `previous-completion', as described in
`mct-previous-completion-or-mini'."
  (or (bobp)
      (mct--completions-line-boundary (mct--first-completion-point))
      (= (save-excursion (previous-completion arg) (point)) (point-min))
      ;; FIXME 2021-12-27: Why do we need this now?  Regression upstream?
      (eq (line-number-at-pos) 1)))

(defun mct--previous-completion (arg)
  "Routine to move to the previous ARGth completion candidate."
  (if (not (mct--one-column-p))
      ;; Retaining the column number ensures that things work
      ;; intuitively in a grid view.
      (let ((col (current-column)))
        ;; The `when' is meant to skip past lines that do not
        ;; contain completion candidates, such as those with
        ;; `completions-group-format'.
        (when (mct--completions-no-completion-line-p (or (- arg) -1))
          (if arg
              (setq arg 2)
            (setq arg (1+ arg))))
        (vertical-motion (or (- arg) -1))
        (unless (eq col (save-excursion (goto-char (point-at-bol)) (current-column)))
          (line-move-to-column col))
        (when (or (&gt; (current-column) col)
                  (not (mct--completions-completion-p)))
          (next-completion -1)))
    (previous-completion (if (natnump arg) arg 1))))

(defun mct-previous-completion-or-mini (&amp;optional arg)
  "Move to the previous completion or switch to the minibuffer.
This performs a regular motion for optional ARG candidates, but
when point can no longer move in that direction it switches to
the minibuffer."
  (interactive "p" mct-minibuffer-mode)
  (let ((count (if (natnump arg) arg 1)))
    (cond
     ((mct--top-of-completions-p count)
      (mct-focus-minibuffer))
     (t
      (mct--previous-completion count)))))

(defun mct-next-completion-group (&amp;optional arg)
  "Move to the next completion group.
If ARG is supplied, move that many completion groups at a time."
  (interactive "p" mct-minibuffer-mode mct-region-mode)
  (dotimes (_ (or arg 1))
    (when-let (group (save-excursion
                       (text-property-search-forward 'face
                                                     'completions-group-separator
                                                     t nil)))
      (let ((pos (prop-match-end group)))
        (unless (eq pos (point-max))
          (goto-char pos)
          (next-completion 1))))))

(defun mct-previous-completion-group (&amp;optional arg)
  "Move to the previous completion group.
If ARG is supplied, move that many completion groups at a time."
  (interactive "p" mct-minibuffer-mode mct-region-mode)
  (dotimes (_ (or arg 1))
    ;; skip back, so if we're at the top of a group, we go to the previous one...
    (forward-line -1)
    (if-let (group (save-excursion
                     (text-property-search-backward 'face
                                                    'completions-group-separator
                                                    t nil)))
        (let ((pos (prop-match-beginning group)))
          (unless (eq pos (point-min))
            (goto-char pos)
            (next-completion 1)))
      ;; ...and if there was a match, go back down, so the point doesn't
      ;; end in the group separator
      (forward-line 1))))

;;;;; Candidate selection

;; The difference between this and choose-completion is that it will
;; exit even if a directory is selected in find-file, whereas
;; choose-completion expands the directory and continues the session.
(defun mct-choose-completion-exit ()
  "Run `choose-completion' in the Completions buffer and exit."
  (interactive nil mct-minibuffer-mode)
  (choose-completion)
  (when (active-minibuffer-window)
    (minibuffer-force-complete-and-exit)))

(defun mct-choose-completion-no-exit ()
  "Run `choose-completion' in the Completions without exiting."
  (interactive nil mct-minibuffer-mode)
  (let ((completion-no-auto-exit t))
    (choose-completion)))

(defvar display-line-numbers-mode)

(defun mct--line-completion (n)
  "Select completion on Nth line."
  (with-current-buffer (window-buffer (mct--get-completion-window))
    (goto-char (point-min))
    (forward-line (1- n))
    (mct-choose-completion-exit)))

(defun mct--line-bounds (n)
  "Test if Nth line is in the buffer."
  (with-current-buffer (window-buffer (mct--get-completion-window))
    (let ((bounds (count-lines (point-min) (point-max))))
      (unless (&lt;= n bounds)
        (user-error "%d is not within the buffer bounds (%d)" n bounds)))))

(defun mct-goto-line ()
  "Go to line N in the Completions' buffer."
  (interactive nil mct-minibuffer-mode)
  (let ((n (read-number "Line number: ")))
    (mct--line-bounds n)
    (select-window (mct--get-completion-window))
    (mct--line-completion n)))

(defun mct--line-number-selection ()
  "Show line numbers and select one of them."
  (with-current-buffer (window-buffer (mct--get-completion-window))
    (let ((mct-show-completion-line-numbers t))
      (if (bound-and-true-p display-line-numbers-mode)
          (mct-goto-line)
        (unwind-protect
            (progn
              (mct--setup-line-numbers)
              (mct-goto-line))
          (display-line-numbers-mode -1))))))

(defun mct-choose-completion-number ()
  "Select completion candidate on a given line number.
Upon selecting the candidate, exit the minibuffer (i.e. confirm
the choice right away).

If the Completions' buffer is not visible, it is displayed.  Line
numbers are shown on the side for during the operation (unless
`mct-show-completion-line-numbers' is non-nil, in which case they
are always visible).

This command can be invoked from either the minibuffer or the
Completions' buffer."
  (interactive nil mct-minibuffer-mode)
  (if (not (mct--one-column-p))
      (user-error "Cannot select by line in grid view")
    (let ((mct-remove-shadowed-file-names t)
          (mct-live-update-delay most-positive-fixnum)
          (enable-recursive-minibuffers t))
      (unless (mct--get-completion-window)
        (mct--show-completions))
      (if (or (and (derived-mode-p 'completion-list-mode)
                   (active-minibuffer-window))
              (and (minibufferp)
                   (mct--get-completion-window)))
          (mct--line-number-selection)))))

(defvar crm-completion-table)
(defvar crm-separator)

(defun mct--regex-to-separator (regex)
  "Parse REGEX of `crm-separator' in `mct-choose-completion-dwim'."
  (save-match-data
    (cond
     ;; whitespace-delimited, like default &amp; org-set-tag-command
     ((string-match (rx
                     bos "[" (1+ blank) "]*"
                     (group (1+ any))
                     "[" (1+ blank) "]*" eos)
                    regex)
      (match-string 1 regex))
     ;; literal character
     ((string= regex (regexp-quote regex))
      regex))))

(defun mct-choose-completion-dwim ()
  "Append to minibuffer when at `completing-read-multiple' prompt.
In any other prompt use `mct-choose-completion-no-exit'."
  (interactive nil mct-minibuffer-mode)
  (when-let* ((mini (active-minibuffer-window))
              (window (mct--get-completion-window))
              (buffer (window-buffer window)))
    (mct-choose-completion-no-exit)
    (with-current-buffer (window-buffer mini)
      (when crm-completion-table
        (let ((separator (or (mct--regex-to-separator crm-separator)
                             ",")))
          (insert separator))
        (let ((inhibit-message t))
          (switch-to-completions))))))

(defun mct-edit-completion ()
  "Edit the current completion candidate inside the minibuffer.

The current candidate is the one at point while inside the
Completions' buffer.

When point is in the minibuffer, the current candidate is
determined as follows:

+ The one at the last known position in the Completions'
  window (if the window is deleted and produced again, this value
  is reset).

+ The first candidate in the Completions' buffer.

A candidate is recognised for as long as point is not past its
last character."
  (interactive nil mct-minibuffer-mode)
  (when-let ((window (mct--get-completion-window))
             ((active-minibuffer-window)))
    (with-current-buffer (window-buffer window)
      (let* ((old-point (save-excursion
                          (select-window window)
                          (window-old-point)))
             (pos (if (= old-point (point-min))
                      (mct--first-completion-point)
                    old-point)))
        (goto-char pos)
        (mct-choose-completion-no-exit)))))

(defun mct-complete-and-exit ()
  "Complete current input and exit.

This is the same as with
\\&lt;mct-minibuffer-local-completion-map&gt;\\[mct-edit-completion],
followed by exiting the minibuffer with that candidate."
  (interactive nil mct-minibuffer-mode)
  (mct-edit-completion)
  (exit-minibuffer))

;;;;; Miscellaneous commands

;; This is needed to circumvent `mct--setup-clean-completions' with regard to
;; `cursor-sensor-functions'.
(defun mct-beginning-of-buffer ()
  "Go to the top of the Completions buffer."
  (interactive nil mct-minibuffer-mode)
  (goto-char (mct--first-completion-point)))

(defun mct-keyboard-quit-dwim ()
  "Control the exit behaviour for completions' buffers.

If in a completions' buffer and unless the region is active, run
`abort-recursive-edit'.  Otherwise run `keyboard-quit'.

If the region is active, deactivate it.  A second invocation of
this command is then required to abort the session."
  (interactive nil mct-minibuffer-mode)
  (when (derived-mode-p 'completion-list-mode)
    (if (use-region-p)
        (keyboard-quit)
      (abort-recursive-edit))))

;;;; Global minor mode setup

;;;;; Stylistic tweaks and refinements

;; Thanks to Omar Antolín Camarena for providing the messageless and
;; stealthily.  Source: &lt;https://github.com/oantolin/emacs-config&gt;.
(defun mct--messageless (&amp;rest app)
  "Set `minibuffer-message-timeout' to 0 while applying APP."
  (let ((minibuffer-message-timeout 0))
    (apply app)))

;; Copied from Daniel Mendler's `vertico' library:
;; &lt;https://github.com/minad/vertico&gt;.
(defun mct--crm-indicator (args)
  "Add prompt indicator to `completing-read-multiple' filter ARGS."
  (cons (concat "[CRM] " (car args)) (cdr args)))

;; Adapted from Omar Antolín Camarena's live-completions library:
;; &lt;https://github.com/oantolin/live-completions&gt;.
(defun mct--honor-inhibit-message (&amp;rest app)
  "Honor `inhibit-message' while applying APP."
  (unless inhibit-message
    (apply app)))

;; Note that this solves bug#45686:
;; &lt;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=45686&gt;
(defun mct--stealthily (&amp;rest app)
  "Prevent minibuffer default from counting as a modification.
Apply APP while inhibiting modification hooks."
  (let ((inhibit-modification-hooks t))
    (apply app)))

(defun mct--setup-appearance ()
  "Set up variables for the appearance of the Completions' buffer."
  (when mct-hide-completion-mode-line
    (setq-local mode-line-format nil))
  (if mct-apply-completion-stripes
      (mct--add-stripes)
    (mct--remove-stripes)))

;;;;; Shadowed path

;; Adapted from icomplete.el
(defun mct--shadow-filenames (&amp;rest _)
  "Hide shadowed file names."
  (let ((saved-point (point)))
    (when (and
           mct-remove-shadowed-file-names
           (eq (mct--completion-category) 'file)
           rfn-eshadow-overlay (overlay-buffer rfn-eshadow-overlay)
           (eq (mct--this-command) 'self-insert-command)
           (= saved-point (point-max))
           (or (&gt;= (- (point) (overlay-end rfn-eshadow-overlay)) 2)
               (eq ?/ (char-before (- (point) 2)))))
      (delete-region (overlay-start rfn-eshadow-overlay)
                     (overlay-end rfn-eshadow-overlay)))))

(defun mct--setup-shadow-files ()
  "Set up shadowed file name deletion."
  (add-hook 'after-change-functions #'mct--shadow-filenames nil t))

;;;;; Highlight current candidate

(defvar-local mct--highlight-overlay nil
  "Overlay to highlight candidate in the Completions' buffer.")

(defvar mct--overlay-priority -50
  "Priority used on the `mct--highlight-overlay'.
This value means that it takes precedence over lines that have
the `mct-stripe' face, while it is overriden by the active
region.")

;; This is for Emacs 27 which does not have a completion--string text
;; property.
(defun mct--completions-text-property-search ()
  "Search for text property of completion candidate."
  (or (text-property-search-forward 'completion--string)
      (text-property-search-forward 'mouse-face)))

;; The `if-let' is to prevent highlighting of empty space, such as by
;; clicking on it with the mouse.
(defun mct--completions-completion-beg ()
  "Return point of completion candidate at START and END."
  (if-let ((string (mct--completions-completion-p)))
      (save-excursion
        (prop-match-beginning (mct--completions-text-property-search)))
    (point)))

;; Same as above for the `if-let'.
(defun mct--completions-completion-end ()
  "Return end of completion candidate."
  (if-let ((string (mct--completions-completion-p)))
      (save-excursion
        (if (mct--one-column-p)
            (1+ (point-at-eol))
          (prop-match-end (mct--completions-text-property-search))))
    (point)))

(defun mct--overlay-make ()
  "Make overlay to highlight current candidate."
  (let ((ol (make-overlay (point) (point))))
    (overlay-put ol 'priority mct--overlay-priority)
    (overlay-put ol 'face 'mct-highlight-candidate)
    ol))

(defun mct--overlay-move (overlay)
  "Highlight the candidate at point with OVERLAY."
  (let* ((beg (mct--completions-completion-beg))
         (end (mct--completions-completion-end)))
	(move-overlay overlay beg end)))

(defun mct--completions-candidate-highlight ()
  "Activate `mct--highlight-overlay'."
  (unless (overlayp mct--highlight-overlay)
    (setq mct--highlight-overlay (mct--overlay-make)))
  (mct--overlay-move mct--highlight-overlay))

(defun mct--setup-highlighting ()
  "Highlight the current completion in the Completions' buffer."
  (add-hook 'post-command-hook #'mct--completions-candidate-highlight nil t))

;;;;; Keymaps

(defvar mct-minibuffer-completion-list-map
  (let ((map (make-sparse-keymap)))
    (define-key map [remap keyboard-quit] #'mct-keyboard-quit-dwim)
    (define-key map [remap goto-line] #'mct-choose-completion-number)
    (define-key map [remap next-line] #'mct-next-completion-or-mini)
    (define-key map (kbd "n") #'mct-next-completion-or-mini)
    (define-key map [remap previous-line] #'mct-previous-completion-or-mini)
    (define-key map (kbd "p") #'mct-previous-completion-or-mini)
    (define-key map [remap backward-paragraph] #'mct-previous-completion-group)
    (define-key map [remap forward-paragraph] #'mct-next-completion-group)
    (define-key map (kbd "e") #'mct-focus-minibuffer)
    (define-key map (kbd "M-e") #'mct-edit-completion)
    (define-key map (kbd "TAB") #'mct-choose-completion-no-exit)
    (define-key map (kbd "RET") #'mct-choose-completion-exit)
    (define-key map (kbd "M-RET") #'mct-choose-completion-dwim)
    (define-key map [remap beginning-of-buffer] #'mct-beginning-of-buffer)
    map)
  "Derivative of `completion-list-mode-map'.")

(defvar mct-minibuffer-local-completion-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-j") #'exit-minibuffer)
    (define-key map [remap goto-line] #'mct-choose-completion-number)
    (define-key map [remap next-line] #'mct-switch-to-completions-top)
    (define-key map [remap next-line-or-history-element] #'mct-switch-to-completions-top)
    (define-key map [remap previous-line] #'mct-switch-to-completions-bottom)
    (define-key map [remap previous-line-or-history-element] #'mct-switch-to-completions-bottom)
    (define-key map (kbd "M-e") #'mct-edit-completion)
    (define-key map (kbd "C-&lt;return&gt;") #'mct-complete-and-exit)
    (define-key map (kbd "C-l") #'mct-list-completions-toggle)
    map)
  "Derivative of `minibuffer-local-completion-map'.")

(defvar mct-minibuffer-local-filename-completion-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "DEL") #'mct-backward-updir)
    map)
  "Derivative of `minibuffer-local-filename-completion-map'.")

(defun mct--setup-completion-list-keymap ()
  "Set up completion list keymap."
  (use-local-map
   (make-composed-keymap mct-minibuffer-completion-list-map
                         (current-local-map))))

(defun mct--setup-keymap ()
  "Set up minibuffer keymaps."
  (use-local-map
   (make-composed-keymap mct-minibuffer-local-completion-map
                         (current-local-map)))
  (when (eq (mct--completion-category) 'file)
    (use-local-map
     (make-composed-keymap mct-minibuffer-local-filename-completion-map
                           (current-local-map)))))

(defun mct--setup-completion-list ()
  "Set up the completion-list for Mct."
  (when (mct--active-p)
    (setq-local completion-show-help nil
                truncate-lines t)
    (mct--setup-clean-completions)
    (mct--setup-appearance)
    (mct--setup-completion-list-keymap)
    (mct--setup-highlighting)
    (mct--setup-line-numbers)
    (cursor-sensor-mode)))

;;;;; mct-minibuffer-mode declaration

(declare-function minibuf-eldef-setup-minibuffer "minibuf-eldef")

;;;###autoload
(define-minor-mode mct-minibuffer-mode
  "Set up opinionated default completion UI."
  :global t
  :group 'mct
  (if mct-minibuffer-mode
      (progn
        (add-hook 'completion-list-mode-hook #'mct--setup-completion-list)
        (dolist (fn '(exit-minibuffer
                      choose-completion
                      minibuffer-force-complete
                      minibuffer-complete-and-exit
                      minibuffer-force-complete-and-exit))
          (advice-add fn :around #'mct--messageless))
        (advice-add #'completing-read-default :around #'mct--completing-read-advice)
        (advice-add #'completing-read-multiple :around #'mct--completing-read-advice)
        (advice-add #'completing-read-multiple :filter-args #'mct--crm-indicator)
        (advice-add #'display-completion-list :around #'mct--display-completion-list-advice)
        (advice-add #'minibuffer-completion-help :after #'mct--fit-completions-window)
        (advice-add #'minibuffer-message :around #'mct--honor-inhibit-message)
        (advice-add #'minibuf-eldef-setup-minibuffer :around #'mct--stealthily))
    (remove-hook 'completion-list-mode-hook #'mct--setup-completion-list)
    (dolist (fn '(exit-minibuffer
                  choose-completion
                  minibuffer-force-complete
                  minibuffer-complete-and-exit
                  minibuffer-force-complete-and-exit))
      (advice-remove fn #'mct--messageless))
    (advice-remove #'completing-read-default #'mct--completing-read-advice)
    (advice-remove #'completing-read-multiple #'mct--completing-read-advice)
    (advice-remove #'completing-read-multiple #'mct--crm-indicator)
    (advice-remove #'display-completion-list #'mct--display-completion-list-advice)
    (advice-remove #'minibuffer-completion-help #'mct--fit-completions-window)
    (advice-remove #'minibuffer-message #'mct--honor-inhibit-message)
    (advice-remove #'minibuf-eldef-setup-minibuffer #'mct--stealthily)))

(define-obsolete-function-alias 'mct-mode 'mct-minibuffer-mode "0.4.0")

;;;;; mct-region-mode declaration

;;;;;; Live completions

(defun mct--region-current-buffer ()
  "Return current buffer of completion in region."
  (and completion-in-region--data
       (marker-buffer (nth 0 completion-in-region--data))))

(defun mct--region-live-completions (&amp;rest _)
  "Update the *Completions* buffer.
Meant to be added to `after-change-functions'."
  (when (mct--region-current-buffer)
    (while-no-input
      (condition-case nil
          (save-match-data
            (mct--show-completions))
        (quit (keyboard-quit))))))

(defun mct--region-live-update ()
  "Hook up `mct--region-live-completions'."
  (add-hook 'after-change-functions #'mct--region-live-completions nil t))

;;;;;; Minor mode specification

(defvar mct-region-buffer-map
  (let ((map (make-sparse-keymap)))
    (define-key map [remap next-line] #'mct-switch-to-completions-top)
    (define-key map [remap previous-line] #'mct-switch-to-completions-bottom)
    ;; TODO: Either keep the TAB=completion-at-point binding or add our own
    ;; command which is compatible with orderless completion.
    (define-key map (kbd "TAB") #'ignore)
    map)
  "Derivative of `completion-in-region-map'.")

(defun mct--region-setup-completion-in-region ()
  "Set up Mct for `completion-in-region'."
  (if completion-in-region-mode
      (progn
        (setcdr (assq #'completion-in-region-mode minor-mode-overriding-map-alist)
                (make-composed-keymap mct-region-buffer-map completion-in-region-mode-map))
        (mct--region-current-buffer)
        ;; NOTE: Ignore the predicate in order to support orderless style.
        ;; TODO: This override should be guarded by a customizable variable,
        ;; since it is intrusive. See also `corfu-quit-at-boundary'.
        (setq completion-in-region-mode--predicate (lambda () t))
        (mct--region-live-update))
    ;; Teardown
    (remove-hook 'after-change-functions #'mct--region-live-completions t)))

(defun mct-next-completion-or-quit (&amp;optional arg)
  "Move to next completion or bury the Completions' buffer.

This performs a regular motion for optional ARG candidates, but
when point can no longer move in that direction it buries the
Completions' buffer.

This is a counterpart of `mct-next-completion-or-mini' that is
meant for the case of completion in region (i.e. not in the
minibuffer)."
  (interactive nil mct-region-mode)
  (let ((count (or arg 1)))
    (cond
     ((mct--bottom-of-completions-p count)
      (minibuffer-hide-completions))
     (t
      (mct--next-completion count)))))

(defun mct-previous-completion-or-quit (&amp;optional arg)
  "Move to previous completion or bury the Completions' buffer.

This performs a regular motion for optional ARG candidates, but
when point can no longer move in that direction it buries the
Completions' buffer.

This is a counterpart of `mct-previous-completion-or-mini' that
is meant for the case of completion in region (i.e. not in the
minibuffer)."
  (interactive nil mct-region-mode)
  (let ((count (if (natnump arg) arg 1)))
    (cond
     ((mct--top-of-completions-p count)
      (minibuffer-hide-completions))
     (t
      (mct--previous-completion count)))))

(defvar mct-region-completion-list-map
  (let ((map (make-sparse-keymap)))
    ;; TODO 2021-12-29: Maybe we can make this work in this context as
    ;; well.
    ;; (define-key map [remap goto-line] #'mct-choose-completion-number)
    (define-key map [remap next-line] #'mct-next-completion-or-quit)
    (define-key map [remap previous-line] #'mct-previous-completion-or-quit)
    (define-key map (kbd "n") #'mct-next-completion-or-quit)
    (define-key map (kbd "p") #'mct-previous-completion-or-quit)
    (define-key map (kbd "M-n") #'mct-next-completion-group)
    (define-key map (kbd "M-p") #'mct-previous-completion-group)
    (define-key map (kbd "TAB") #'choose-completion)
    (define-key map (kbd "RET") #'choose-completion)
    (define-key map [remap beginning-of-buffer] #'mct-beginning-of-buffer)
    map)
  "Derivative of `completion-list-mode-map'.")

(defun mct--region-setup-completion-list-keymap ()
  "Set up completion list keymap."
  (use-local-map
   (make-composed-keymap mct-region-completion-list-map
                         (current-local-map))))

(defun mct--region-setup-completion-list ()
  "Set up the completion-list for Mct."
  (when (mct--region-p)
    (setq-local completion-show-help nil
                truncate-lines t)
    (mct--setup-clean-completions)
    (mct--setup-appearance)
    (mct--region-setup-completion-list-keymap)
    (mct--setup-highlighting)
    (mct--setup-line-numbers)
    (cursor-sensor-mode)))

(defun mct--region-completion-done (&amp;rest app)
  "Apply APP before disabling completion in region."
  (apply app)
  (completion-in-region-mode -1))

;;;###autoload
(define-minor-mode mct-region-mode
  "Set up interactivity over the default `completion-in-region'."
  :global nil
  (if mct-region-mode
      (progn
        (advice-add #'completion--done :around #'mct--region-completion-done)
        (add-hook 'completion-list-mode-hook #'mct--region-setup-completion-list)
        (add-hook 'completion-in-region-mode-hook #'mct--region-setup-completion-in-region)
        (advice-add #'minibuffer-completion-help :after #'mct--fit-completions-window)
        (advice-add #'display-completion-list :around #'mct--display-completion-list-advice)
        (advice-add #'minibuffer-message :around #'mct--honor-inhibit-message))
    (advice-remove #'completion--done #'mct--region-completion-done)
    (remove-hook 'completion-list-mode-hook #'mct--region-setup-completion-list)
    (remove-hook 'completion-in-region-mode-hook #'mct--region-setup-completion-in-region)
    (advice-remove #'minibuffer-completion-help #'mct--fit-completions-window)
    (advice-remove #'display-completion-list #'mct--display-completion-list-advice)
    (advice-remove #'minibuffer-message #'mct--honor-inhibit-message)))

;; The `mct-region-global-mode', `mct-region--on', and
;; `mct-region-excluded-modes' are adapted from the corfu.el library of
;; Daniel Mendler.

;;;###autoload
(define-globalized-minor-mode mct-region-global-mode mct-region-mode mct-region--on)

(defun mct-region--on ()
  "Turn `mct-region-mode' on."
  (unless (or noninteractive
              (eq (aref (buffer-name) 0) ?\s)
              (memq major-mode mct-region-excluded-modes))
    (mct-region-mode 1)))

(provide 'mct)
;;; mct.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:2733674b-51f9-494e-b34d-e8842ac4ef96" class="outline-4">
<h4 id="h:2733674b-51f9-494e-b34d-e8842ac4ef96"><span class="section-number-4">3.1.4.</span> Minibuffer history (savehist-mode)</h4>
<div class="outline-text-4" id="text-h:2733674b-51f9-494e-b34d-e8842ac4ef96">
<p>
The built-in <code>savehist-mode</code> keeps a record of actions involving the
minibuffer.  You can access previous inputs with <code>M-p</code> and <code>M-n</code>.  Well
designed commands that use completion will have their own history, so
those key bindings will only cycle through relevant results.  You can
also search backwardly through them with <code>M-r</code>.
</p>

<p>
This kind of functionality is of paramount importance to a fast and
efficient workflow involving any completion framework that leverages the
built-in mechanisms.
</p>

<p>
Emacs will remember your input and choices so it will prioritise the
desired results when trying to force complete a given input.  Make sure
to also read the <a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and my extras (mct.el)</a> for
the minibuffer-specific setup.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Minibuffer history (savehist-mode)
(prot-emacs-builtin-package 'savehist
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-hook 'after-init-hook #'savehist-mode))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:9c9401d6-8c53-4276-be4c-3bff345d3eeb" class="outline-4">
<h4 id="h:9c9401d6-8c53-4276-be4c-3bff345d3eeb"><span class="section-number-4">3.1.5.</span> Enhanced minibuffer commands (consult.el and prot-consult.el)</h4>
<div class="outline-text-4" id="text-h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">
<p>
Daniel Mendler's Consult is a welcome addition to the ecosystem of
modular, extensible tools that work with the standard minibuffer
completion mechanisms and, by extension, with every user interface that
largely conforms with them (Icomplete, Selectrum) or fully respects them
(Embark and <a href="https://github.com/minad/vertico">Daniel's own Vertico</a>).  For my case, this means that it
works with everything included in <a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>.
</p>

<p>
Consult's value proposition is two-fold: (1) remain aligned with the
Emacs completion paradigm, and (2) offer minibuffer-centric commands
that either enhance aspects of interactivity and functionality found in
existing commands or outright provide them from scratch.
</p>

<p>
Some Consult commands are drop-in replacements for built-in options.
For example <code>consult-complex-command</code> offers an improved interactive
experience over the default <code>repeat-complex-command</code>.  Same principle for
<code>consult-goto-line</code> which displays the line numbers and offers a live
preview of where you are about to land.
</p>

<p>
Other commands enhance the defaults with a filtering mechanism that
targets candidates by their type.  A case in point is <code>consult-imenu</code>
which recognises syntactic constructs that are variables, functions,
macros (configurable via <code>consult-imenu-narrow</code>, <code>consult-imenu-toplevel</code>).
</p>

<p>
This "filtering" mechanism, which is internally known as "narrowing",
can be accessed via a key binding for all commands that support it.  In
my case, that key is the right angled bracket, or greater than sign (<code>&gt;</code>)
from inside the minibuffer (configure <code>consult-narrow-key</code>).  So you type
the narrow key and follow it up with another key that matches the
relevant targets.  Hit backspace to remove the narrowing.  As for the
available keys, type <code>?</code> which calls <code>consult-narrow-help</code>.
</p>

<p>
This narrowing-by-type mechanism can also be used without inputting the
<code>consult-narrow-key</code>, just by typing in the appropriate character and
inserting a space.  For instance, to search only for functions in
<code>consult-imenu</code>, you type <code>f</code> and then a space.  Consult will add an
indicator to the minibuffer prompt describing the active filter.
</p>

<p>
In general, commands that involve multiple groups can benefit from this
type of narrowing.  The prime example is <code>consult-buffer</code> which combines
sources of recently visited files, bookmarks, and buffers (those are
configurable via the variable <code>consult-buffer-sources</code>).  Though others
follow the same principle, such as the aforementioned <code>consult-imenu</code> and
<code>consult-bookmark</code>.
</p>

<p>
Another intriguing facility of Consult is its asynchronous call to
external processes, such as <code>grep</code> and <code>find</code>.  Those calls can be
configured to return some output based on a minimum number of
characters, while they also allow for tweaks to their update delays.
Interactivity is already a given, meaning that you can continue typing
and see the results pop up.  Furthermore, they implement a two-stage
input scheme, separated by a configurable delimiter (<code>#</code> by default and
controlled with <code>consult-async-default-split</code>):
</p>

<ul class="org-ul">
<li>First you type in the pattern that should be sent to the external
program.  This is what triggers the asynchronous call.  So your input
looks like this: <code>#PATTERN</code>.  The pattern will typically consist of some
text or a regular expression, but can also include command line flags
for the underlying CLI program (check Consult's documentation for the
technicalities).</li>

<li>Then you can add another field delimiter to instruct Consult to (i)
keep the results that <code>#PATTERN</code> gave you and (ii) leverage Emacs' own
mechanisms to further narrow the list.  Now your input looks like
this: <code>#PATTERN#MORE-PATTERNS</code>.  The <code>#MORE-PATTERNS</code> will use whatever
completion styles you have configured (check my <code>completion-styles</code>).</li>
</ul>

<p>
As already suggested, Consult provides previews for its commands.  This
feature should work without any further intervention.
</p>

<p>
Consult can shine when used in tandem with Embark to produce buffers
that hold all the candidates of any given minibuffer completion command
(<a href="#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">Extended minibuffer actions and more (embark.el and prot-embark.el)</a>).
For example, <code>embark-export</code> can be called from inside <code>consult-grep</code> (and
variants) to deliver a dedicated <code>grep-mode</code> buffer, which can then be
edited with the help of the <code>wgrep</code> package (check <a href="#h:42624165-f4cb-4318-abce-c11232426880">wgrep (writable grep)</a>).
Use that to quickly refactor some pattern across your files.
</p>

<p>
Other nice extensions of Consult are (i) its ability to work as a
generic front-end for completion, and (ii) its preview facility for
registers.  The former is done by <code>consult-completion-in-region</code> which
provides completion for commands such as <code>dabbrev-completion</code> or the TAB
key in programming buffers (see <a href="#h:d51d37df-4e58-4e0b-85a1-019ceda342f6">Tabs, indentation, and the TAB key</a>).
While the latter is an overall prettier presentation for the familiar
register preview window (watch: <a href="https://protesilaos.com/codelog/2020-03-08-emacs-registers/">Primer on Emacs “registers”</a>
(2020-03-08)).
</p>

<p>
As for registers themselves, Consult furnishes three commands, one
focused on minibuffer completion and two as do-what-I-mean alternatives
to the built-in facilities of storing and inserting&#x2014;or jumping
to&#x2014;registered data.
</p>

<ul class="org-ul">
<li><code>consult-register</code> is what you use for completion.  It searches through
the contents of the registered compartments and, thus, works well when
you have text-heavy registers that you need to filter through before
inserting one at point.</li>

<li><p>
<code>consult-register-store</code> will save a "thing" to the specified key.  What
the thing is depends on the context:
</p>

<ul class="org-ul">
<li>If the region is active, it will operate on the affected text.</li>
<li>If you call it with a numeric argument, it will store that number.</li>
<li>If no region is active and no numeric prefix is supplied, it will
let you select between the current position (point), window
configuration (window), set of frames with their window
configurations (frameset), or keyboard macro (kmacro).</li>
</ul>

<p>
This do-what-I-mean facility is complemented by an actions' menu that
offers hints on the keys you can use to specify the desired step
forward.  For example, if you are operating on a region, <code>M-a</code> will let
you append the text to the given register.
</p></li>

<li><code>consult-register-load</code> simplifies the mental workload of actually using
a register.  Unlike the Emacs default where you need to know in
advance what type of data does the register holds in order to use the
right action for it, Consult's version just handles that for you.  All
you have to do is instruct it to use the given register and it will
know whether it should insert some text or jump to a point/frameset,
etc.</li>
</ul>

<p>
In practice, I only ever use <code>consult-register</code> because I have already
developed muscle memory for the register-related actions.  Though using
all three of the above is easier to learn and more consistent overall.
</p>

<p>
Note that my <code>prot-consult.el</code> (reproduced after the following package
configurations) defines some <i>quick and dirty</i> extensions or thin wrappers
around Consult commands.  The former <b>will be reviewed</b> in favour of
better alternatives, even though they "simply work" with everything I
try.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Enhanced minibuffer commands (consult.el and prot-consult.el)
(prot-emacs-elpa-package 'consult
  (setq consult-line-numbers-widen t)
  ;; (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key "&gt;")
  (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions"
                           :types ((?f "Functions" font-lock-function-name-face)
                                   (?m "Macros"    font-lock-keyword-face)
                                   (?p "Packages"  font-lock-constant-face)
                                   (?t "Types"     font-lock-type-face)
                                   (?v "Variables" font-lock-variable-name-face)))))
  ;; Search C-h f for more "bookmark jump" handlers.
  (setq consult-bookmark-narrow
        `((?d "Docview" ,#'doc-view-bookmark-jump)
          (?e "Eshell" ,#'eshell-bookmark-jump)
          (?f "File" ,#'bookmark-default-handler)
          (?h "Help" ,#'help-bookmark-jump)
          (?i "Info" ,#'Info-bookmark-jump)
          (?m "Man" ,#'Man-bookmark-jump)
          (?p "PDF" ,#'pdf-view-bookmark-jump)
          (?v "VC Dir" ,#'vc-dir-bookmark-jump)
          (?w "EWW" ,#'prot-eww-bookmark-jump)))
  (setq register-preview-delay 0.8
        register-preview-function #'consult-register-format)
  (setq consult-find-args "find . -not ( -wholename */.* -prune )")
  (setq consult-preview-key 'any)

  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x r b") #'consult-bookmark) ; override `bookmark-jump'
    (define-key map (kbd "C-x M-:") #'consult-complex-command)
    (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
    (define-key map (kbd "C-x M-k") #'consult-kmacro)
    (define-key map [remap goto-line] #'consult-goto-line)
    (define-key map (kbd "M-K") #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
    (define-key map (kbd "M-F") #'consult-focus-lines) ; same principle
    (define-key map (kbd "M-s M-b") #'consult-buffer)
    (define-key map (kbd "M-s M-f") #'consult-find)
    (define-key map (kbd "M-s M-g") #'consult-grep)
    (define-key map (kbd "M-s M-m") #'consult-mark)
    (define-key map (kbd "C-x r r") #'consult-register)) ; Use the register's prefix
  (define-key consult-narrow-map (kbd "?") #'consult-narrow-help))

(prot-emacs-builtin-package 'prot-consult
  (setq consult-project-root-function #'prot-consult-project-root)
  (setq prot-consult-command-centre-list
        '(consult-line
          prot-consult-line
          consult-mark))
  (setq prot-consult-command-top-list
        '(consult-outline
          consult-imenu
          prot-consult-outline
          prot-consult-imenu))
  (prot-consult-set-up-hooks-mode 1)
  (let ((map global-map))
    (define-key map (kbd "M-s M-i") #'prot-consult-imenu)
    (define-key map (kbd "M-s M-s") #'prot-consult-outline)
    (define-key map (kbd "M-s M-y") #'prot-consult-yank)
    (define-key map (kbd "M-s M-l") #'prot-consult-line)))
</pre>
</div>

<p>
Here is <code>prot-consult.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-consult.el --- Tweak consult.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Tweaks for `consult.el' intended for my Emacs configuration:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'consult nil t)
(require 'consult-imenu nil t)
(require 'prot-pulse)

(defgroup prot-consult ()
  "Tweaks for consult.el."
  :group 'minibuffer)

(defcustom prot-consult-command-centre-list '(consult-line consult-mark)
  "Commands to run `prot-consult-jump-recentre-hook'.
You must restart function `prot-consult-set-up-hooks-mode' for
changes to take effect."
  :group 'prot-consult
  :type 'list)

(defcustom prot-consult-command-top-list '(consult-outline)
  "Commands to run `prot-consult-jump-top-hook'.
You must restart function `prot-consult-set-up-hooks-mode' for
changes to take effect."
  :group 'prot-consult
  :type 'list)

;;;; Setup for some consult commands (TODO: needs review)

(defvar prot-consult-jump-recentre-hook nil
  "Hook that runs after select Consult commands.
To be used with `advice-add'.")

(defun prot-consult-after-jump-recentre (&amp;rest _)
  "Run `prot-consult-jump-recentre-hook'."
  (run-hooks 'prot-consult-jump-recentre-hook))

(defvar prot-consult-jump-top-hook nil
  "Hook that runs after select Consult commands.
To be used with `advice-add'.")

(defun prot-consult-after-jump-top (&amp;rest _)
  "Run `prot-consult-jump-top-hook'."
  (run-hooks 'prot-consult-jump-top-hook))

;;;###autoload
(define-minor-mode prot-consult-set-up-hooks-mode
  "Set up hooks for Consult."
  :init-value nil
  :global t
  (if prot-consult-set-up-hooks-mode
      (progn
        (dolist (fn prot-consult-command-centre-list)
          (advice-add fn :after #'prot-consult-after-jump-recentre))
        (dolist (fn prot-consult-command-top-list)
          (advice-add fn :after #'prot-consult-after-jump-top))
        (add-hook 'prot-consult-jump-recentre-hook #'prot-pulse-recentre-centre)
        (add-hook 'prot-consult-jump-top-hook #'prot-pulse-recentre-top)
        (add-hook 'prot-consult-jump-top-hook #'prot-pulse-show-entry))
    (dolist (fn prot-consult-command-centre-list)
      (advice-remove fn #'prot-consult-after-jump-recentre))
    (dolist (fn prot-consult-command-top-list)
      (advice-remove fn #'prot-consult-after-jump-top))
    (remove-hook 'prot-consult-jump-recentre-hook #'prot-pulse-recentre-centre)
    (remove-hook 'prot-consult-jump-top-hook #'prot-pulse-recentre-top)
    (remove-hook 'prot-consult-jump-top-hook #'prot-pulse-show-entry)))

;;;; Commands

(defvar consult--find-cmd)
(defvar consult--directory-prompt)
(declare-function consult--find "consult")
(autoload 'prot-orderless-with-styles "prot-orderless")

;;;###autoload
(defun prot-consult-project-root ()
  "Return path to project or `default-directory'.
Intended to be assigned to `consult-project-root-function'."
  (or (vc-root-dir)
      (locate-dominating-file "." ".git")
      default-directory))

;;;###autoload
(defun prot-consult-outline ()
  "Run `consult-outline' through `prot-orderless-with-styles'."
  (interactive)
  (prot-orderless-with-styles 'consult-outline))

;;;###autoload
(defun prot-consult-imenu ()
  "Run `consult-imenu' through `prot-orderless-with-styles'."
  (interactive)
  (prot-orderless-with-styles 'consult-imenu))

;;;###autoload
(defun prot-consult-line ()
  "Run `consult-line' through `prot-orderless-with-styles'."
  (interactive)
  (prot-orderless-with-styles 'consult-line))

;;;###autoload
(defun prot-consult-yank ()
  "Run Consult yank through `prot-orderless-with-styles'.
Wraps around the `consult-yank-from-kill-ring' command."
  (interactive)
  (prot-orderless-with-styles 'consult-yank-from-kill-ring))

(provide 'prot-consult)
;;; prot-consult.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:4c41ab10-9533-40b2-8c0a-e38b5f0194f6" class="outline-5">
<h5 id="h:4c41ab10-9533-40b2-8c0a-e38b5f0194f6"><span class="section-number-5">3.1.5.1.</span> Switch to directories (consult-dir.el)</h5>
<div class="outline-text-5" id="text-h:4c41ab10-9533-40b2-8c0a-e38b5f0194f6">
<p>
This is another nifty package by Karthik Chikmagalur (author of
<code>project-x</code>, among others, which I configure elsewhere in this document:
<a href="#h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055">Extra features for projects (project-x.el)</a>).  <code>consult-dir</code> provides an
all-in-one interface with minibuffer completion for switching to a
directory that belongs to (i) your list of bookmarks, (ii) the current
project, (iii) your other projects, or (iv) recent files.  It thus
integrates nicely with other parts of the Emacs setup, where those are
present:
</p>

<ul class="org-ul">
<li><a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>.</li>
<li><a href="#h:79cd6177-a81b-420f-8759-e6927b974377">Built-in bookmarking framework (bookmark.el and prot-bookmark.el)</a>.</li>
<li><a href="#h:5723c4bb-ff6c-449f-bb60-be66fab3f137">Completion for recent files and directories (prot-recentf.el)</a>.</li>
</ul>

<p>
As its name suggests, <code>consult-dir</code> builds on the Consult package by
Daniel Mendler (<a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el)</a>).  It thus
retains the functionality of its base library, such as the ability to
narrow the list of candidates to a subset in the same way as, e.g., the
<code>consult-buffer</code> command does it: while at the empty minibuffer prompt,
type <code>r</code> for recent directories, <code>m</code> for bookmarked entries, <code>p</code> for projects,
and follow it up with an empty space.  This applies the relevant filter.
To remove it just delete backwards.
</p>

<p>
There are two main uses of the <code>consult-dir</code> command.  The first is the
general feature of switching to the buffer of choice.  The other is when
faced with a minibuffer prompt that expects a file path, such as when
you copy or rename a file with Dired.  In that case you want to perform
the operation with one of your directories of interest as the target, so
you call the <code>consult-dir</code> command, select one item in a recursive
minibuffer (a minibuffer command inside a minibuffer command), and have
that populate the original prompt.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Switch to directories (consult-dir.el)
(prot-emacs-elpa-package 'consult-dir
  (setq consult-dir-shadow-filenames nil)
  (setq consult-dir-sources '( consult-dir--source-bookmark
                               consult-dir--source-default
                               consult-dir--source-project
                               consult-dir--source-recentf))

  ;; Overrides `list-directory' in the `global-map', though I never used
  ;; that anyway.
  (dolist (map (list global-map minibuffer-local-filename-completion-map))
    (define-key map (kbd "C-x C-d") #'consult-dir)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984" class="outline-4">
<h4 id="h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984"><span class="section-number-4">3.1.6.</span> Extended minibuffer actions and more (embark.el and prot-embark.el)</h4>
<div class="outline-text-4" id="text-h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">
<p>
Video introduction: <a href="https://protesilaos.com/codelog/2021-01-09-emacs-embark-extras/">Embark and my extras</a> (2021-01-09).  Also read
<a href="https://karthinks.com/software/fifteen-ways-to-use-embark/">Fifteen ways to use Embark</a> (2021-10-06) by Karthik Chikmagalur.
</p>

<p>
[ NOTE 2021-04-02: the part in that video that deals with cycling
  through the completion candidates has been moved to the file
  <code>prot-minibuffer.el</code>, though the effect is practically the same.  UPDATE
  2021-10-22: It now is its own standalone package, called
  <code>mct.el</code>---<a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and my extras (mct.el)</a>. ]
</p>

<p>
Embark provides a unified framework of regular Emacs keymaps which let
you carry out <i>contextually relevant actions</i> on <b>targets</b> through a common
<b>point of entry</b>, typically a <i>prefix key</i>.
</p>

<ul class="org-ul">
<li>"Actions" are standard Emacs commands, such as <code>describe-symbol</code> or some
interactive command you have defined that reads an argument from the
minibuffer.</li>

<li>"Targets" are semantically sensitive constructs, such as the symbol at
point, a URL, a file name, the active region, or the current
completion candidate in the minibuffer (or the completions'
buffer&#x2014;more on that in the next section).  Embark has so-called
"clasifiers" which help it determine the category that the target
belongs to.</li>

<li>The "contextually relevant [actions]" are defined in keymaps whose
scope matches the category of the target.  So <code>embark-file-map</code> holds
all key and command associations for when Embark recognises a file
name as its target.  <code>embark-region-map</code> is for actions pertaining to
the active region; <code>embark-buffer-map</code> for buffer names that you access
through, say, <code>switch-to-buffer</code> (<code>C-x b</code>).  And so on.</li>

<li>As for the "point of entry" or "prefix key", it is an Embark command,
such as <code>embark-act</code> or <code>embark-become</code>.  Those activate the appropriate
keymap, thus granting you access to the relevant commands.</li>
</ul>

<p>
Embark can act on individual targets (e.g. the region) or sets of
targets (e.g. the list of minibuffer completion candidates).
</p>

<p>
Emacs users are already familiar with this contextuality of Embark, even
though they may not realise it.  Think, for example, that hitting the <code>j</code>
key in an <code>org-mode</code> buffer performs the action of inserting that letter
in the buffer: you type something.  While the same <code>j</code> key performs a
different action in, say, a <code>dired-mode</code> buffer.  There is no conflict
between those actions because each of them is bound to a distinct
keymap, and only one of those keymaps applies in their respective
context.
</p>

<p>
The beauty of Embark's design is that you configure its contextuality in
the exact same way you define all of your Emacs key bindings.  So you
can bind any command to whatever key you want and confine that action to
a context you specify.
</p>

<p>
On Emacs 28, learn more about the keymaps with <code>M-x describe-keymap</code> and
then search for <code>embark</code>.
</p>

<p>
Now a few things about actions that you can gain access to by invoking
either of <code>embark-act</code> (most cases), or <code>embark-become</code> (where appropriate):
</p>

<ul class="org-ul">
<li>Embark has two ways to help you learn about its actions, though you
will probably only ever need one of them.  The first one, which is the
default, is to display a detailed buffer when the variable
<code>embark-indicator</code> is set to a value of <code>embark-mixed-indicator</code> or
<code>embark-verbose-indicator</code>.  Those will produce a buffer that shows the
available actions, the keys they are bound to, and a description of
what each action does.  The other method, which is only really useful
if <code>embark-indicator</code> is set to <code>embark-minimal-indicator</code> is to follow up
the <code>embark-act</code> with <code>C-h</code>.  That will produce a minibuffer prompt
showing all available key bindings.

<ul class="org-ul">
<li>Keymaps aside, you can call <i>any command</i> after invoking <code>embark-act</code>.
This can be either with <code>M-x</code> or via its key binding.  For example, if
you want to grep for the symbol at point in the current project, you
can do <code>embark-act</code> and then <code>C-x p g</code> (<code>project-find-regexp</code>) (also read
<a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>).  This will, of course,
work as expected for commands that typically prompt you for
something to operate on.</li>

<li>Using the <code>C-h</code> as a suffix is a standard procedure in Emacs to get a
Help buffer that contains references to all commands+keys that
extend a give key chord.  So, for example, <code>C-x r C-h</code> will show you
all commands under the <code>C-x r</code> prefix (see <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).
While the generic <code>C-h</code> is fine in its own right, Embark offers an
alternative that leverages minibuffer completion: the
<code>embark-prefix-help-command</code>.  You can either select an action from
there or type <code>@</code> and the corresponding key.</li>
</ul></li>

<li>You will often be targeting individual items, such as the current
completion candidate in the minibuffer, or the symbol at point.  You
can, however, collect the entire set of targets and store it in a
buffer, which you can then re-use at your convenience or save it on
disk (with <code>write-file</code> bound to <code>C-x C-w</code> by default).  This is done by
the <code>embark-collect-snapshot</code> command, which you can always access
through <code>embark-act</code>.

<ul class="org-ul">
<li>The "Embark Collect" buffer can be presented as a grid or a list,
with the possibility to manually switch between the two by means of
the <code>embark-collect-toggle-view</code> command.  The list view offers more
room to the side of each candidate.  It can be used to display
annotations (see <a href="#h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40">Completion annotations (marginalia)</a>), such as the
first line of a variable's doc string and current value, a command's
key binding, the buffer's underlying file system path if it is
visiting a file, and so on.</li>

<li>Embark's "collect" buffer also has a live-updating version, which
can be use to filter the list of targets.  This particular feature
can, in fact, be used as a medium for visualising the list of
candidates in the active minibuffer session.  I used that setup for
several months together with the default minibuffer as part my
bespoke completion framework, though as of 2021-04-02 I handle the
live-updating completions' buffer independently of Embark
(<a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and my extras (mct.el)</a>).</li>

<li>Other than producing a snapshot, Embark can also collect the targets
and present them in a buffer whose major-mode is specialised to work
on the category those targets belong to.  This is done with the
<code>embark-export</code> command.  If you are targeting files, then the export
takes you to a <code>dired-mode</code> buffer (also refer to this document's
section on <a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">Dired (directory editor, file manager)</a>); buffers go to
<code>ibuffer-mode</code> (check <a href="#h:06290f9c-491c-45b2-b213-0248f890c83d">Ibuffer and extras</a>); grep results in a <code>grep-mode</code>
buffer, and so on.</li>
</ul></li>
</ul>

<p>
Finally, the <code>prot-embark.el</code> that is reproduced after the following block
contains a few keymaps that integrate Embark with packages like <code>consult</code>
(<a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el and prot-consult.el)</a>).  The
<code>embark-consult</code> package provides glue code that allows Embark to produce
a correct export buffer while using relevant Consult commands, such as
<code>consult-grep</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Extended minibuffer actions and more (embark.el and prot-embark.el)
(prot-emacs-elpa-package 'embark
  (setq prefix-help-command #'embark-prefix-help-command)
  ;; (setq prefix-help-command #'describe-prefix-bindings) ; the default of the above
  (setq embark-collect-initial-view-alist '((t . list)))
  (setq embark-quit-after-action t)     ; XXX: Read the doc string!
  (setq embark-cycle-key (kbd "C-."))   ; see the `embark-act' key
  (setq embark-collect-live-update-delay 0.5)
  (setq embark-collect-live-initial-delay 0.8)
  (setq embark-indicator #'embark-mixed-indicator)
  ;; NOTE 2021-07-31: The mixed indicator starts out with a minimal view
  ;; and then pops up the verbose buffer, so those variables matter.
  (setq embark-verbose-indicator-excluded-actions
        '("\\`embark-collect-" "\\`customize-" "\\(local\\|global\\)-set-key"
          set-variable embark-cycle embark-export
          embark-keymap-help embark-become embark-isearch))
  (setq embark-verbose-indicator-buffer-sections
        `(target "\n" shadowed-targets " " cycle "\n" bindings))
  (setq embark-mixed-indicator-both nil)
  (setq embark-mixed-indicator-delay 1.2)
  ;;  NOTE 2021-07-28: This is used when `embark-indicator' is set to
  ;;  `embark-mixed-indicator' or `embark-verbose-indicator'.  We can
  ;;  specify the window parameters here, but I prefer to do that in my
  ;;  `display-buffer-alist' (search this document) because it is easier
  ;;  to keep track of all my rules in one place.
  (setq embark-verbose-indicator-display-action nil)

  (define-key global-map (kbd "C-,") #'embark-act)
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-,") #'embark-act)
    (define-key map (kbd "C-&gt;") #'embark-become)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view)) ; parallel of `fill-paragraph'
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-,") #'embark-act)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view))
  (let ((map embark-region-map))
    (define-key map (kbd "a") #'align-regexp)
    (define-key map (kbd "i") #'epa-import-keys-region)
    (define-key map (kbd "r") #'repunctuate-sentences) ; overrides `rot13-region'
    (define-key map (kbd "s") #'sort-lines)
    (define-key map (kbd "u") #'untabify))
  (let ((map embark-symbol-map))
    (define-key map (kbd ".") #'embark-find-definition)
    (define-key map (kbd "k") #'describe-keymap)))

;; Needed for correct exporting while using Embark with Consult
;; commands.
(prot-emacs-elpa-package 'embark-consult)

(prot-emacs-builtin-package 'prot-embark
  (prot-embark-keymaps 1)
  (prot-embark-setup-packages 1))
</pre>
</div>

<p>
This is <code>prot-embark.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-embark.el --- Extensions to embark.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions to `embark.el' for my Emacs configuration:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; NOTE 2021-04-02: Everything pertaining to the completions' buffer has
;; been moved to `prot-minibuffer.el'.
;;
;; NOTE 2021-04-10: What once was `prot-embark-extras.el' has been
;; merged here.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'cl-lib)
(require 'embark nil t)
(require 'prot-common)

(defgroup prot-embark ()
  "Extensions for `embark'."
  :group 'editing)

;;;; Extra keymaps

(autoload 'consult-grep "consult")
(autoload 'consult-line "consult")
(autoload 'consult-imenu "consult")
(autoload 'consult-outline "consult")

(defvar prot-embark-become-general-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "f") 'consult-find)
    (define-key map (kbd "g") 'consult-grep)
    map)
  "General custom cross-package `embark-become' keymap.")

(defvar prot-embark-become-line-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "l") 'consult-line)
    (define-key map (kbd "i") 'consult-imenu)
    (define-key map (kbd "s") 'consult-outline) ; as my default is 'M-s M-s'
    map)
  "Line-specific custom cross-package `embark-become' keymap.")

(defvar embark-become-file+buffer-map)
(autoload 'prot-recentf-recent-files "prot-recentf")
(autoload 'project-switch-to-buffer "project")
(autoload 'project-find-file "project")

(defvar prot-embark-become-file+buffer-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map embark-become-file+buffer-map)
    (define-key map (kbd "r") 'prot-recentf-recent-files)
    (define-key map (kbd "B") 'project-switch-to-buffer)
    (define-key map (kbd "F") 'project-find-file)
    map)
  "File+buffer custom cross-package `embark-become' keymap.")

(defvar embark-become-keymaps)

;;;###autoload
(define-minor-mode prot-embark-keymaps
  "Add or remove keymaps from Embark.
This is based on the value of `prot-embark-add-keymaps'
and is meant to keep things clean in case I ever wish to disable
those so-called 'extras'."
  :init-value nil
  :global t
  (let ((maps (list 'prot-embark-become-general-map
                    'prot-embark-become-line-map
                    'prot-embark-become-file+buffer-map)))
    (if prot-embark-keymaps
        (dolist (map maps)
          (cl-pushnew map embark-become-keymaps))
      (setq embark-become-keymaps
            (dolist (map maps)
              (delete map embark-become-keymaps))))))

;;;; Keycast integration

;; Got this from Embark's wiki.  Renamed it to placate the compiler:
;; &lt;https://github.com/oantolin/embark/wiki/Additional-Configuration&gt;.

(defvar keycast--this-command-keys)
(defvar keycast--this-command)

(defun prot-embark--store-action-key+cmd (cmd)
  "Configure keycast variables for keys and CMD.
To be used as filter-return advice to `embark-keymap-prompter'."
  (setq keycast--this-command-keys (this-single-command-keys)
        keycast--this-command cmd))

(advice-add 'embark-keymap-prompter :filter-return #'prot-embark--store-action-key+cmd)

(defun prot-embark--force-keycast-update (&amp;rest _)
  "Update keycast's mode line.
To be passed as advice before `embark-act' and others."
  (force-mode-line-update t))

(autoload 'embark-act "embark")
(autoload 'embark-act-noexit "embark")
(autoload 'embark-become "embark")

;; NOTE: This has a generic name because my plan is to add more packages
;; to it.
;;;###autoload
(define-minor-mode prot-embark-setup-packages
  "Set up advice to integrate Embark with various commands."
  :init-value nil
  :global t
  (if (and prot-embark-setup-packages
           (require 'keycast nil t))
      (dolist (cmd '(embark-act embark-become))
        (advice-add cmd :before #'prot-embark--force-keycast-update))
    (dolist (cmd '(embark-act embark-become))
      (advice-remove cmd #'prot-embark--force-keycast-update))))

(provide 'prot-embark)
;;; prot-embark.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:7862f39e-aed0-4d02-9f1e-60c4601a9734" class="outline-4">
<h4 id="h:7862f39e-aed0-4d02-9f1e-60c4601a9734"><span class="section-number-4">3.1.7.</span> Projects (project.el and prot-project.el)</h4>
<div class="outline-text-4" id="text-h:7862f39e-aed0-4d02-9f1e-60c4601a9734">
<p>
Starting with Emacs 28, the current development target, <code>project.el</code>
contains lots of interesting additions that make it an all-round useful
tool.  Chief among them is a new prefix key bound to <code>C-x p</code>.  This has
good mnemonic value, like those for tabs (<code>C-x t</code>) and registers (<code>C-x r</code>).
</p>

<p>
A "project" is, in our case, a directory whose contents are related to
each other in terms of the end product they can provide.  Think, for
example, how Emacs' source code is a single "project" that delivers the
program we use.  In practical terms, a project is a version controlled
directory (or directory tree) governed by some program.  For my case
that is <code>git</code> though other backends are supported (by virtue of VC&#x2014;see
section on <a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a> as well as
my related extras in <a href="#h:2ff46d23-09d5-4d92-b0af-2339dc19719f">Diff-mode (and prot-diff.el extensions)</a>).
</p>

<p>
Using any of the commands listed in <code>C-x p C-h</code> will append the current
project to a list of "known projects", stored in the dynamically updated
<code>project--list</code> variable, whose contents are stored in a file defined by
<code>project-list-file</code> (remember that <code>C-h</code> can be added to any key sequence to
show its extensions and the commands associated with them&#x2014;read my
brief guide on <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).  It is then possible to switch
between your projects and proceed to immediately perform an action on
them with <code>C-x p p</code>.  A menu with possible commands will appear once you
select a project.  That is customisable via <code>project-switch-commands</code>.
</p>

<p>
Also note that <code>C-x p p</code> (<code>project-switch-project</code>) can be used to store a
new version-controlled directory in the <code>project--list</code>.  Look for the
<code>... (choose a dir)</code> option.
</p>

<p>
Now an overview of the <code>prot-project.el</code> commands, which build on top of
an otherwise comprehensive system (full code further below):
</p>

<ul class="org-ul">
<li><code>prot-project-commit-log</code> produces a list with the most recent commits
in the project.  The default count is controlled by a customisation
option: <code>prot-project-commit-log-limit</code>.  In case there is no project
being acted upon, the command first prompts for completion against the
project list.</li>

<li><code>prot-project-find-subdir</code> provides completion for subdirectories in the
current project.  It opens the match in a Dired buffer.  When no
project is present, it prompts for completion.</li>

<li><code>prot-project-magit-status</code> produces the <code>magit-status</code> buffer for the
current project or prompts for completion.</li>

<li><code>prot-project-retrieve-tag</code> lets you switch to an earlier tagged commit
or branch using completion.  As always, when no project is present, it
asks for one before doing its work.</li>
</ul>

<p>
To aid me in my work, I copied code from Manuel Uberti's website (also
referenced in the source code below this configuration block):
</p>

<ul class="org-ul">
<li><a href="https://www.manueluberti.eu/emacs/2020/11/14/extending-project/">Extending project.el</a> (2020-11-14)</li>
<li><a href="https://www.manueluberti.eu/emacs/2020/11/21/flymake-projects/">Restricting Flymake to my projects</a> (2020-11-21)</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Projects (project.el and prot-project.el)
(prot-emacs-builtin-package 'project
  ;; ;; Use this for Emacs 27 (I am on 28)
  ;; (add-to-list 'prot-emacs-ensure-install 'project)
  (setq project-switch-commands
        '((?f "File" project-find-file)
          (?s "Subdir" prot-project-find-subdir)
          (?g "Grep" project-find-regexp)
          (?d "Dired" project-dired)
          (?b "Buffer" project-switch-to-buffer)
          (?q "Query replace" project-query-replace-regexp)
          (?t "Tag switch" prot-project-retrieve-tag)
          (?m "Magit" prot-project-magit-status)
          (?v "VC dir" project-vc-dir)
          (?l "Log VC" prot-project-commit-log)
          (?e "Eshell" project-eshell)))
  (define-key global-map (kbd "C-x p q") #'project-query-replace-regexp)) ; C-x p is `project-prefix-map'

(prot-emacs-builtin-package 'prot-project
  (setq prot-project-project-roots '("~/Git/Projects/" "~/Git/build/"))
  (setq prot-project-commit-log-limit 25)
  (setq prot-project-large-file-lines 1000)
  (let ((map global-map))
    (define-key map (kbd "C-x p &lt;delete&gt;") #'prot-project-remove-project)
    (define-key map (kbd "C-x p l") #'prot-project-commit-log)
    (define-key map (kbd "C-x p m") #'prot-project-magit-status)
    (define-key map (kbd "C-x p s") #'prot-project-find-subdir)
    (define-key map (kbd "C-x p t") #'prot-project-retrieve-tag)))
</pre>
</div>

<p>
This is <code>prot-project.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-project.el --- Extensions to project.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my project.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Make sure to also inspect prot-vc.el and prot-diff.el for a more
;; complete view of what I have on the topic of version control.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'cl-lib)
(require 'project)
(require 'prot-common)
(require 'vc)

(defgroup prot-project ()
  "Extensions for project.el and related libraries."
  :group 'project)

(defcustom prot-project-project-roots (list "~/Git/Projects/")
  "List of directories with version-controlled projects.
To be used by `prot-project-switch-project'."
  :type 'list
  :group 'prot-project)

(defcustom prot-project-commit-log-limit 25
  "Limit commit logs for project to N entries by default.
A value of 0 means 'unlimited'."
  :type 'integer
  :group 'prot-project)

(defcustom prot-project-large-file-lines 1000
  "How many lines constitute a 'large file' (integer).
This determines whether some automatic checks should be executed
or not, such as `prot-project-flymake-mode-activate'."
  :type 'integer
  :group 'prot-project)

;; Copied from Manuel Uberti:
;; &lt;https://www.manueluberti.eu/emacs/2020/11/14/extending-project/&gt;.
;;
;; Note that I prefer adding some dummy doc string over seeing spurious
;; compiler warnings.
(cl-defmethod project-root ((project (head local)))
  "Project root for PROJECT with HEAD and LOCAL."
  (cdr project))

;; Copied from Manuel Uberti and tweaked accordingly:
;; &lt;https://www.manueluberti.eu/emacs/2020/11/14/extending-project/&gt;.
(defun prot-project--project-files-in-directory (dir)
  "Use `fd' to list files in DIR."
  (unless (executable-find "fd")
    (error "Cannot find 'fd' command is shell environment $PATH"))
  (let* ((default-directory dir)
         (localdir (file-local-name (expand-file-name dir)))
         (command (format "fd -t f -0 . %s" localdir)))
    (project--remote-file-names
     (split-string (shell-command-to-string command) "\0" t))))

;; Copied from Manuel Uberti:
;; &lt;https://www.manueluberti.eu/emacs/2020/11/14/extending-project/&gt;.
;;
;; Same principle for the dummy doc string.
(cl-defmethod project-files ((project (head local)) &amp;optional dirs)
  "Override `project-files' to use `fd' in local projects.

Project root for PROJECT with HEAD and LOCAL, plus optional
DIRS."
  (mapcan #'prot-project--project-files-in-directory
          (or dirs (list (project-root project)))))

(defun prot-project--list-projects ()
  "Produce list of projects in `prot-project-project-roots'."
  (let* ((dirs prot-project-project-roots)
         (dotless directory-files-no-dot-files-regexp)
         (cands (mapcan (lambda (d)
                          (directory-files d t dotless))
                        dirs)))
    (mapcar (lambda (d)
              (list (abbreviate-file-name d)))
            cands)))

;; FIXME: this is fragile since we do not store the original value of
;; `project--list' and may risk losing data.
;;;###autoload
(defun prot-project-add-projects ()
  "Append `prot-project--list-projects' to `project--list'."
  (interactive)
  (project--ensure-read-project-list)
  (let ((projects (prot-project--list-projects)))
    (setq project--list (append projects project--list))
    (project--write-project-list)))

;; TODO: use `completing-read-multiple' and learn how to delete a list
;; from an alist.
;;;###autoload
(defun prot-project-remove-project ()
  "Remove project from `project--list' using completion."
  (interactive)
  (project--ensure-read-project-list)
  (let* ((projects project--list)
         (dir (completing-read "REMOVE project from list: " projects nil t)))
    (setq project--list (delete (assoc dir projects) projects))
    (project--write-project-list)))

(defun prot-project--directory-subdirs (dir)
  "Return list of subdirectories in DIR."
  (cl-remove-if-not
   (lambda (x)
     (file-directory-p x))
   (directory-files-recursively dir ".*" t t)))

;; TODO: generalise this for all VC backends?  Which ones?
(defun prot-project--directory-subdirs-no-git (dir)
  "Remove .git dirs from DIR."
  (cl-remove-if
   (lambda (x)
     (string-match-p "\\.git" x))
   (prot-project--directory-subdirs dir)))

;; NOTE: in practice this is for `embark.el' (or equivalent
;; functionality), as it allows it to export the candidates in a Dired
;; buffer.
(defun prot-project--subdirs-completion-table (dir)
  "Return list of subdirectories in DIR with completion table."
  (prot-common-completion-table
   'file
   (prot-project--directory-subdirs-no-git dir)))

(defvar prot-project--subdir-hist '()
  "Minibuffer history for `prot-project-find-subdir'.")

;;;###autoload
(defun prot-project-find-subdir ()
  "Find subdirectories in the current project, using completion."
  (interactive)
  (let* ((pr (project-current t))
         (dir (cdr pr))
         (subdirs (prot-project--subdirs-completion-table dir))
         (directory (completing-read "Select Project subdir: " subdirs
                                     nil t nil 'prot-project--subdir-hist)))
    (dired directory)
    (add-to-history 'prot-project--subdir-hist dir)))

;; FIXME: the buttons at the bottom of the log for displaying more
;; commits do not seem to work with this.
;;;###autoload
(defun prot-project-commit-log (&amp;optional arg)
  "Print commit log for the current project.
With optional prefix ARG (\\[universal-argument]) shows expanded
commit messages and corresponding diffs.

The log is limited to the integer specified by
`prot-project-commit-log-limit'.  A value of 0 means
'unlimited'."
  (interactive "P")
  (let* ((pr (project-current t))
         (dir (cdr pr))
         (default-directory dir) ; otherwise fails at spontaneous M-x calls
         (backend (vc-responsible-backend dir))
         (num prot-project-commit-log-limit)
         (int (prot-common-number-integer-p num))
         (limit (if (= int 0) t int))
         (diffs (if arg 'with-diff nil))
         (vc-log-short-style (unless diffs '(directory))))
    (vc-print-log-internal backend (list dir) nil nil limit diffs)))

;;;###autoload
(defun prot-project-retrieve-tag ()
  "Run `vc-retrieve-tag' on project and switch to the root dir.
Basically switches to a new branch or tag."
  (interactive)
  (let* ((pr (project-current t))
         (dir (cdr pr))
         (default-directory dir) ; otherwise fails at spontaneous M-x calls
         (name
          (vc-read-revision "Tag name: "
                            (list dir)
                            (vc-responsible-backend dir))))
    (vc-retrieve-tag dir name)
    (project-dired)))

(autoload 'magit-status "magit")

;;;###autoload
(defun prot-project-magit-status ()
  "Run `magit-status' on project."
  (interactive)
  (let* ((pr (project-current t))
         (dir (cdr pr)))
    (magit-status dir)))

(defun prot-project--max-line ()
  "Return the last line's number."
  (save-excursion
    (goto-char (point-max))
    (line-number-at-pos)))

(defun prot-project--large-file-p (&amp;optional n)
  "Check if lines exceed `prot-project-large-file-lines'.
Optional N integer overrides that variable's value."
  (let* ((num (or n prot-project-large-file-lines))
         (int (prot-common-number-integer-p num)))
    (&gt; (prot-project--max-line) int)))

;; Copied from Manuel Uberti, whom I had inspired with an earlier
;; version of this, and adapted accordingly:
;; &lt;https://www.manueluberti.eu/emacs/2020/11/21/flymake-projects/&gt;.
;;;###autoload
(defun prot-project-flymake-mode-activate ()
  "Activate Flymake only for `project-known-project-roots'."
  (project--ensure-read-project-list)
  (let ((known-projects (project-known-project-roots))
        (pr (or (vc-root-dir)
                (locate-dominating-file "." ".git")
                default-directory))
        (modes (prot-common-minor-modes-active)))
    (if (and (null buffer-read-only)
             (member pr known-projects)
             (not (prot-project--large-file-p))
             (not (member 'org-src-mode modes))
             (not (null buffer-file-truename)))
        (flymake-mode 1)
      (flymake-mode -1))))

(defvar org-src-mode-hook)

(add-hook 'org-src-mode-hook #'prot-project-flymake-mode-activate)
(add-hook 'prog-mode-hook #'prot-project-flymake-mode-activate)

(provide 'prot-project)
;;; prot-project.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055" class="outline-5">
<h5 id="h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055"><span class="section-number-5">3.1.7.1.</span> Extra features for projects (project-x.el)</h5>
<div class="outline-text-5" id="text-h:4de10a0e-af55-4fdd-8000-d1e3a8ca8055">
<p>
This package by Karthik Chikmagalur provides some helpful extensions to
the <code>project.el</code> library (see <a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>).
</p>

<dl class="org-dl">
<dt>Persistent storage of window configuration</dt><dd>The window layout for
the given project can be saved and restored at will.  This is similar
to how registers can store a window layout, with the key difference
being that <code>project-x</code>'s variants persist between Emacs sessions.  So
you can start work on a project, save the window configuration and
revisit it the day after.</dd>
<dt>Arbitrary project declaration</dt><dd>By adding an empty <code>.project</code> file to
the root of a directory, we make it a valid project.  This means that
we can revisit it with the familiar <code>C-x p p</code> (<code>project-switch-project</code>)
and generally perform every project-related operation we want.  The
upside of using this method is that you can specify arbitrary file
paths that (i) do not necessary work under version and (ii) you do not
intend to treat them as your regular projects (e.g. the <code>elpa</code> directory
where Emacs installs packages by default).</dd>
</dl>

<p>
The <code>project-x-mode</code> streamlines the experience by adding a couple of key
bindings to the <code>C-x p</code> project prefix key chord.  Those bindings will be
familiar to anyone who has ever used registers: <code>C-x p w</code> will capture the
project's window configuration, while <code>C-x p j</code> will jump to an already
stored layout.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Extra features for projects (project-x.el)
;; Project repo: &lt;https://github.com/karthink/project-x&gt;.  This is one
;; of the packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'project-x
  (setq project-x-window-list-file (locate-user-emacs-file "project-x-window-list"))
  (setq project-x-local-identifier ".project")
  (project-x-mode 1))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:5723c4bb-ff6c-449f-bb60-be66fab3f137" class="outline-4">
<h4 id="h:5723c4bb-ff6c-449f-bb60-be66fab3f137"><span class="section-number-4">3.1.8.</span> Completion for recent files and directories (prot-recentf.el)</h4>
<div class="outline-text-4" id="text-h:5723c4bb-ff6c-449f-bb60-be66fab3f137">
<p>
<code>recentf</code> is a built-in minor mode that keeps track of the files you have
opened, allowing you to revisit them faster.  Its true power consists in
the fact that its data, maintained in <code>recentf-list</code>, is a simple
variable.  This means that we can access it through any relevant piece
of Elisp functionality.
</p>

<p>
To that end, the functions I define in <code>prot-recentf.el</code> are meant to
either control the contents of the list or allow me to access them
through my completion framework or a dedicated file listing (refer to
the mega-section <a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>).
</p>

<p>
Note that there exists a built-in <code>recentf-open-files</code> function for
accessing the recent files through a bespoke buffer.  I find that I have
no use for it.
</p>

<p>
Also note that the Consult package provides its own <code>recentf</code> command as
well as the <code>consult-buffer</code> which combines candidates from multiple
sources, including bookmarks, recent files, and buffers (check more in
<a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el and prot-consult.el)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Completion for recent files and directories (prot-recentf.el)
(prot-emacs-builtin-package 'recentf
  (setq recentf-save-file (locate-user-emacs-file "recentf"))
  (setq recentf-max-saved-items 200)
  (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
  (add-hook 'after-init-hook #'recentf-mode))

(prot-emacs-builtin-package 'prot-recentf
  (add-to-list 'recentf-keep 'prot-recentf-keep-predicate)
  (let ((map global-map))
    (define-key map (kbd "C-x C-r") #'prot-recentf-recent-files-or-dirs)))
</pre>
</div>

<p>
This is a copy of <code>prot-recentf.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-recentf.el --- Extensions to recentf.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions to `recentf.el' for my Emacs configuration:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'recentf)
(require 'prot-common)

;;;###autoload
(defun prot-recentf-keep-predicate (file)
  "Additional conditions for saving FILE in `recentf-list'.
Add this function to `recentf-keep'."
  (cond
   ((file-directory-p file) (file-readable-p file))))

(defvar prot-recentf--history-files '()
  "Minibuffer history for prot-recentf files.")

(defvar prot-recentf--history-dirs '()
  "Minibuffer history for prot-recentf directories.")

(defun prot-recentf--files ()
  "Return completion table with files in `recentf-list'."
  (prot-common-completion-table
   'file
   (mapcar 'abbreviate-file-name recentf-list)))

(defun prot-recentf--files-prompt (files)
  "Helper of `prot-recentf-recent-files' to read FILES."
  (let ((def (car prot-recentf--history-files)))
    (completing-read
     (format "Recentf [%s]: " def)
     files nil t nil 'prot-recentf--history-files def)))

;;;###autoload
(defun prot-recentf-recent-files (file)
  "Select FILE from `recentf-list' using completion."
  (interactive
   (list (prot-recentf--files-prompt (prot-recentf--files))))
  (find-file file)
  (add-to-history 'prot-recentf--history-files file))

(defun prot-recentf--dirs ()
  "Return completion table with directories in `recentf-list'."
  (let ((list (mapcar 'abbreviate-file-name recentf-list)))
    (prot-common-completion-table
     'file
     (delete-dups
      (mapcar (lambda (file)
                (if (file-directory-p file)
                    (directory-file-name file)
                  (substring (file-name-directory file) 0 -1)))
              list)))))

(defun prot-recentf--dirs-prompt (dirs)
  "Helper of `prot-recentf-recent-dirs' to read DIRS."
  (let ((def (car prot-recentf--history-dirs)))
    (completing-read
     (format "Recent dir [%s]: " def)
     dirs nil t nil 'prot-recentf--history-dirs def)))

;;;###autoload
(defun prot-recentf-recent-dirs (dir)
  "Select DIR from `recentf-list' using completion."
  (interactive
   (list (prot-recentf--dirs-prompt (prot-recentf--dirs))))
  (find-file dir)
  (add-to-history 'prot-recentf--history-dirs dir))

;;;###autoload
(defun prot-recentf-recent-files-or-dirs (&amp;optional arg)
  "Select recent file or, with ARG, recent directory."
  (interactive "P")
  (if arg
      (call-interactively 'prot-recentf-recent-dirs)
    (call-interactively 'prot-recentf-recent-files)))

(provide 'prot-recentf)
;;; prot-recentf.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:98876022-57cc-40de-936e-4ee42cefd69a" class="outline-4">
<h4 id="h:98876022-57cc-40de-936e-4ee42cefd69a"><span class="section-number-4">3.1.9.</span> In-buffer completions</h4>
<div class="outline-text-4" id="text-h:98876022-57cc-40de-936e-4ee42cefd69a">
</div>
<div id="outline-container-h:675ebef4-d74d-41af-808d-f9579c2a5ec4" class="outline-5">
<h5 id="h:675ebef4-d74d-41af-808d-f9579c2a5ec4"><span class="section-number-5">3.1.9.1.</span> Corfu (Completion Overlay Region FUnction) and CAPE</h5>
<div class="outline-text-5" id="text-h:675ebef4-d74d-41af-808d-f9579c2a5ec4">
<p>
NOTE 2021-12-29: There are experiments to make MCT to the job that
Corfu does.  As such, I am disabling this for the time being, though I
strongly encourage you to stick with Corfu.
</p>

<p>
<code>corfu</code> is another nimble package by Daniel Mendler (author of Consult and
several others&#x2014;search this document for a few of them), which focuses
on text expansion within the buffer.  Its User Interface involves a
pop-up that shows the completion candidates for the text before point.
This pop-up, technically a child frame, is invoked manually with the <code>TAB</code>
key.  While I would have preferred to use the minibuffer even for
in-buffer text expansion, for the sake of consistency and
predictability, I consider the added functionality more important than
my mild preference against pop-ups (though the fact that Corfu is
invoked manually makes this largely irrelevant).
</p>

<p>
As is the norm with Daniel's contributions, <code>corfu</code> is a sharp and focused
tool that works with the standard completion mechanisms, as it reads
from the <code>completion-styles</code> as well as the <code>completion-category-overrides</code>
(refer to <a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and my extras (mct.el)</a>, though note
that if you are a fan of Daniel's work, you will probably want to check
the <a href="https://github.com/minad/vertico">Vertico package</a> instead of my hacks for the default minibuffer
experience).
</p>

<p>
Unlike its more established counterpart, <code>company-mode</code>, Corfu does not
implement its own backends for various programming languages.  Instead,
it plugs in to the standard <code>completion-at-point-functions</code> (CAPF).
Perhaps that could be seen as a downside for users who program in a lot
of languages and/or who require some of Company's bespoke functionality.
For me though, the CAPF facility is good enough because it works with
the only programming language I have been coding in for the last several
months: Emacs Lisp.  CAPF also is future-proof in that any package that
provides its own completion table, automatically works with Corfu, such
as my contacts manager (<a href="#h:d386e14b-dcf7-46a2-851f-867cd84c6cae">EBDB (mail contacts)</a>).  And I would assume that
it also works for any major mode that is in sync with the current best
practices in Emacs' design.  Besides, this approach makes the code
easier for me to understand and configure.
</p>

<p>
Once the Corfu overlay appears, use <code>C-n</code> and <code>C-p</code> to cycle through the
candidates.  Other motions work as well, such as <code>C-v</code>, <code>M-v</code>, <code>M-&lt;</code>, <code>M-&gt;</code>,
though regular incremental motions is what you would normally want.  <code>RET</code>
selects the current item and exits, while <code>TAB</code> tries to complete as much
as possible, only exiting if the match is unique.  Additionally, you can
use <code>M-h</code> (<code>corfu-show-documentation</code>) and <code>M-g</code> (<code>corfu-show-documentation</code>)
over the selected candidate to either display its doc string or its
source code, respectively.
</p>

<p>
Note that for <code>TAB</code> to perform completion in addition to its primary
function of adjusting indentation, we need <code>tab-always-indent</code> to be set
to a <code>complete</code> value (check <a href="#h:d51d37df-4e58-4e0b-85a1-019ceda342f6">Tabs, indentation, and the TAB key</a> and/or
read that variable's doc string).
</p>

<p>
Finally, the <code>cape</code> package, also by Daniel, adds some more backends for
the aforementioned CAPF facility.  They make Corfu work in more
contexts.  Basically, this is the sort of thing that you set up and it
"just works".
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Corfu (Completion Overlay Region FUnction)
;; (prot-emacs-elpa-package 'corfu
;;   ;; (dolist (mode '( message-mode-hook text-mode-hook prog-mode-hook
;;   ;;                  shell-mode-hook eshell-mode-hook))
;;   ;;   (add-hook mode #'corfu-mode))
;;   (corfu-global-mode 1)
;;   (define-key corfu-map (kbd "&lt;tab&gt;") #'corfu-complete))
;;
;; (prot-emacs-elpa-package 'cape
;;   (setq cape-dabbrev-min-length 2)
;;   (dolist (backend '( cape-keyword-capf cape-file-capf cape-dabbrev-capf))
;;     (add-to-list 'completion-at-point-functions backend)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84" class="outline-5">
<h5 id="h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84"><span class="section-number-5">3.1.9.2.</span> Dabbrev (dynamic word completion)</h5>
<div class="outline-text-5" id="text-h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84">
<p>
This is Emacs' own approach to dynamic/arbitrary text completion inside
the buffer: "dynamic abbreviation" or else <code>dabbrev</code>.  This mechanism
works by reading all text before point to find a suitable match.
Different scenaria determine whether it should also look forward and in
other buffers.  In essence, Dabbrev helps you re-type what you already
have.
</p>

<p>
With <code>dabbrev-expand</code> we make an attempt to complete the text at point.
Repeated invocations will cycle through the candidates.  No feedback is
provided, much in the same way yanking from the kill-ring works (though
for Emacs28 <code>yank-pop</code> on <code>M-y</code> will use completion if the previous command
was not <code>yank</code> on <code>C-y</code>).  To complete a phrase, matching the last succesful
<code>dabbrev-expand</code>, you need to supply an empty space and call the command
again.  This will match the next word, and so on for N words.
</p>

<p>
Whereas <code>dabbrev-completion</code> benefits from minibuffer interactivity and
the pattern matching styles in effect (<a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>).
With the help of Corfu, the completion candidates are displayed in a
pop-up window near point (<a href="#h:675ebef4-d74d-41af-808d-f9579c2a5ec4">Corfu for in-buffer completion</a>).
</p>

<p>
The <code>dabbrev-abbrev-char-regexp</code> is configured to match both regular words
and symbols (e.g. words separated by hyphens).  This makes it equally
suitable for code and ordinary language.
</p>

<p>
While the <code>dabbrev-abbrev-skip-leading-regexp</code> is instructed to also
expand words and symbols that start with any of these: <code>$</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>~</code>, <code>'</code>.
This regexp may be expanded in the future, but the idea is to be able to
perform completion in contexts where the known word/symbol is preceded
by a special character.  For example, in the <code>org-mode</code> version of this
document, all inline code must be placed between the equals sign.  So
now typing the <code>=</code>, then a letter, will still allow me to expand text
based on that input.
</p>

<p>
To check what I have on regular expressions, see further below my
configurations and documentation for <a href="#h:6c6759c8-3ae3-40b0-8356-05cc0975e12a">re-builder (regexp-builder)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Dabbrev (dynamic word completion)
(prot-emacs-builtin-package 'dabbrev
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (let ((map global-map))
    (define-key map (kbd "M-/") #'dabbrev-expand)
    (define-key map (kbd "C-x M-/") #'dabbrev-completion)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:33cd69cc-1a50-4abb-9f09-cae98dc8998b" class="outline-5">
<h5 id="h:33cd69cc-1a50-4abb-9f09-cae98dc8998b"><span class="section-number-5">3.1.9.3.</span> Abbreviations or Abbrevs</h5>
<div class="outline-text-5" id="text-h:33cd69cc-1a50-4abb-9f09-cae98dc8998b">
<p>
The <code>abbrev</code> library provides an easy way to automatically correct some of
your most common typos or write an abbreviation that expands into
another string of characters when <code>abbrev-mode</code> is enabled in the relevant
mode.  For example, I have set it up to convert <code>latex</code> into <code>LaTeX</code> when I
am using <code>text-mode</code> or derivates, such as <code>org-mode</code>.  This expansion is
case-insensitive, so <code>Latex</code> will still become <code>LaTeX</code>.
</p>

<p>
The expansion is triggered by a non-text character such as a space or
newline, or the command <code>expand-abbrev</code> (<code>C-x a e</code>) after the target text
has been filled in and point is at the end of it.
</p>

<p>
Abbreviations are stored in tables.  In general, we want to have our
most common entries in the <code>global-abbrev-table</code>.  Then we can refine our
substitutes based on the major mode we are in.  Each major modes comes
with its own abbrev table, so we can have something like
<code>message-mode-abbrev-table</code> which only works in <code>message-mode</code>.
</p>

<p>
The Emacs manual also covers the concept of "skeletons", which are
templates that can be parameterised with Elisp and then expanded as
abbrevs.  I have no real use for them right now.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Abbreviations or Abbrevs
(prot-emacs-builtin-package 'abbrev
  (setq abbrev-file-name (locate-user-emacs-file "abbrevs"))
  (setq only-global-abbrevs nil)

  (let ((table global-abbrev-table))
    (define-abbrev table "meweb" "https://protesilaos.com")
    (define-abbrev table "megit" "https://gitlab.com/protesilaos"))

  (let ((table text-mode-abbrev-table))
    (define-abbrev table "latex" "LaTeX")
    (define-abbrev table "github" "GitHub")
    (define-abbrev table "gitlab" "GitLab")
    (define-abbrev table "sourcehut" "SourceHut")
    (define-abbrev table "auctex" "AUCTeX")
    (define-abbrev table "Emacs27" "Emacs 27")
    (define-abbrev table "Emacs28" "Emacs 28")
    (define-abbrev table "Emacs29" "Emacs 29")
    (define-abbrev table "asciidoc" "AsciiDoc"))

  (with-eval-after-load 'message
    (let ((table message-mode-abbrev-table)
          (name "Protesilaos (or simply \"Prot\")"))
      (define-abbrev table "bestregards" (format "Best regards,\n%s" name))
      (define-abbrev table "allthebest" (format "All the best,\n%s" name))
      (define-abbrev table "abest" "All the best,\nProt")
      (define-abbrev table "bregards" "Best regards,\nProt")))

  (let ((map global-map))
    (define-key map (kbd "C-x a e") #'expand-abbrev) ; default, just here for visibility
    (define-key map (kbd "C-x a u") #'unexpand-abbrev))

  ;; message-mode derives from text-mode, so we don't need a separate
  ;; hook for it.
  (dolist (hook '(text-mode-hook git-commit-mode-hook))
    (add-hook hook #'abbrev-mode)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h:67dac9fe-5c15-437d-bb3e-26b293affa45" class="outline-3">
<h3 id="h:67dac9fe-5c15-437d-bb3e-26b293affa45"><span class="section-number-3">3.2.</span> Configurations for&#x2014;or extensions to&#x2014;built-in search commands</h3>
<div class="outline-text-3" id="text-h:67dac9fe-5c15-437d-bb3e-26b293affa45">
<p>
These are meant to enhance the functionality of tools that are already
shipped with Emacs.
</p>
</div>

<div id="outline-container-h:b67687ee-25a3-4bf4-a924-180ccb63c629" class="outline-4">
<h4 id="h:b67687ee-25a3-4bf4-a924-180ccb63c629"><span class="section-number-4">3.2.1.</span> Isearch, occur, grep, and extras (prot-search.el)</h4>
<div class="outline-text-4" id="text-h:b67687ee-25a3-4bf4-a924-180ccb63c629">
<p>
The built-in search mechanisms, defined in the libraries <code>isearch.el</code> and
<code>replace.el</code> are minimal in their presentation, yet powerful in their
applications.  There are the main points of entry to the commands they
offer:
</p>

<ul class="org-ul">
<li><code>isearch-forward</code> (<code>C-s</code>) prompts for a string after point and offers live
feedback on its progress.  <code>isearch-backward</code> (<code>C-r</code>) moves in the
opposite direction.

<ul class="org-ul">
<li>Two distinct keys may seem redundant at first, but you really
appreciate this level of precision when recording keyboard macros
(see, for example, my video about <a href="https://protesilaos.com/codelog/2020-01-21-emacs-isearch-kmacro/">Isearch powers in keyboard macros</a>
(2020-01-21)).</li>

<li>Use <code>C-M-s</code> and <code>C-M-r</code> for running a search against a regular
expression, or call <code>isearch-toggle-regexp</code> (<code>M-r</code>) after starting a
regular isearch.</li>
</ul></li>

<li><code>query-replace</code> (<code>M-%</code>) replaces all matches of a string and asks you for
confirmation on each of them.  If you check its help page (press <code>?</code>
after invoking the command), you will learn that <code>!</code> stands for an
affirmative answer to all, which is a standard in all such prompts.

<ul class="org-ul">
<li><code>query-replace-regexp</code> (<code>C-M-%</code>) does the same for regular expressions.</li>
</ul></li>

<li><code>occur</code> (<code>M-s o</code>) places all matches of a regular expression or string in
a dedicated buffer.  That can function as an index for moving to the
relevant points in the buffer, but also as a means of refactoring all
matches at once.  Just make the <code>*Occur*</code> buffer editable with <code>e</code>.
Running <code>occur</code> with a numeric argument provides N lines of context
around the given match.</li>
</ul>

<p>
The beauty of the Occur and Replace commands is that they can be
initiated from within an active Isearch session, using the same keys.
So <code>C-s INPUT M-s o</code> will search for input and then run <code>occur</code> on it.  Try
<code>C-h k C-s</code> to get a help menu with all the extra keys you can use with
<code>isearch</code>.  These are the ones I use the most:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Key chord</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">C-s C-w</td>
<td class="org-left">Search char or word at point</td>
</tr>

<tr>
<td class="org-left">M-s .</td>
<td class="org-left">Search for symbol at point</td>
</tr>

<tr>
<td class="org-left">M-s M-.</td>
<td class="org-left">Search for thing at point (Emacs28)</td>
</tr>

<tr>
<td class="org-left">M-s o</td>
<td class="org-left">Run `occur' on regexp</td>
</tr>

<tr>
<td class="org-left">M-s h r</td>
<td class="org-left">Highlight regexp</td>
</tr>

<tr>
<td class="org-left">M-s h u</td>
<td class="org-left">Undo the highlight</td>
</tr>

<tr>
<td class="org-left">C-s M-r</td>
<td class="org-left">Toggle regexp search</td>
</tr>

<tr>
<td class="org-left">M-%</td>
<td class="org-left">Run `query-replace'</td>
</tr>

<tr>
<td class="org-left">C-M-%</td>
<td class="org-left">`query-replace-regexp'</td>
</tr>
</tbody>
</table>

<p>
Every one of the above, except the first item, can be executed on their
own, or as extensions of <code>C-s</code> (and variants).  In the latter case, when
you run a regexp-aware Isearch (<code>C-M-s</code> or <code>C-M-r</code>) a <code>M-%</code> will automatically
be interpreted as <code>C-M-%</code>.
</p>

<p>
The Occur and Replace operations are aware of the active region, so if
you highlight, say, a paragraph and do <code>M-%</code> you will only replace matches
inside of that area (while not relevant to our point, this also works
for <code>undo</code> (<code>C-/</code>), which is super useful).  Though one can achieve pretty
much the same result by leveraging Emacs' narrowing commands, like
<code>narrow-to-defun</code> (learn about all of them with <code>C-x n C-h</code>)
</p>

<p>
Now here is a neat trick I discovered a while ago that makes Isearch
even better for most tasks: the ability to interpret a space as a
wildcard.  This is due to the combined effect of the values assigned to
the variables <code>search-whitespace-regexp</code>, <code>isearch-lax-whitespace</code>,
<code>isearch-regexp-lax-whitespace</code>.  So you can now search for something like
<code>se di bu al</code> and it will return <code>setq display-buffer-alist</code>.  And you can
still combine it with all of the aforementioned!  Note that <b>this affects
regular searches</b> (the standard <code>C-s</code> and <code>C-r</code>).  The regexp-sensitive
functions <code>C-M-s</code> and <code>C-M-r</code> remain in tact.  You can always toggle
whitespace matching behaviour while performing a search, with <code>M-s SPC</code>
(revert back to just literal spaces).
</p>

<p>
Now on to my <code>prot-search.el</code> library which provides some extensions to
an already well-designed architecture (the code is reproduced after the
package configurations).
</p>

<ul class="org-ul">
<li><code>prot-search-isearch-other-end</code> simply places point at the opposite end
of the current match.  Particularly helpful while recording keyboard
macros.  This is to work around the default behaviour of Isearch which
puts the point at either the beginning or the end of the match,
depending on the direction it is moving in.  For single words or
balanced expressions this is not an issue because you can always
confirm+exit a search by using a motion key (so, for example, move to
the end of the matching word with <code>M-f</code>).  There are, however, matches
that are not limited to such boundaries, especially with the wildcard
hack mentioned above.  For those cases moving to the opposite end
might require multiple key presses, which is bad when trying to record
an efficient keyboard macro.  Note though that you can achieve the
same result by changing the direction the search is moving towards
with <code>C-s</code> or <code>C-r</code> (though I still prefer my minor addition).</li>

<li><code>prot-search-isearch-abort-dwim</code> deletes the entirety of the
non-matching input while leaving the valid parts in place.  Otherwise
it behaves like a standard backward character deletion. The built-in
method to remove the entirety of a mismatched input is to hit <code>C-g</code>
following a failed search.  However, I find that the choice of key
binding can prove problematic, since <code>C-g</code> also exits a successful
search, while I also prefer a "do-what-I-mean" behaviour.</li>

<li><code>prot-search-isearch-replace-symbol</code> runs a forward-looking
<code>query-replace</code> for the symbol at point.  Simple and effective for
quickly refactoring a given function/variable name (and one of the
reasons why I have never needed an extra package for such tasks).</li>

<li><code>prot-search-isearch-beginning-of-buffer</code> and its counterpart
<code>prot-search-isearch-end-of-buffer</code> move to the first or last instance
of the symbol at point.  They also accept a numeric argument, which
they interpret as an offset.  In practice, this is the same as running
<code>M-s . M-s &lt;</code> or <code>M-s . M-s &gt;</code>.</li>

<li><code>prot-search-occur-urls</code> gathers all URLs in the current buffer and
places them in an Occur buffer <i>without their context</i> while also making
them clickable (we say that it "buttonises" them).</li>

<li><code>prot-search-occur-outline</code> produces an outline of the buffer based on a
configurable association of major mode and regular expression.  Check
the variable <code>prot-search-outline-regexp-alist</code>.  The command can prompt
for a regexp style to use, defaulting to the current major mode if an
outline regexp exists for it.  An arbitrary regexp can also be
inserted either through interactive use or from Lisp code.</li>

<li><code>prot-search-occur-browse-url</code> gathers all URLs in the buffer and
prompts you to select one with completion.  It then browses that item
using whatever browser you have for <code>browse-url-browser-function</code>.</li>

<li><code>prot-search-grep</code> runs a local grep in the current directory.  With a
prefix argument, it runs recursively instead.  This is a thin wrapper
around the built-in <code>lgrep</code> and <code>rgrep</code> commands: it makes the process
faster by not asking for a directory and file extension pattern.  All
output is placed in a separate buffer.  Note that I also have a
variant for git-controlled projects: it is <code>prot-vc-git-grep</code> from
<a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a>.  Also note that
Consult provides a live version: refer to the <a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">section on consult.el</a>.
(I normally use Consult and export the results with Embark, except for
when I know exactly what I am looking for and want it in a buffer, so
the added features are not needed).</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Isearch, occur, grep, and extras (prot-search.el)
(prot-emacs-builtin-package 'isearch
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  ;; These variables are from Emacs 28
  (setq isearch-repeat-on-direction-change t)
  (setq lazy-highlight-initial-delay 0.5)
  (setq lazy-highlight-no-delay-length 3)
  (setq isearch-wrap-pause t)

  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "M-/") #'isearch-complete)))

(prot-emacs-builtin-package 'replace
  (setq list-matching-lines-jump-to-current-line t)
  (add-hook 'occur-mode-hook #'hl-line-mode)
  (add-hook 'occur-mode-hook #'prot-common-truncate-lines-silently) ; from `prot-common.el'
  (define-key occur-mode-map (kbd "t") #'toggle-truncate-lines))

(prot-emacs-builtin-package 'grep)

(prot-emacs-builtin-package 'prot-search
  (setq prot-search-outline-regexp-alist
        '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
          (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)")))

  (let ((map global-map))
    (define-key map (kbd "M-s %") #'prot-search-isearch-replace-symbol)
    (define-key map (kbd "M-s M-&lt;") #'prot-search-isearch-beginning-of-buffer)
    (define-key map (kbd "M-s M-&gt;") #'prot-search-isearch-end-of-buffer)
    (define-key map (kbd "M-s g") #'prot-search-grep)
    (define-key map (kbd "M-s u") #'prot-search-occur-urls)
    (define-key map (kbd "M-s M-o") #'prot-search-occur-outline)
    (define-key map (kbd "M-s M-u") #'prot-search-occur-browse-url))
  (let ((map isearch-mode-map))
    (define-key map (kbd "&lt;up&gt;") #'prot-search-isearch-repeat-backward)
    (define-key map (kbd "&lt;down&gt;") #'prot-search-isearch-repeat-forward)
    (define-key map (kbd "&lt;backspace&gt;") #'prot-search-isearch-abort-dwim)
    (define-key map (kbd "&lt;C-return&gt;") #'prot-search-isearch-other-end)))
</pre>
</div>

<p>
Here is <code>prot-search.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-search.el --- Extensions to isearch, replace, grep for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my isearch.el, replace.el, and grep.el extensions, for
;; use in my Emacs setup: &lt;https://protesilaos.com/emacs/dotemacs&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'isearch)
(require 'replace)
(require 'grep)
(require 'prot-common)

(defgroup prot-search ()
  "Setup for Isearch, Occur, and related."
  :group 'search)

;; NOTE 2021-09-16: Based on my git config for headings in diffs.  Read:
;; &lt;https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/&gt;.
(defcustom prot-search-outline-regexp-alist
  '((emacs-lisp-mode . "^\\((\\|;;;+ \\)")
    (org-mode . "^\\(\\*+ +\\|#\\+[Tt][Ii][Tt][Ll][Ee]:\\)"))
  "Alist of regular expressions per major mode.

For best results the key must be a symbol that corresponds to a
major mode.

To be used by `prot-search-occur-outline'."
  :type 'alist
  :group 'prot-search)

;;;; Isearch

;;;###autoload
(defun prot-search-isearch-other-end ()
  "End current search in the opposite side of the match.
Particularly useful when the match does not fall within the
confines of word boundaries (e.g. multiple words)."
  (interactive)
  (isearch-done)
  (when isearch-other-end
    (goto-char isearch-other-end)))

;;;###autoload
(defun prot-search-isearch-abort-dwim ()
  "Delete failed `isearch' input, single char, or cancel search.

This is a modified variant of `isearch-abort' that allows us to
perform the following, based on the specifics of the case: (i)
delete the entirety of a non-matching part, when present; (ii)
delete a single character, when possible; (iii) exit current
search if no character is present and go back to point where the
search started."
  (interactive)
  (if (eq (length isearch-string) 0)
      (isearch-cancel)
    (isearch-del-char)
    (while (or (not isearch-success) isearch-error)
      (isearch-pop-state)))
  (isearch-update))

;;;###autoload
(defun prot-search-isearch-repeat-forward (&amp;optional arg)
  "Move forward, keeping point at the beginning of the match.
Optionally move to ARGth match in the given direction."
  (interactive "p")
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end))
  (isearch-repeat-forward (or arg 1)))

;;;###autoload
(defun prot-search-isearch-repeat-backward (&amp;optional arg)
  "Move backward, keeping point at the beginning of the match.
Optionally move to ARGth match in the given direction."
  (interactive "p")
  (when (and (not isearch-forward) isearch-other-end)
    (goto-char isearch-other-end))
  (isearch-repeat-backward (or arg 1)))

(defmacro prot-search-isearch-occurrence (name edge &amp;optional doc)
  "Construct function for moving to `isearch' occurrence.
NAME is the name of the function.  EDGE is either the beginning
or the end of the buffer.  Optional DOC is the resulting
function's docstring."
  `(defun ,name (&amp;optional arg)
     ,doc
     (interactive "p")
     (let ((x (or arg 1))
           (command (intern (format "isearch-%s-of-buffer" ,edge))))
       (isearch-forward-symbol-at-point)
       (funcall command x))))

(prot-search-isearch-occurrence
 prot-search-isearch-beginning-of-buffer
 "beginning"
 "Run `isearch-beginning-of-buffer' for the symbol at point.
With numeric ARG, move to ARGth occurrence counting from the
beginning of the buffer.")

(prot-search-isearch-occurrence
 prot-search-isearch-end-of-buffer
 "end"
 "Run `isearch-end-of-buffer' for the symbol at point.
With numeric ARG, move to ARGth occurrence counting from the
end of the buffer.")

;;;; Replace/Occur

;; TODO: make this work backwardly when given a negative argument
(defun prot-search-isearch-replace-symbol ()
  "Run `query-replace-regexp' for the symbol at point."
  (interactive)
  (isearch-forward-symbol-at-point)
  (isearch-query-replace-regexp))

(autoload 'goto-address-mode "goto-addr")

;;;###autoload
(defun prot-search-occur-urls ()
  "Produce buttonised list of all URLs in the current buffer."
  (interactive)
  (let ((buf-name (format "*links in &lt;%s&gt;*" (buffer-name))))
    (add-hook 'occur-hook #'goto-address-mode)
    (occur-1 prot-common-url-regexp "\\&amp;" (list (current-buffer)) buf-name)
    (remove-hook 'occur-hook #'goto-address-mode)))

;;;###autoload
(defun prot-search-occur-browse-url ()
  "Point browser at a URL in the buffer using completion.
Which web browser to use depends on the value of the variable
`browse-url-browser-function'.

Also see `prot-search-occur-urls'."
  (interactive)
  (let ((matches nil))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp prot-common-url-regexp nil t)
        (push (match-string-no-properties 0) matches)))
    (funcall browse-url-browser-function
             (completing-read "Browse URL: " matches nil t))))

(defvar prot-search--occur-outline-hist '()
  "Minibuffer history of `prot-search-occur-outline'.")

(defun prot-search--occur-outline-prompt ()
  "Helper prompt for `prot-search-occur-outline'."
  (let* ((alist prot-search-outline-regexp-alist)
         (key (car (assoc major-mode alist)))
         (default (or key (nth 1 prot-search--occur-outline-hist))))
    (completing-read
     (format "Outline style [%s]: " default)
     (mapcar #'car alist)
     nil nil nil 'prot-search--occur-outline-hist default)))

;;;###autoload
(defun prot-search-occur-outline (&amp;optional arg)
  "Produce buffer outline from `prot-search-outline-regexp-alist'.

With optional prefix ARG (\\[universal-argument]), prompt for a
preset among the entries in `prot-search-outline-regexp-alist'.

ARG may also be a string (or regular expression) when called from
Lisp."
  (interactive "P")
  (let* ((regexp (when (and arg (not (stringp arg)))
                   (prot-search--occur-outline-prompt)))
         (rx (cond
              ((stringp arg)
               arg)
              ((and arg (string= major-mode regexp))
               (cdr (assoc regexp prot-search-outline-regexp-alist)))
              ((assoc major-mode prot-search-outline-regexp-alist)
               (cdr (assoc major-mode prot-search-outline-regexp-alist)))
              (t (user-error "Unknown outline style"))))
         (buf-name (format "*outline of &lt;%s&gt;*" (buffer-name))))
    (occur-1 rx nil (list (current-buffer)) buf-name)
    (add-to-history 'prot-search--occur-outline-hist regexp)))

;;;; Grep

(defvar prot-search--grep-hist '()
  "Input history of grep searches.")

;;;###autoload
(defun prot-search-grep (regexp &amp;optional recursive)
  "Run grep for REGEXP.

Search in the current directory using `lgrep'.  With optional
prefix argument (\\[universal-argument]) for RECURSIVE, run a
search starting from the current directory with `rgrep'."
  (interactive
   (list
    (read-from-minibuffer (concat (if current-prefix-arg
                                      (propertize "Recursive" 'face 'warning)
                                    "Local")
                                  " grep for PATTERN: ")
                          nil nil nil 'prot-search--grep-hist)
    current-prefix-arg))
  (unless grep-command
    (grep-compute-defaults))
  (if recursive
      (rgrep regexp "*" default-directory)
    (lgrep regexp "*" default-directory)
    (add-to-history 'prot-search--grep-hist regexp)))

(provide 'prot-search)
;;; prot-search.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:6c6759c8-3ae3-40b0-8356-05cc0975e12a" class="outline-4">
<h4 id="h:6c6759c8-3ae3-40b0-8356-05cc0975e12a"><span class="section-number-4">3.2.2.</span> Test regular expressions (re-builder)</h4>
<div class="outline-text-4" id="text-h:6c6759c8-3ae3-40b0-8356-05cc0975e12a">
<p>
Emacs offers a built-in tool for testing regular expressions: invoke it
with the <code>regexp-builder</code> or <code>re-builder</code> command.  It pops up a buffer at
the bottom of the current window, which lets you test a regular
expression on the contents of the buffer from where the command was
called.  By default, <code>re-builder</code> uses Emacs-style notation, where escape
sequences are written as a double backslash.  You can switch between the
various styles by using <code>C-c TAB</code> inside of the regexp builder's buffer.
I choose to keep this style as the default as it is what I also use when
writing a pattern in some Elisp file.
</p>

<p>
To learn more about regular expressions, read the relevant pages in the
official manual by evaluating this: <code>(info "(emacs) Regexps")</code>.  Also
consider watching my ~35 minute-long video <a href="https://protesilaos.com/codelog/2020-01-23-emacs-regexp-primer/">primer on Emacs regexp</a>
(2020-01-23).  If you actually need to do a regexp-aware query and
replace operation that performs an arbitrary elisp function on a group
check my article on how to use <a href="https://protesilaos.com/codelog/2021-03-03-emacs-query-replace-downcase/">query-replace-regexp to downcase matches</a>
(2021-03-03).  Remember that you can always get interactivity by first
using something like <code>isearch-forward-regexp</code> and then switching to the
<code>query-replace</code> operation with <code>M-%</code> (in this case, <code>query-replace</code>
automatically becomes regexp-aware).
</p>

<p>
Also check: <a href="#h:b67687ee-25a3-4bf4-a924-180ccb63c629">Isearch, occur, grep, and extras (prot-search.el)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Test regular expressions (re-builder)
(prot-emacs-builtin-package 're-builder
  (setq reb-re-syntax 'read))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:42624165-f4cb-4318-abce-c11232426880" class="outline-4">
<h4 id="h:42624165-f4cb-4318-abce-c11232426880"><span class="section-number-4">3.2.3.</span> wgrep (writable grep)</h4>
<div class="outline-text-4" id="text-h:42624165-f4cb-4318-abce-c11232426880">
<p>
With <code>wgrep</code> we can directly edit the results of a <code>grep</code> and save the
changes to all affected buffers.  In principle, this is the same as what
the built-in <code>occur</code> offers.  We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, query and replace a regexp&#x2026;).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; wgrep (writable grep)
(prot-emacs-elpa-package 'wgrep
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  (let ((map grep-mode-map))
    (define-key map (kbd "e") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-x C-q") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-c C-c") #'wgrep-finish-edit)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:594bca38-542c-4aac-95f5-349f034c6802" class="outline-4">
<h4 id="h:594bca38-542c-4aac-95f5-349f034c6802"><span class="section-number-4">3.2.4.</span> Cross-references (xref.el)</h4>
<div class="outline-text-4" id="text-h:594bca38-542c-4aac-95f5-349f034c6802">
<p>
Xref provides helpful commands for code navigation and discovery, such
as <code>xref-find-definitions</code> (<code>M-.</code>) and its counterpart <code>xref-pop-marker-stack</code>
(<code>M-,</code>).  It is a library that gets used by a variety of tools, including
<code>project.el</code> (see <a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>).
</p>

<p>
Here are just the basics.  I might add more in the future.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Cross-references (xref.el)
(prot-emacs-builtin-package 'xref
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'grep))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h:402cb0db-1e93-4b1f-8f6d-e17b4409fb86" class="outline-2">
<h2 id="h:402cb0db-1e93-4b1f-8f6d-e17b4409fb86"><span class="section-number-2">4.</span> Directory, buffer, window management</h2>
<div class="outline-text-2" id="text-h:402cb0db-1e93-4b1f-8f6d-e17b4409fb86">
</div>
<div id="outline-container-h:c519300f-8a9a-472b-b26d-c2f49adbdb5d" class="outline-3">
<h3 id="h:c519300f-8a9a-472b-b26d-c2f49adbdb5d"><span class="section-number-3">4.1.</span> Dired file manager (and prot-dired.el extras)</h3>
<div class="outline-text-3" id="text-h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">
<p>
The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer.  It is simply superb!  I use it
daily for a number of tasks.
</p>

<p>
You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, start an email with the current or marked files attached to the
message, and more.  Combine that with the possibility of matching items
with regular expressions, such as for marking files or narrowing the
list, or creating an editable Dired buffer to bulk rename entries, and
you have everything you need to maximise your productivity.
</p>

<p>
Watch some of my older videos:
</p>

<ul class="org-ul">
<li><a href="https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/">Dired tweaks and refinements</a> (2019-08-12).</li>
<li><a href="https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/">Use Dired and keyboard macros</a> (2019-09-03).</li>
<li><a href="https://protesilaos.com/codelog/2019-09-19-dired-narrow/">Techniques to narrow Dired</a> (2019-09-19).</li>
<li><a href="https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/">Change multi-file permissions with Dired</a> (2019-11-16).</li>
<li><a href="https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/">Music management with Dired and Bongo</a> (2019-11-13).</li>
<li><a href="https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/">Dired+Bongo and macros to handle music playlists</a> (2019-11-18).</li>
<li><a href="https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/">Search and replace across multiple files (not Dired-specific)</a> (2019-12-08).</li>
</ul>

<p>
The following package configurations are fairly comprehensive.  First an
overview of the options I specify for Dired proper:
</p>

<ul class="org-ul">
<li>Copy and delete recursively.  No need to be prompted about each
action.</li>

<li>While in detailed view, search only file names when point is on one of
them, else apply the query to the rest of the data.</li>

<li>Deletion sends items to the system's Trash, making it safer than the
standard <code>rm</code>.  The trash can be a life-saver, as it lets you restore
deleted files (check: <a href="#h:954adfb4-8f2c-4665-bb5b-e098926341b0">dired-like mode for the trash (trashed.el)</a>).</li>

<li>Reformat output.  Sort directories first.  Show dotfiles and place
them before anything else.  Omit implicit directories (the single and
double dots).  Use human-readable size units.  To learn everything
about these switches, you need to read the manpage of <code>ls</code>.  You can do
so with <code>M-x man RET ls</code> or <code>M-x woman</code>.

<ul class="org-ul">
<li>Note that <code>dired-listing-switches</code> and <code>find-ls-option</code> are configured
to show hidden directories and files <i>before</i> their non-hidden
counterparts.  If you want to reverse this order, you must include
the <code>-X</code> option (such as <code>-AFXhlv --group-directories-first</code>).</li>
</ul></li>

<li>Hide all the details by default (permissions, size, etc.).  Those can
easily be toggled on with the left parenthesis.  Also enable
highlighting of the current line (<code>hl-line-mode</code>), which makes it even
easier to spot the current item (I do not enable this globally,
because I only want it for line-oriented interfaces, such as Dired's,
but not for text editing).</li>

<li>While having two dired buffers open, the rename and copy operations
will place the path of the inactive one as the target destination.
When multiple dired buffers are present, this works between the
current and most recently used ones, with <code>M-n</code> and <code>M-p</code> on the
minibuffer prompt allowing you to switch between all possible targets.</li>

<li>For Emacs 27.1 or higher, Dired can automatically create destination
directories for its copy and rename operations.  So you can, for
example, move (copy or rename) <code>file</code> to <code>/non-existent-path/file</code> and you
will get what you want right away.</li>

<li>For Emacs 27.1 or higher, renaming a file of a version-controlled
repository (git) will be done using the appropriate VC mechanism.
This is to ensure that file name changes are tracked correctly (also
check my detailed: <a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a>).</li>
</ul>

<p>
And here are a few words about the more specialised parts of the Dired
ecosystem:
</p>

<dl class="org-dl">
<dt>Dired subtree</dt><dd><p>
This third-party package which is part of the
<a href="https://github.com/Fuco1/dired-hacks">dired-hacks project by Matus Goljer</a> offers tree-style navigation,
meaning that the subdirectories of the current Dired buffer can be
expanded and contracted in place.  It is possible to perform the same
kind of folding on their subdirectories, and so on.
</p>

<p>
Tree-style navigation is useful in my workflow when all I want is a
quick peek at a directory's contents.
</p></dd>

<dt>Dired extras (dired-x)</dt><dd><p>
These are some additional features that are
shipped with Emacs.  The one I need the most is <code>dired-jump</code> and its
"other window" variant.  These are among my favourite commands.  They
will always take you to the directory that contains the current
buffer. (Note for Emacs 28 users: <code>dired-jump</code> is now part of <code>dired.el</code>).
</p>

<p>
'Jumping' works even when you are inside buffers that do not visit
files, such as Magit, Diff, or Eshell: it just takes you to the
<code>default-directory</code>.  This is its most valuable quality!  Edit a file
then proceed to do some file management, then invoke <code>previous-buffer</code>
or <code>winner-undo</code> to go back to where you were (I have a few key bindings
for those in the <a href="#h:12591f89-eeea-4b12-93e8-9293504e5a12">Window configuration section</a>).  Everything happens
naturally.  Emacs' interconnectedness at its best!
</p>

<p>
The other neat features of <code>dired-x</code> are (1) its ability to open Info
files in place (<code>dired-info</code> command, bound to <code>I</code>), and (2) to open all
marked files at once (<code>dired-do-find-marked-files</code> bound to <code>F</code> by
default).
</p></dd>

<dt>Writable Dired (wdired)</dt><dd>This is the standard editable state of a
dired buffer.  You can access it with <code>C-x C-q</code>.  Write changes to files
or directories, as if it were a regular buffer, then confirm them with
<code>C-c C-c</code>.  This practically means that you can rename files and change
permissions (when the detailed list is available).  Note that while
renaming a file, any forward slash is treated like a directory and <b>is
created directly</b> upon successful exit.  Combine this utility with
keyboard macros, rectangle edits, or <code>query-replace</code> (and its regexp
variant---<a href="#h:b67687ee-25a3-4bf4-a924-180ccb63c629">Isearch, occur, grep, and extras (prot-search.el)</a>) and you
have one potent tool at your disposal.</dd>

<dt>Image dired</dt><dd>This built-in library offers facilities for generating
thumbnails out of a selection of images and displaying them in a
separate buffer.  An external program is needed to convert the images
into thumbnails: <code>imagemagick</code>.  Other useful external packages are
<code>optipng</code> and <code>sxiv</code> (or equivalent).  The former is for operating on PNG
files, while the latter is a lightweight image viewer.  I feel this
process is a bit cumbersome and can be very slow if you try to
generate lots of images at once.  The culprit is the image converter.
As such, only use this for smaller collections.  Besides, Emacs can
open an image in a buffer and that works well for viewing individual
items (else use <code>!</code> or <code>&amp;</code> to run an external process, with the latter
being asynchronous).  I don't keep a lot of images around, so I am not
the best person to comment on this feature.  Instead, I recommend you
view the video of <a href="https://www.youtube.com/watch?v=NrY3t3W0_cM">image-dired by Emacs Elements (Raoul Comninos)</a>.</dd>

<dt>prot-dired.el</dt><dd>This file (reproduced in its entirety below those
configurations) contains a few custom extensions for streamlining some
repetitive tasks.  The video on <a href="https://protesilaos.com/codelog/2021-07-21-emacs-dired-custom-extras/">my custom Dired extras</a> (2021-07-21)
may also be of help.

<ol class="org-ol">
<li>It contains methods for opening media files using an external
program.  The idea is to provide a default option when invoking
either <code>!</code> or <code>&amp;</code> on a given file.  So if, for example, you try to open
an image, it will search the system for the first program matching
the elements in the <code>prot-dired-image-viewers</code> variable.  Same
principle for media players.</li>

<li>The <code>prot-dired-limit-regexp</code> command is a convenience wrapper around
built-in capabilities of narrowing the listing to the files that
match (or don't) a given regular expression.  When called directly,
it prompts for a regexp and removes everything that does not match
it.  This operation does not delete files.  It just hides them
(restore the view either with <code>g</code> or by using the <code>undo</code> command).
When the command is invoked with a universal prefix argument (<code>C-u</code>)
it inverts the meaning of the regular expression so that it hides
the matching entries.</li>

<li><p>
The <code>prot-dired-insert-subdir</code> is a general purpose command for
inserting the contents of a subdirectory in the current Dired
buffer.  It basically provides a superset of features found in the
standard <code>dired-maybe-insert-subdir</code> (bound to <code>i</code> by default).  When
items are marked, it searches among them for the subdirectories to
the current directory and inserts them in the buffer, while
ignoring invalid entries.  If no marks are active and point is on a
subdirectory line, it inserts it directly.  If no marks are active
and point is not on a subdirectory, then it prompts for minibuffer
completion and inserts the selected item.  When invoked with a
single prefix argument (<code>C-u</code>) it first asks for the command-line
flags to pass to the underlying <code>ls</code> program, which can be helpful if
you want to get some more verbose information or pass the <code>-R</code> flag
to directly insert a tree recursively.  And when the command is
called with a double prefix argument (<code>C-u C-u</code>) it removes all
inserted subdirectories in one go.  As always, the <code>undo</code> command can
help you manage each step.
</p>

<p>
Tip: to remove a single subdirectory, you can still use <code>C-u k</code> over
its heading (<code>dired-do-kill-lines</code> with its ARG).
</p>

<p>
Another tip: to update the <code>ls</code> switches for the whole buffer, type
<code>C-u s</code> (<code>dired-sort-toggle-or-edit</code> with its ARG).
</p></li>

<li>An Imenu index is set up which lets you jump to the headers of all
inserted directories using minibuffer completion (either with the
generic <code>M-x imenu</code> or some third-party variant).  The are commands
which provide directional motions to move between such headings:
<code>prot-dired-subdirectory-next</code> and <code>prot-dired-subdirectory-previous</code>.</li>

<li>The command <code>prot-dired-grep-marked-files</code> streamlines a common
workflow I have of using <code>find</code> on the command line to grep for file
contents.  It performs a search in the marked files.  When no items
are marked, it goes through all files in the current directory
(non-recursive).  Its doc string covers the technicalities.  The
command serves as a specialised variant of <code>prot-search-grep</code>
(<a href="#h:b67687ee-25a3-4bf4-a924-180ccb63c629">Isearch, occur, grep, and extras (prot-search.el)</a>).</li>
</ol></dd>
</dl>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Dired file manager (and prot-dired.el extras)
(prot-emacs-builtin-package 'dired
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p) ; also see `dired-do-revert-buffer'
  (setq dired-make-directory-clickable t) ; Emacs 29.1
  (setq dired-free-space nil) ; Emacs 29.1

  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode))

(prot-emacs-builtin-package 'dired-aux
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action))) ; Emacs 28

;; ;; NOTE 2021-05-10: I do not use `find-dired' and related commands
;; ;; because there are other tools that offer a better interface, such
;; ;; as `consult-find', `consult-grep', `project-find-file',
;; ;; `project-find-regexp', `prot-vc-git-grep'.
;; (prot-emacs-builtin-package 'find-dired
;;   (setq find-ls-option
;;         '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
;;   (setq find-name-arg "-iname"))

(prot-emacs-builtin-package 'dired-x
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (define-key dired-mode-map (kbd "I") #'dired-info))

(prot-emacs-builtin-package 'prot-dired
  (setq prot-dired-image-viewers '("feh" "sxiv"))
  (setq prot-dired-media-players '("mpv" "vlc"))
  (setq prot-dired-media-extensions
        "\\.\\(mp[34]\\|ogg\\|flac\\|webm\\|mkv\\)")
  (setq prot-dired-image-extensions
        "\\.\\(png\\|jpe?g\\|tiff\\)")
  (setq dired-guess-shell-alist-user ; those are the defaults for ! and &amp; in Dired
        `((,prot-dired-image-extensions (prot-dired-image-viewer))
          (,prot-dired-media-extensions (prot-dired-media-player))))

  (add-hook 'dired-mode-hook #'prot-dired-setup-imenu)

  (let ((map dired-mode-map))
    (define-key map (kbd "i") #'prot-dired-insert-subdir) ; override `dired-maybe-insert-subdir'
    (define-key map (kbd "/") #'prot-dired-limit-regexp)
    (define-key map (kbd "C-c C-l") #'prot-dired-limit-regexp)
    (define-key map (kbd "M-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "C-c C-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "M-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "C-c C-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "M-s G") #'prot-dired-grep-marked-files))) ; M-s g is `prot-search-grep'

(prot-emacs-elpa-package 'dired-subtree
  (setq dired-subtree-use-backgrounds nil)
  (let ((map dired-mode-map))
    (define-key map (kbd "&lt;tab&gt;") #'dired-subtree-toggle)
    (define-key map (kbd "&lt;backtab&gt;") #'dired-subtree-remove))) ; S-TAB

(prot-emacs-builtin-package 'wdired
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(prot-emacs-builtin-package 'image-dired
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "&lt;return&gt;") #'image-dired-thumbnail-display-external))
</pre>
</div>

<p>
These are the contents of <code>prot-dired.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-dired.el --- Extensions to dired.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my dired.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile (require 'cl-lib))
(require 'prot-common)

(defgroup prot-dired ()
  "Extensions for Dired."
  :group 'dired)

;;;; File associations

(defcustom prot-dired-media-extensions
  "\\.\\(mp[34]\\|ogg\\|flac\\|webm\\|mkv\\)"
  "Regular expression for media file extensions.

Also see the function `prot-dired-media-player' and the variable
`prot-dired-media-players'.

To be used in user configurations while setting up the variable
`dired-guess-shell-alist-user'."
  :type 'string
  :group 'prot-dired)

(defcustom prot-dired-image-extensions
  "\\.\\(png\\|jpe?g\\|tiff\\)"
  "Regular expression for media file extensions.

Also see the function `prot-dired-image-viewer' and the variable
`prot-dired-image-viewers'.

To be used in user configurations while setting up the variable
`dired-guess-shell-alist-user'."
  :type 'string
  :group 'prot-dired)

(defcustom prot-dired-media-players '("mpv" "vlc")
  "List of strings for media player programs.

Also see the function `prot-dired-media-player' and the variable
`prot-dired-media-extensions'.

To be used in user configurations while setting up the variable
`dired-guess-shell-alist-user'."
  :type '(repeat string)
  :group 'prot-dired)

(defcustom prot-dired-image-viewers '("feh" "sxiv")
  "List of strings for image viewer programs.

Also see the function `prot-dired-image-viewer' and the variable
`prot-dired-image-extensions'.

To be used in user configurations while setting up the variable
`dired-guess-shell-alist-user'."
  :type '(repeat string)
  :group 'prot-dired)

;; NOTE 2021-06-28: I am not sure why the compiler complains without
;; this, even though we require cl-lib.
(declare-function cl-remove-if "cl-lib")

(defmacro prot-dired-file-association (name programs)
  "Make NAME function to check for PROGRAMS."
  (declare (indent defun))
  `(defun ,name ()
     ,(format "Return available program.

This checks each entry in `%s' and returns the first program that
is available on the system.  If none is present, it falls back to
xdg-open (for GNU/Linux only).

This function is for use in `dired-guess-shell-alist-user'."
              programs)
     (catch :found
       (dolist (p (append ,programs '("xdg-open")))
         (when (executable-find p)
           (throw :found p))))))

(prot-dired-file-association
  prot-dired-media-player
  prot-dired-media-players)

(prot-dired-file-association
  prot-dired-image-viewer
  prot-dired-image-viewers)

;;;; General commands

(autoload 'dired-mark-files-regexp "dired")
(autoload 'dired-toggle-marks "dired")
(autoload 'dired-do-kill-lines "dired-aux")

(defvar prot-dired--limit-hist '()
  "Minibuffer history for `prot-dired-limit-regexp'.")

;;;###autoload
(defun prot-dired-limit-regexp (regexp omit)
  "Limit Dired to keep files matching REGEXP.

With optional OMIT argument as a prefix (\\[universal-argument]),
exclude files matching REGEXP.

Restore the buffer with \\&lt;dired-mode-map&gt;`\\[revert-buffer]'."
  (interactive
   (list
    (read-regexp
     (concat "Files "
             (when current-prefix-arg
               (propertize "NOT " 'face 'warning))
             "matching PATTERN: ")
     nil 'prot-dired--limit-hist)
    current-prefix-arg))
  (dired-mark-files-regexp regexp)
  (unless omit (dired-toggle-marks))
  (dired-do-kill-lines)
  (add-to-history 'prot-dired--limit-hist regexp))

(defvar prot-dired--find-grep-hist '()
  "Minibuffer history for `prot-dired-grep-marked-files'.")

;; Also see `prot-search-grep' from prot-search.el.
;;;###autoload
(defun prot-dired-grep-marked-files (regexp &amp;optional arg)
  "Run `find' with `grep' for REGEXP on marked files.
When no files are marked or when just a single one is marked,
search the entire directory instead.

With optional prefix ARG target a single marked file.

We assume that there is no point in marking a single file and
running find+grep on its contents.  Visit it and call `occur' or
run grep directly on it without the whole find part."
  (interactive
   (list
    (read-string "grep for PATTERN in marked files: " nil 'prot-dired--find-grep-hist)
    current-prefix-arg)
   dired-mode)
  (when-let* ((marks (dired-get-marked-files 'no-dir))
              (files (mapconcat #'identity marks " -o -name "))
              (args (if (or arg (length&gt; marks 1))
                        (concat
                         "find . -type f "
                         (shell-quote-argument "(")
                         " -name " files " "
                         (shell-quote-argument ")")
                         " -exec grep -nH --color=auto " regexp " "
                         (shell-quote-argument "{}")
                         " " (shell-quote-argument ";") " ")
                      (concat
                       "find . -type f "
                       " -exec grep -nH --color=auto " regexp " "
                       (shell-quote-argument "{}")
                       " " (shell-quote-argument ";") " "))))
    (compilation-start
     args
     'grep-mode
     (lambda (mode) (format "*prot-dired-find-%s '%s'" mode regexp))
     t)))

;;;; Subdir extras and Imenu setup

(defvar prot-dired--directory-header-regexp "^ +\\(.+\\):\n"
  "Pattern to match Dired directory headings.")

;;;###autoload
(defun prot-dired-subdirectory-next (&amp;optional arg)
  "Move to next or optional ARGth Dired subdirectory heading.
For more on such headings, read `dired-maybe-insert-subdir'."
  (interactive "p")
  (let ((pos (point))
        (subdir prot-dired--directory-header-regexp))
    (goto-char (point-at-eol))
    (if (re-search-forward subdir nil t (or arg nil))
        (progn
          (goto-char (match-beginning 1))
          (goto-char (point-at-bol)))
      (goto-char pos))))

;;;###autoload
(defun prot-dired-subdirectory-previous (&amp;optional arg)
  "Move to previous or optional ARGth Dired subdirectory heading.
For more on such headings, read `dired-maybe-insert-subdir'."
  (interactive "p")
  (let ((pos (point))
        (subdir prot-dired--directory-header-regexp))
    (goto-char (point-at-bol))
    (if (re-search-backward subdir nil t (or arg nil))
        (goto-char (point-at-bol))
      (goto-char pos))))

(autoload 'dired-current-directory "dired")
(autoload 'dired-kill-subdir "dired-aux")

;;;###autoload
(defun prot-dired-remove-inserted-subdirs ()
  "Remove all inserted Dired subdirectories."
  (interactive)
  (goto-char (point-max))
  (while (and (prot-dired-subdirectory-previous)
              (not (equal (dired-current-directory)
                          (expand-file-name default-directory))))
      (dired-kill-subdir)))

(autoload 'cl-remove-if-not "cl-seq")

(defun prot-dired--dir-list (list)
  "Filter out non-directory file paths in LIST."
  (cl-remove-if-not
   (lambda (dir)
     (file-directory-p dir))
   list))

(defun prot-dired--insert-dir (dir &amp;optional flags)
  "Insert DIR using optional FLAGS."
  (dired-maybe-insert-subdir (expand-file-name dir) (or flags nil)))

(autoload 'dired-get-filename "dired")
(autoload 'dired-get-marked-files "dired")
(autoload 'dired-maybe-insert-subdir "dired-aux")
(defvar dired-subdir-switches)
(defvar dired-actual-switches)

;;;###autoload
(defun prot-dired-insert-subdir (&amp;optional arg)
  "Generic command to insert subdirectories in Dired buffers.

When items are marked, insert those which are subsirectories of
the current directory.  Ignore regular files.

If no marks are active and point is on a subdirectory line,
insert it directly.

If no marks are active and point is not on a subdirectory line,
prompt for a subdirectory using completion.

With optional ARG as a single prefix (`\\[universal-argument]')
argument, prompt for command line flags to pass to the underlying
'ls' program.

With optional ARG as a double prefix argument, remove all
inserted subdirectories."
  (interactive "p")
  (let* ((name (dired-get-marked-files))
         (flags (when (eq arg 4)
                  (read-string "Flags for `ls' listing: "
                               (or dired-subdir-switches dired-actual-switches)))))
    (cond  ; NOTE 2021-07-20: `length&gt;', `length=' are from Emacs28
     ((eq arg 16)
      (prot-dired-remove-inserted-subdirs))
     ((and (length&gt; name 1) (prot-dired--dir-list name))
      (mapc (lambda (file)
              (when (file-directory-p file)
                (prot-dired--insert-dir file flags)))
            name))
     ((and (length= name 1) (file-directory-p (car name)))
      (prot-dired--insert-dir (car name) flags))
     (t
      (let ((selection (read-directory-name "Insert directory: ")))
        (prot-dired--insert-dir selection flags))))))

(defun prot-dired--imenu-prev-index-position ()
  "Find the previous file in the buffer."
  (let ((subdir prot-dired--directory-header-regexp))
    (re-search-backward subdir nil t)))

(defun prot-dired--imenu-extract-index-name ()
  "Return the name of the file at point."
  (file-relative-name
   (buffer-substring-no-properties (+ (point-at-bol) 2)
                                   (1- (point-at-eol)))))

;;;###autoload
(defun prot-dired-setup-imenu ()
  "Configure imenu for the current dired buffer.
Add this to `dired-mode-hook'."
  (set (make-local-variable 'imenu-prev-index-position-function)
       'prot-dired--imenu-prev-index-position)
  (set (make-local-variable 'imenu-extract-index-name-function)
       'prot-dired--imenu-extract-index-name))

(provide 'prot-dired)
;;; prot-dired.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:954adfb4-8f2c-4665-bb5b-e098926341b0" class="outline-4">
<h4 id="h:954adfb4-8f2c-4665-bb5b-e098926341b0"><span class="section-number-4">4.1.1.</span> dired-like mode for the trash (trashed.el)</h4>
<div class="outline-text-4" id="text-h:954adfb4-8f2c-4665-bb5b-e098926341b0">
<p>
<code>trashed</code> applies the principles of <code>dired</code> to the management of the user's
filesystem trash.  Use <code>C-h m</code> to see the docs and keybindings for its
major mode.
</p>

<p>
Basically, its interaction model is as follows:
</p>

<ul class="org-ul">
<li><code>m</code> to mark for some deferred action, such as <code>D</code> to delete, <code>R</code> to restore.</li>
<li><code>t</code> to toggle the status of all items as marked.  Use this without marks
to <code>m</code> (mark) all items, then call a deferred action to operate on them.</li>
<li><code>d</code> to mark for permanent deletion.</li>
<li><code>r</code> to mark for restoration.</li>
<li><code>x</code> to execute these special marks.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; dired-like mode for the trash (trashed.el)
(prot-emacs-elpa-package 'trashed
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:137f16fe-4f88-4b4d-bd71-cd978c9fdcd5" class="outline-3">
<h3 id="h:137f16fe-4f88-4b4d-bd71-cd978c9fdcd5"><span class="section-number-3">4.2.</span> Working with buffers</h3>
<div class="outline-text-3" id="text-h:137f16fe-4f88-4b4d-bd71-cd978c9fdcd5">
</div>

<div id="outline-container-h:17933226-27a8-47c0-80f9-3cc609aacae0" class="outline-4">
<h4 id="h:17933226-27a8-47c0-80f9-3cc609aacae0"><span class="section-number-4">4.2.1.</span> Keymap for buffers (Emacs28)</h4>
<div class="outline-text-4" id="text-h:17933226-27a8-47c0-80f9-3cc609aacae0">
<p>
Starting with Emacs version 28, there is a keymap that can be accessed
with the <code>C-x x</code> sequence.  This new keymap (<code>ctl-x-x-map</code>), is meant to be
used for commands that pertain to the current buffer.  What I have here
are just some tweaks to make it work the way I prefer.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Keymap for buffers (Emacs28)
(let ((map ctl-x-x-map))              ; Emacs 28
  (define-key map "e" #'eval-buffer)
  (define-key map "f" #'follow-mode)  ; override `font-lock-update'
  (define-key map "r" #'rename-uniquely))

(with-eval-after-load 'org
  (define-key ctl-x-x-map "i" #'prot-org-id-headlines)
  (define-key ctl-x-x-map "h" #'prot-org-ox-html))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:60a70340-49dc-4f45-b147-12a4141db42b" class="outline-4">
<h4 id="h:60a70340-49dc-4f45-b147-12a4141db42b"><span class="section-number-4">4.2.2.</span> Unique names for buffers</h4>
<div class="outline-text-4" id="text-h:60a70340-49dc-4f45-b147-12a4141db42b">
<p>
These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of <code>uniquify-buffer-name-style</code>.  While <code>uniquify-strip-common-suffix</code> will
remove the part of the file system path they have in common.
</p>

<p>
All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Unique names for buffers
(prot-emacs-builtin-package 'uniquify
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:06290f9c-491c-45b2-b213-0248f890c83d" class="outline-4">
<h4 id="h:06290f9c-491c-45b2-b213-0248f890c83d"><span class="section-number-4">4.2.3.</span> Ibuffer and extras (dired-like buffer list manager)</h4>
<div class="outline-text-4" id="text-h:06290f9c-491c-45b2-b213-0248f890c83d">
<p>
<code>ibuffer.el</code> ships with Emacs and it provides a drop-in replacement for
<code>list-buffers</code>.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.  For this
reason I bind it to <code>C-x C-b</code>.
</p>

<p>
Overview of its features:
</p>

<ul class="org-ul">
<li>mark and delete buffers same way you do in <code>dired</code> (see the previous
sections on <a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">dired (directory editor, file manager)</a>);</li>
<li>mark by a predicate, such as name, major mode, etc.;</li>
<li>sort buffers by name, filesystem path, major mode, size;</li>
<li>run <code>occur</code> on the marked buffers (remember: Occur produces a buffer
that you can edit once you enable the editable state with <code>e</code>);</li>
<li>run <code>query-replace</code> or <code>query-replace-regexp</code> on marked buffers.</li>
</ul>

<p>
Run the universal help command for major mode documentation (<code>C-h m</code>)
while inside <code>ibuffer</code> to get a detailed list of all available commands
and their key bindings.
</p>

<p>
With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:
</p>

<ul class="org-ul">
<li>Prompt for confirmation only when deleting a modified buffer.</li>
<li>Hide the summary.</li>
<li>Do not open on the other window; use the current one.</li>
<li>Do not show empty filter groups.</li>
<li>Do not cycle movements.  So do not go to the top when moving downward
at the last item on the list.</li>
</ul>

<p>
Also watch my <a href="https://protesilaos.com/codelog/2020-04-02-emacs-intro-ibuffer/">introduction to Ibuffer</a> (2020-04-02).
</p>

<p>
Now some extras that I introduced after I published that video, which
pertain to my <code>prot-ibuffer.el</code> library (copied in its entirety below the
package configurations):
</p>

<ul class="org-ul">
<li><code>prot-ibuffer-buffers-major-mode</code> produces a filtered list of buffers
that match the major mode of the current buffer and lets you pick one
using minibuffer completion.  With an optional prefix argument (<code>C-u</code>)
it places the results in an Ibuffer list.</li>

<li><code>prot-ibuffer-buffers-vc-root</code> filters the list to items that match the
current buffer's version-controlled directory.  In practice, this
fills the same niche as the built-in <code>project-switch-to-buffer</code> (for
Emacs 28+), with the crucial difference that it neither reads from nor
writes to the list of known projects (also check my configurations for
<a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>).  When called with an
optional prefix argument, this command puts its matching candidates in
an Ibuffer view.</li>
</ul>

<p>
For those two I received guidance from Omar Antolín Camarena with regard
to the use of <code>read-buffer</code> and the <code>lambda</code> passed to it (any errors are my
own).  This method informs other tools that this type of completion
pertains to buffers, so they can adapt accordingly.  See, in particular,
<a href="#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">Extended minibuffer actions and more (embark.el and prot-embark.el)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Ibuffer and extras (dired-like buffer list manager)
(prot-emacs-builtin-package 'ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 40 40 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  (define-key global-map (kbd "C-x C-b") #'ibuffer)
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content)))

(prot-emacs-builtin-package 'prot-ibuffer
  (let ((map global-map))
    (define-key map (kbd "M-s b") #'prot-ibuffer-buffers-major-mode)
    (define-key map (kbd "M-s v") #'prot-ibuffer-buffers-vc-root)))
</pre>
</div>

<p>
Here is <code>prot-ibuffer.el</code> (find everything in <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-ibuffer.el --- Extensions to ibuffer.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my ibuffer.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'ibuffer)

;;;###autoload
(defun prot-ibuffer-buffers-major-mode (&amp;optional arg)
  "Select buffers that match the current buffer's major mode.
With optional prefix ARG (\\[universal-argument]) produce an
`ibuffer' filtered accordingly.  Else use standard completion."
  (interactive "P")
  (let* ((major major-mode)
         (prompt "Buffers for"))
    (if arg
        (ibuffer t (format "*%s %s*" prompt major)
                 (list (cons 'used-mode major)))
      (switch-to-buffer
       (read-buffer
        (format "%s %s:" prompt major) nil t
        (lambda (pair) ; pair is (name-string . buffer-object)
          (with-current-buffer (cdr pair) (derived-mode-p major))))))))

;;;###autoload
(defun prot-ibuffer-buffers-vc-root (&amp;optional arg)
  "Select buffers that belong to the version controlled directory.
With optional prefix ARG (\\[universal-argument]) produce an
`ibuffer' filtered accordingly.  Else use standard completion."
  (interactive "P")
  (let* ((root (or (vc-root-dir)
                   (locate-dominating-file "." ".git")))
         (prompt "Buffers for VC"))
    (if root
        (if arg
            (ibuffer t (format "*%s %s*" prompt root)
                     (list (cons 'filename (expand-file-name root))))
          (switch-to-buffer
           (read-buffer
            (format "%s %s:" prompt root) nil t
            (lambda (pair) ; pair is (name-string . buffer-object)
              (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
      (user-error "Not in a version-controlled directory"))))

(provide 'prot-ibuffer)
;;; prot-ibuffer.el ends here
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:12591f89-eeea-4b12-93e8-9293504e5a12" class="outline-3">
<h3 id="h:12591f89-eeea-4b12-93e8-9293504e5a12"><span class="section-number-3">4.3.</span> Window configuration</h3>
<div class="outline-text-3" id="text-h:12591f89-eeea-4b12-93e8-9293504e5a12">
<p>
I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.
</p>

<p>
By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.
</p>

<p>
That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.
</p>
</div>

<div id="outline-container-h:3d8ebbb1-f749-412e-9c72-5d65f48d5957" class="outline-4">
<h4 id="h:3d8ebbb1-f749-412e-9c72-5d65f48d5957"><span class="section-number-4">4.3.1.</span> Window rules and basic tweaks (window.el)</h4>
<div class="outline-text-4" id="text-h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">
<p>
The <code>display-buffer-alist</code> is intended as a rule-set for controlling the
placement of windows.  This is mostly needed for ancillary buffers, such
as shells, compilation output, and the like.  The objective is to create
a more intuitive workflow where targeted buffer groups or types are
always shown at a given location, on the premise that predictability
improves usability.
</p>

<p>
For each buffer action in <code>display-buffer-alist</code> we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.
</p>

<p>
Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual (evaluate <code>(elisp) Displaying Buffers</code>).
Information can also be found at all times via <code>C-h f display-buffer</code> and,
for my particular settings, with <code>C-h f display-buffer-in-side-window</code>.
</p>

<p>
With regard to the key bindings you will find here, most combinations
are complementary to the standard ones, such as <code>C-x 1</code> being aliased as
<code>s-1</code>, <code>C-x o</code> turning into <code>s-o</code> and the like.  They <b>do not replace</b> the
defaults: they just provide more convenient access to their
corresponding functions.  Some involve the Super key, in accordance with
the norms described in the relevant <a href="#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703">note on the matter</a>.  Concerning the
<code>balance-windows-area</code> I find that it is less intrusive than the original
<code>balance-windows</code> normally bound to the same <code>C-x +</code>.  Lastly, the
<code>resize-window-repeat-map</code> is for repeatable key chords that work with the
<code>repeat-mode</code> for Emacs28 (read my description of what it is and how to
set it up: <a href="#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0">Repeatable key chords (repeat-mode)</a>).
</p>

<p>
Make sure to also review the other window-related keys in those
sections:
</p>

<ul class="org-ul">
<li><a href="#h:6b4f7792-6ccd-45d5-b262-01d200639072">Window history (winner-mode)</a>.</li>
<li><a href="#h:230d96c8-a955-4b82-844d-9de9a1b7c531">Directional window motions (windmove)</a>.</li>
</ul>

<p>
For a demo of the <code>display-buffer-alist</code> and the functions that
accompany it, watch my <a href="https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/">video on rules for buffer placement</a>
(2020-01-07).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Window rules and basic tweaks (window.el)
(prot-emacs-builtin-package 'window
  (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\**prot-elfeed-bongo-queue.*"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -2))
          ("\\*\\(prot-elfeed-mpv-output\\|world-clock\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; ("\\*\\(Embark\\)?.*Completions.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-bottom)
          ;;  (window-parameters . ((no-other-window . t))))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x &lt;down&gt;") #'next-buffer)
    (define-key map (kbd "C-x &lt;up&gt;") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x &gt;") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x &lt;") #'shrink-window-horizontally)) ; override `scroll-left'
  (let ((map resize-window-repeat-map))
    (define-key map "&gt;" #'enlarge-window-horizontally)
    (define-key map "&lt;" #'shrink-window-horizontally)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:6b4f7792-6ccd-45d5-b262-01d200639072" class="outline-4">
<h4 id="h:6b4f7792-6ccd-45d5-b262-01d200639072"><span class="section-number-4">4.3.2.</span> Window history (winner-mode)</h4>
<div class="outline-text-4" id="text-h:6b4f7792-6ccd-45d5-b262-01d200639072">
<p>
Also check: <a href="#h:230d96c8-a955-4b82-844d-9de9a1b7c531">Directional window motions (windmove)</a>.
</p>

<p>
Winner is a built-in tool that keeps a record of buffer and window
layout changes.  It then allows us to move back and forth in the history
of said changes.  As noted in the section about the <code>tab-bar</code>, the main
problem with Winner is that it cannot keep parallel histories, each for
a given tab (see <a href="#h:63ad472f-c9c2-40ad-9675-1dc529487788">Tabs for window layouts (tab-bar.el and prot-tab.el)</a>).
The alternative is to use <code>tab-bar-history-mode</code> and the commands it
provides or, more specifically, the wrappers I have defined which fall
back to Winner when tabs are not in use.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Window history (winner-mode)
(prot-emacs-builtin-package 'winner
  (add-hook 'after-init-hook #'winner-mode)

  ;; ;; NOTE 2021-07-31: Those are superseded by the commands
  ;; ;; `prot-tab-winner-undo' and `prot-tab-winner-redo' in prot-tab.el
  ;; ;; (search this document).
  ;; (let ((map global-map))
  ;;   (define-key map (kbd "C-x &lt;right&gt;") #'winner-redo)
  ;;   (define-key map (kbd "C-x &lt;left&gt;") #'winner-undo))
  )
</pre>
</div>
</div>
</div>

<div id="outline-container-h:230d96c8-a955-4b82-844d-9de9a1b7c531" class="outline-4">
<h4 id="h:230d96c8-a955-4b82-844d-9de9a1b7c531"><span class="section-number-4">4.3.3.</span> Directional window motions (windmove)</h4>
<div class="outline-text-4" id="text-h:230d96c8-a955-4b82-844d-9de9a1b7c531">
<p>
Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions: a decent addition to the
simpler <code>other-window</code> command (<code>C-x o</code> by default).  It also has commands
for deleting a window in the given direction as well as for switching
the current window with the one in the given direction.  I do not need
the directional deletion motions, as they require extra key bindings
while I feel that it is easy enough to select a window and delete it
outright with <code>delete-window</code> (on <code>C-x 0</code> by default).
</p>

<p>
The <code>windmove-create-window</code> variable specifies what should happen when
trying to move past the edge of the frame.  The idea with this is to
allow it to create a new window with the contents of the current buffer.
I tried it for a while but felt that the times it would interfere with
my layout by mistake where more than those it would actually speed up my
workflow.
</p>

<p>
Also read: <a href="#h:6b4f7792-6ccd-45d5-b262-01d200639072">Window history (winner-mode)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Directional window motions (windmove)
(prot-emacs-builtin-package 'windmove
  (setq windmove-create-window nil)     ; Emacs 27.1
  (let ((map global-map))
    ;; Those override some commands that are already available with
    ;; C-M-u, C-M-f, C-M-b.
    (define-key map (kbd "C-M-&lt;up&gt;") #'windmove-up)
    (define-key map (kbd "C-M-&lt;right&gt;") #'windmove-right)
    (define-key map (kbd "C-M-&lt;down&gt;") #'windmove-down)
    (define-key map (kbd "C-M-&lt;left&gt;") #'windmove-left)
    (define-key map (kbd "C-M-S-&lt;up&gt;") #'windmove-swap-states-up)
    (define-key map (kbd "C-M-S-&lt;right&gt;") #'windmove-swap-states-right) ; conflicts with `org-increase-number-at-point'
    (define-key map (kbd "C-M-S-&lt;down&gt;") #'windmove-swap-states-down)
    (define-key map (kbd "C-M-S-&lt;left&gt;") #'windmove-swap-states-left)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:63ad472f-c9c2-40ad-9675-1dc529487788" class="outline-4">
<h4 id="h:63ad472f-c9c2-40ad-9675-1dc529487788"><span class="section-number-4">4.3.4.</span> Tabs for window layouts (tab-bar.el and prot-tab.el)</h4>
<div class="outline-text-4" id="text-h:63ad472f-c9c2-40ad-9675-1dc529487788">
<p>
Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":
</p>

<ol class="org-ol">
<li>Work spaces that contain windows in any given layout.</li>
<li>A list of buffers presented as buttons at the top of the window.</li>
</ol>

<p>
The former, represented by the <code>tab-bar</code> library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.
</p>

<p>
The latter, implemented in <code>tab-line</code>, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.
</p>

<p>
I do not need the <code>tab-line</code> as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way&#x2014;do not forget to check my <a href="#h:06290f9c-491c-45b2-b213-0248f890c83d">Ibuffer settings</a>).
</p>

<p>
On the other hand, the work spaces (<code>tab-bar</code>) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).
</p>

<p>
Starting with Emacs 28, the <code>tab-bar</code> can re-use indicators from the mode
line.  With a bit of tweaking (and dirty hacks&#x2014;but, hey, they work!)
we can hide all mode lines and replace them with a single status bar
that spans the length of the frame (just like the Tmux status line, if
you have ever used that).  I was aware of this possibility for a long
time, as I keep track of developments in emacs.git, but I never actually
tinkered with the available options&#x2026;  Until Philip Kaludercic
published the article <a href="http://ruzkuku.com/texts/emacs-global.html">Emacs 28 has a global mode line</a> (2021-07-29) which
inspired me to finally start experimenting.
</p>

<p>
As of this writing (2021-07-30), upstream Emacs only covers the part of
the mode line that shows the current time and the like (technically the
<code>global-mode-string</code>).  So my <code>prot-tab.el</code> library, which is reproduced
after the following package configurations, implements some more
indicators that I want to use.
</p>

<p>
The minor mode which takes care of this new "status line" concept is
<code>prot-tab-status-line</code>.  Check the code to notice the dirty hacks I
alluded to.
</p>

<p>
In the past, I was using a command which would merely toggle the display
of the <code>tab-bar</code> (<code>prot-tab-bar-toggle</code>), but now that I can finally avoid
the duplication of information and keep things cleaner, I think I am not
going back to the paradigm where each window has its own mode line.
</p>

<p>
To learn about the key bindings that the <code>tab-bar</code> uses, type its prefix
key <code>C-x t</code> and follow it up with <code>C-h</code> (read <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).
</p>

<p>
Finally, now that <code>tab-bar-history-mode</code> is a de facto replacement for
<code>winner-mode</code>.  Like Winner, it stores a history of window layouts.
Unlike Winner, it keeps histories that are specific to each tab.  The
problem with Winner is that when we switch between tabs, it continues to
retain a linear history, so when we try to undo in one tab, we
effectively get the state of the previous one.  As such, my two commands
<code>prot-tab-winner-undo</code> and <code>prot-tab-winner-redo</code> provide thin wrappers
around the two modes.  If tabs are present, then we use the history for
them, else we fall back to Winner.
</p>

<p>
Here are my settings, followed by the entirety of <code>prot-tab.el</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Tabs for window layouts (tab-bar.el and prot-tab.el)
(prot-emacs-builtin-package 'tab-bar
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice nil)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)

  (tab-bar-mode -1)                     ; see `prot-tab-status-line'

  ;; Same concept as `winner-mode'.  See the `prot-tab-winner-undo' and
  ;; its counterpart.
  (tab-bar-history-mode 1))

(prot-emacs-builtin-package 'prot-tab
  (setq prot-tab-tab-select-num-threshold 3)
  (setq tab-bar-format                    ; Emacs 28
        '(prot-tab-format-space-single
          prot-tab-format-mule-info
          prot-tab-format-modified
          tab-bar-format-tabs-groups
          prot-tab-format-space-double
          prot-tab-format-position
          prot-tab-format-space-double
          prot-tab-format-vc
          prot-tab-format-space-double
          prot-tab-format-modes         ; FIXME 2021-07-30: Make it work with `minions'.
          tab-bar-format-align-right
          prot-tab-format-misc-info
          prot-tab-format-space-double
          tab-bar-format-global
          prot-tab-format-space-single))

  (add-hook 'after-init-hook #'prot-tab-status-line)

  (let ((map global-map))
    (define-key map (kbd "C-x &lt;right&gt;") #'prot-tab-winner-redo)
    (define-key map (kbd "C-x &lt;left&gt;") #'prot-tab-winner-undo)
    (define-key map (kbd "&lt;f8&gt;") #'prot-tab-status-line) ; unopinionated alternative: `prot-tab-bar-toggle'
    (define-key map (kbd "C-x t t") #'prot-tab-select-tab-dwim)))

;; ;; This is only included as a reference.
;; (prot-emacs-builtin-package 'tab-line
;;   (global-tab-line-mode -1))
</pre>
</div>

<p>
The <code>prot-tab.el</code> code, which is in <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-tab.el --- Tab bar (tab-bar.el) extras for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This set of configurations pertains to my tab-bar.el extensions, for
;; use in my Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'tab-bar)

(defgroup prot-tab ()
  "Extensions for tab-bar.el."
  :group 'tab-bar)

(defcustom prot-tab-tab-select-num-threshold 3
  "Minimum number of tabs to prompt for numeric selection.
This is used by `prot-tab-select-tab-dwim' to determine whether
it should prompt for completion, or to ask for just a tab number
to switch to.  If the number of open tabs is greater than this
variable's value, then the command will prompt for a number."
  :type 'integer
  :group 'prot-tab)

;;;; General commands

(defun prot-tab--tab-bar-tabs ()
  "Return a list of `tab-bar' tabs, minus the current one."
  (mapcar (lambda (tab)
            (alist-get 'name tab))
          (tab-bar--tabs-recent)))

;;;###autoload
(defun prot-tab-select-tab-dwim (&amp;optional arg)
  "Do-What-I-Mean function for getting to a `tab-bar' tab.
If no other tab exists, or with optional prefix argument
ARG (\\[universal-argument]), create one and switch to it.

If there is one other tab (so two in total) switch to it without
further questions.

If the tabs are more than `prot-tab-tab-select-num-threshold',
show numeric hints (`tab-bar-tab-hints') and prompt for a number
to switch to.  Else prompt for full text completion."
  (interactive "P")
  (let ((tabs (prot-tab--tab-bar-tabs)))
    (cond
     ((or arg (null tabs))
      (tab-new))
     ((length= tabs 1)
      (tab-next))
     ((length&gt; tabs (1- prot-tab-tab-select-num-threshold))
      (let ((tab-bar-tab-hints t)
            (bar tab-bar-mode))
        (unwind-protect
            (progn
              (unless bar
                (prot-tab-bar-toggle 1))
              (tab-bar-select-tab
               (read-number "Go to tab NUM: ")))
          (unless bar
            (prot-tab-bar-toggle -1)))))
     (t
      (tab-bar-switch-to-tab
       (completing-read "Select tab: " tabs nil t))))))

;;;###autoload
(define-minor-mode prot-tab-bar-toggle
  "Toggle `tab-bar' presentation."
  :init-value nil
  :global t
  (if (or prot-tab-bar-toggle
          (not (bound-and-true-p tab-bar-mode)))
      (progn
        (setq tab-bar-show t)
        (tab-bar-mode 1))
    (setq tab-bar-show nil)
    (tab-bar-mode -1)))

;;;; Window layout history

(declare-function winner-undo "winner")
(declare-function winner-redo "winner")

;;;###autoload
(defun prot-tab-winner-undo ()
  "Go to previous window layout in the history.
When Tab-Bar-Mode and Tab-Bar-History-Mode are active, use
history that is specific to the current tab.  Else try to call
`winner-undo' if Winner-Mode is active.  Signal an error
otherwise."
  (interactive)
  (if (and (bound-and-true-p tab-bar-mode)
           (bound-and-true-p tab-bar-history-mode))
      (progn
        (tab-bar-history-back)
        (setq this-command 'tab-bar-history-back))
    (if (bound-and-true-p winner-mode)
        (progn
          (winner-undo)
          (setq this-command 'winner-undo))
      (user-error "No `tab-bar-history-mode' or `winner-mode' active"))))

;;;###autoload
(defun prot-tab-winner-redo ()
  "Go to next window layout in the history.
When Tab-Bar-Mode and Tab-Bar-History-Mode are active, use
history that is specific to the current tab.  Else try to call
`winner-redo' if Winner-Mode is active.  Signal an error
otherwise."
  (interactive)
  (if (and (bound-and-true-p tab-bar-mode)
           (bound-and-true-p tab-bar-history-mode))
      (progn
        (tab-bar-history-forward)
        (setq this-command 'tab-bar-history-forward))
    (if (bound-and-true-p winner-mode)
        (progn
          (winner-redo)
          (setq this-command 'winner-redo))
      (user-error "No `tab-bar-history-mode' or `winner-mode' active"))))

;;;; Indicators for `tab-bar-format' --- EXPERIMENTAL

(defun prot-tab-format-mule-info ()
  "Format `mode-line-mule-info' for the tab bar."
  `((global menu-item ,(string-trim-right (format-mode-line mode-line-mule-info)) ignore)))

(defun prot-tab-format-modified ()
  "Format `mode-line-modified' for the tab bar."
  `((global menu-item ,(string-trim-right (format-mode-line mode-line-modified)) ignore)))

(defun prot-tab-format-modes ()
  "Format `mode-line-modes' for the tab bar."
  `((global menu-item ,(string-trim-right (format-mode-line mode-line-modes)) ignore)))

;; FIXME 2021-07-30: This does not update unless some other event takes
;; place, such as an ELDOC update.  Otherwise it updates every second.
(defun prot-tab-format-position ()
  "Format `mode-line-position' for the tab bar."
  `((global menu-item ,(string-trim-right (format-mode-line mode-line-position)) ignore)))

(defun prot-tab-format-vc ()
  "Format VC status for the tab bar."
  `((global menu-item ,(string-trim-right (format-mode-line vc-mode)) ignore)))

(defun prot-tab-format-misc-info ()
  "Format `mode-line-misc-info' for the tab bar."
  `((global menu-item ,(string-trim-right (format-mode-line mode-line-misc-info)) ignore)))

(defun prot-tab-format-space-single ()
  "Format space for the tab bar."
  `((global menu-item " " ignore)))

(defun prot-tab-format-space-double ()
  "Format double space for the tab bar."
  `((global menu-item "  " ignore)))

(defvar prot-tab--window-divider-place (default-value 'window-divider-default-places)
  "Last value of `window-divider-default-places'.
For use in Prot-Tab-Status-Line.")

(declare-function prot-notmuch-mail-indicator "prot-notmuch")

;; NOTE 2021-07-30: This is experimental and subject to review.
;;;###autoload
(define-minor-mode prot-tab-status-line
  "Make Tab bar a status line and configure the extras.
Hide the mode lines and change their colors."
  :global t
  :group 'prot-tab
  (if prot-tab-status-line
      (progn
        (setq tab-bar-show t)
        (tab-bar-mode 1)
        (tab-bar-history-mode 1)
        (setq window-divider-default-places t)
        (window-divider-mode 1)
        (display-time-mode 1)
        (when (featurep 'prot-notmuch)
          (prot-notmuch-mail-indicator 1))
        (custom-set-faces
         `(mode-line ((default :height 1 :box nil :overline nil :underline nil)
                      (((class color) (min-colors 88) (background light))
                       :background "#0000c0" ; OR ,@(list (face-attribute 'default :foreground))
                       :foreground "#0000c0")
                      (((class color) (min-colors 88) (background dark))
                       :background "#00bcff"
                       :foreground "#00bcff")
                      (t :inverse-video t)))
         `(mode-line-inactive ((default :height 1 :box nil :overline nil :underline nil)
                      (((class color) (min-colors 88) (background light))
                       :background "white"
                       :foreground "white")
                      (((class color) (min-colors 88) (background dark))
                       :background "black"
                       :foreground "black")))))
    (setq tab-bar-show nil)
    (tab-bar-mode -1)
    (tab-bar-history-mode -1)
    (setq window-divider-default-places prot-tab--window-divider-place)
    (window-divider-mode -1)
    (display-time-mode -1)
    (when (featurep 'prot-notmuch)
      (prot-notmuch-mail-indicator -1))
    (custom-set-faces
     `(mode-line (( )))
     `(mode-line-inactive (( ))))))

(provide 'prot-tab)
;;; prot-tab.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:753ea060-57e4-4dba-9bf9-b6337e478839" class="outline-4">
<h4 id="h:753ea060-57e4-4dba-9bf9-b6337e478839"><span class="section-number-4">4.3.5.</span> Transposition and rotation of windows</h4>
<div class="outline-text-4" id="text-h:753ea060-57e4-4dba-9bf9-b6337e478839">
<p>
The <code>transpose-frame</code> library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with <code>M-x find-library transpose-frame</code>.
</p>

<p>
Remember that you can always repeat a command with <code>C-x z</code>.  And if you
have the right settings, you can repeat again just by pressing another <code>z</code>
(see <a href="#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0">Repeatable key chords (repeat-mode)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Transposition and rotation of windows
(prot-emacs-elpa-package 'transpose-frame
  (let ((map global-map))
    (define-key map (kbd "C-x M-r") #'rotate-frame-clockwise)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h:fa8bd8af-de14-489b-bc56-1a9bb3ef9f0f" class="outline-2">
<h2 id="h:fa8bd8af-de14-489b-bc56-1a9bb3ef9f0f"><span class="section-number-2">5.</span> Applications and utilities</h2>
<div class="outline-text-2" id="text-h:fa8bd8af-de14-489b-bc56-1a9bb3ef9f0f">
<p>
This section includes configurations for programs like email clients,
news reader, music players…  Anything you would normally see in a
standalone application.  The end goal is to eventually integrate every
aspect of my computing inside of Emacs.
</p>
</div>

<div id="outline-container-h:79cd6177-a81b-420f-8759-e6927b974377" class="outline-3">
<h3 id="h:79cd6177-a81b-420f-8759-e6927b974377"><span class="section-number-3">5.1.</span> Built-in bookmarking framework (bookmark.el and prot-bookmark.el)</h3>
<div class="outline-text-3" id="text-h:79cd6177-a81b-420f-8759-e6927b974377">
<p>
Bookmarks are compartments that store data persistently about a file,
directory, Info node, Man or WoMan page, image-mode entry, Docview or
pdf-tools document, Eshell buffer&#x2026;  Basically there can be a bookmark
for anything that Emacs can access, as long as it has a handler function
configured for it.  Do <code>M-x apropos-function</code> and search for <code>bookmark jump</code>
to see what is on offer (packages can add their own support).
</p>

<p>
When you set a bookmark with the command <code>bookmark-set</code> (bound by default
to <code>C-x r m</code>), Emacs remembers both the current item and, when data
persists on disk, the position of the point in it.  The command prompts
you for a name, which wil make it easier for you to retrieve the
information afterwards.  Alternatively, use <code>bookmark-set-no-overwrite</code>
(<code>C-x r M</code>) to prevent yourself from overriding existing bookmarks (though
I generally prefer to write meaningful names for my entries).
</p>

<p>
To access bookmarks with minibuffer completion, invoke the command
<code>bookmark-jump</code> (<code>C-x r b</code>).  To get an overview in a tabulated list, call
<code>list-bookmarks</code> (<code>C-x r l</code>).
</p>

<p>
If you would like to browse bookmarks (and other sources such as recent
files) through an all-in-one interface, use the <code>consult-buffer</code> command
(see <a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el and prot-consult.el)</a>).
Consult also offers the command <code>consult-bookmark</code> which is like the
standard <code>bookmark-jump</code> except that it also has support for group
headings (so all files are under one heading, all Info nodes in
another).  I thus consider it a drop-in replacement for <code>C-x r b</code>.
</p>

<p>
The <code>list-bookmarks</code> interface provides several commands for visiting, or
deleting bookmarks.  Use <code>C-h m</code> (<code>describe-mode</code>) to get a help buffer with
an explanation of what those are (and remember to make best use of
Emacs' self-documentation system: <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).
</p>

<p>
Internally, bookmarks are similar to registers.  As such, I encourage
you to read the official manual on the matter by evaluating this form:
<code>(info "(emacs) Registers")</code>.  Also watch my <a href="https://protesilaos.com/codelog/2020-03-08-emacs-registers/">Primer on Emacs “registers”</a>
(2020-03-08).
</p>

<p>
<code>bookmark.el</code> offers a few customisation options, though I find that the
out-of-the-box design works well for my needs.  What I am still not sure
about is the option to query for a longer form annotation (the variable
<code>bookmark-use-annotations</code>) <i>while recording a new bookmark</i>.  It pops up a
buffer where you can write a note on what is about to be recorded.  The
note will appear in a separate buffer while visiting that bookmark (for
its placement see <a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">Window rules and basic tweaks (window.el)</a>).  To skip
annotating the bookmark, just do not insert any text and either kill the
buffer or type <code>C-c C-c</code> to accept the empty annotation.  In such a case,
no buffer will pop up while visiting the bookmark.  Perhaps a less
intrusive alternative is to annotate bookmarks after the fact, through
the <code>list-bookmarks</code> view by typing <code>e</code> with point over the entry of
interest.
</p>

<p>
Speaking of the <code>list-bookmarks</code> view, items with an annotation have an
asterisk prepended to their line.  With point over such a line, type <code>a</code>
to produce a buffer with the contents of the annotation, or <code>A</code> to show
all bookmarks with their annotations or lack thereof.
</p>

<p>
On the presentation front, Emacs28 adds a fringe marker on the line
where a bookmark is set or on the line where you land after visiting a
bookmark.  This is controlled by the variable <code>bookmark-set-fringe-mark</code>.
While my <code>prot-bookmark.el</code> (reproduced after the following package
configurations) defines some extra faces for the <code>list-bookmarks</code> view.
Those help differentiate URLs from files, PDFs, and directories, though
it is a work-in-progress and will likely cover more cases.
</p>

<p>
URL bookmarks are handled by my <code>prot-eww.el</code> extensions, by means of a
custom handler that leverages the standard <code>bookmark.el</code> framework instead
of the EWW-only bookmarking facility that is available by default
(<a href="#h:524bc702-ff55-4ed9-9a38-26d30d64591d">Simple HTML Renderer, Emacs Web Wowser, Elpher, prot-eww.el</a>).
</p>

<p>
Also watch: <a href="https://protesilaos.com/codelog/2021-09-08-emacs-bookmarks-intro/">Primer on Emacs bookmarks</a> (2021-09-08).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Built-in bookmarking framework (bookmark.el and prot-bookmark.el)
(prot-emacs-builtin-package 'bookmark
  (setq bookmark-use-annotations nil)
  (setq bookmark-automatically-show-annotations t)
  (setq bookmark-set-fringe-mark t) ; Emacs28

  (add-hook 'bookmark-bmenu-mode-hook #'hl-line-mode))

(prot-emacs-builtin-package 'prot-bookmark
  (prot-bookmark-extra-keywords 1))
</pre>
</div>

<p>
Here is <code>prot-bookmark.el</code> (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-bookmark.el --- Bookmark extras for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Bookmark extras for my Emacs: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)

(defgroup prot-bookmark ()
  "Bookmark extras for my dotemacs."
  :group 'matching)

;;;; Extend Bookmark menu font-lock

(defface prot-bookmark-url
  '((((class color) (min-colors 88) (background light))
     :foreground "#0000c0")
    (((class color) (min-colors 88) (background dark))
     :foreground "#00bcff")
    (t :foreground "blue"))
  "Face for URL bookmarks.")

(defface prot-bookmark-pdf
  '((((class color) (min-colors 88) (background light))
     :foreground "#7f1010")
    (((class color) (min-colors 88) (background dark))
     :foreground "#ffa0a0")
    (t :foreground "red"))
  "Face for PDF bookmarks.")

(defface prot-bookmark-directory
  '((((class color) (min-colors 88) (background light))
     :foreground "#0f3d8c")
    (((class color) (min-colors 88) (background dark))
     :foreground "#a0acef")
    (t :foreground "cyan"))
  "Face for directory bookmarks.")

;; TODO 2021-09-08: We should be able to filter out bookmarks from the
;; likes of Info and VC-Dir which set a file path even though they are
;; not really intended to be visited as files.
(defconst prot-bookmark-keywords
  `((,(concat "\\(.*\\)" " " prot-common-url-regexp)
     (1 '(bold prot-bookmark-url) t)
     (2 'prot-bookmark-url t))
    ("\\(.*\\)\\( [~/].*\\.pdf\\)"
     (1 '(bold prot-bookmark-pdf) t)
     (2 'prot-bookmark-pdf t))
    ("\\(.*\\)\\( [~/].*/$\\)"
     (1 '(bold prot-bookmark-directory) t)
     (2 'prot-bookmark-directory t))
    ("\\(.*org.*last-stored.*\\)"
     (1 'shadow t)))
  "Extra font-lock patterns for the Bookmark menu.")

;;;###autoload
(define-minor-mode prot-bookmark-extra-keywords
  "Apply extra font-lock rules to bookmark list buffers."
  :init-value nil
  :global t
  (if prot-bookmark-extra-keywords
      (progn
        (font-lock-flush (point-min) (point-max))
        (font-lock-add-keywords nil prot-bookmark-keywords nil)
        (add-hook 'bookmark-bmenu-mode-hook #'prot-bookmark-extra-keywords))
    (font-lock-remove-keywords nil prot-bookmark-keywords)
    (remove-hook 'bookmark-bmenu-mode-hook #'prot-bookmark-extra-keywords)
    (font-lock-flush (point-min) (point-max))))

(provide 'prot-bookmark)
;;; prot-bookmark.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:67b7944e-6398-44a8-91d6-79e423b3e5f1" class="outline-4">
<h4 id="h:67b7944e-6398-44a8-91d6-79e423b3e5f1"><span class="section-number-4">5.1.1.</span> Ibuffer-like bookmark list (blist.el)</h4>
<div class="outline-text-4" id="text-h:67b7944e-6398-44a8-91d6-79e423b3e5f1">
<p>
<i>NOTE 2021-09-16: Work-in-progress.</i>
</p>

<p>
This is a new package by Sévère Durand which makes the listing of
bookmarks look more organised and provides many functions for operating
on them, just like how <code>ibuffer</code> does it:
</p>

<ol class="org-ol">
<li><a href="#h:79cd6177-a81b-420f-8759-e6927b974377">Built-in bookmarking framework (bookmark.el and prot-bookmark.el)</a>.</li>
<li><a href="#h:06290f9c-491c-45b2-b213-0248f890c83d">Ibuffer and extras (dired-like buffer list manager)</a>.</li>
</ol>

<p>
Durand is also the author of the useful <code>rlist</code> package, which lets you
see your registers in a list and, optionally, delete the ones you no
longer need (<a href="#h:aad79917-cd80-491b-9020-db27867ab132">Dired-like list for registers (rlist)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Ibuffer-like bookmark list (blist.el)
;; Project repo: &lt;https://gitlab.com/mmemmew/blist&gt;.  Its dependency is
;; `ilist', by the same author: &lt;https://gitlab.com/mmemmew/blist&gt;.
;;
;; I handle those manually via git, at least until they become available
;; through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-elpa-package 'ilist)

(prot-emacs-elpa-package 'blist
  (setq blist-expert t)
  (setq blist-discard-empty-p t)

  ;; NOTE 2021-09-16: This package is still in its early days.  Things
  ;; will change.
  (with-eval-after-load 'prot-eww
    (blist-define-criterion "eww" "EWW"
      (eq (bookmark-get-handler bookmark)
          #'prot-eww-bookmark-jump)))

  (with-eval-after-load 'prot-eshell
    (blist-define-criterion "eshell" "Eshell"
      (eq (bookmark-get-handler bookmark)
          #'prot-eshell-bookmark-jump)))

  (blist-define-criterion "info" "Info"
    (eq (bookmark-get-handler bookmark)
        #'Info-bookmark-jump))

  (with-eval-after-load 'pdf-tools
    (blist-define-criterion "pdf" "PDF"
      (eq (bookmark-get-handler bookmark)
          #'pdf-view-bookmark-jump-handler)))

  (setq blist-filter-groups
        (list
         (cons "EWW" #'blist-eww-p)
         (cons "Eshell" #'blist-eshell-p)
         (cons "PDF" #'blist-pdf-p)
         (cons "Info" #'blist-info-p)
         (cons "Default" #'blist-default-p)))

  (define-key global-map (kbd "C-x r l") #'blist-list-bookmarks))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:77d14350-978d-4820-ab7f-4641706c445a" class="outline-3">
<h3 id="h:77d14350-978d-4820-ab7f-4641706c445a"><span class="section-number-3">5.2.</span> Custom extensions for "focus mode" (prot-logos.el)</h3>
<div class="outline-text-3" id="text-h:77d14350-978d-4820-ab7f-4641706c445a">
<p>
My <code>prot-logos.el</code> (copied verbatim after the package configurations)
provides the necessary infrastructure for my preferred "focus mode"
aesthetic.  Everything is controlled by <code>prot-logos-focus-mode</code>.  Bind
that to a key and you are good to go.  An overview of its components,
which are contingent on other features:
</p>

<dl class="org-dl">
<dt>Olivetti (centred buffer content)</dt><dd>I spend much of my time in Emacs
reading and writing long form texts.  It is nice to be able to easily
toggle a mode that centres the buffer, allowing for greater comfort.
Olivetti covers that niche very nicely.  It is not aggressive in its
requirements, which is important to play well with my paragraph and
fill-mode settings (<a href="#h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3">Paragraphs and fill-mode (prot-fill.el)</a>): it
respects my existing line length and my preference for auto-filling
text, while it does not introduce any kind of functionality beyond the
scope of bringing the current window's buffer to the centre of the
view.  This is exactly what I need.  Any other enhancement, such as a
larger font size can be delegated to a specialised instrument.  Thanks
to Paul W. Rankin for providing such a nimble tool!  For <code>prot-logos</code>
Olivetti always gets activated.</dd>

<dt><code>variable-pitch-mode</code> (mixed fonts)</dt><dd>This is a built-in mode that
remaps the <code>default</code> face's font family to a proportionately spaced one
(also see <a href="#h:e03b6415-a18f-4058-b9b0-5721d38c6c50">Font configurations (prot-fonts.el)</a>).  It can produce a
prose-friendly presentation, especially if the <code>variable-pitch</code> face is
set to some nice font family.  As the effect is not particularly good
in <code>prog-mode</code> buffers, due to misalignments in spacing and indentation,
<code>prot-logos</code> only applies variable width fonts in <code>text-mode</code> buffers.
The activation is further controlled by <code>prot-logos-variable-pitch</code> (off
by default).  Bear in mind that <code>variable-pitch-mode</code> is quite
aggressive in its application, as it affects all other faces, unless
the active theme (or some minor mode) makes provisions to retain fixed
typographic spacing for those elements that require it, such as code
blocks and inline code elements, tables, and indentation (refer to
<a href="#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">Modus themes (my highly accessible themes)</a>).</dd>

<dt><code>org-tree-slide</code> and <code>org-indent</code></dt><dd>The former is a third-party package
and the latter is part of the Org distribution.  What the first does
is convert headings into pseudo slides.  While the other indents
content visually, without actually affecting the underlying initial
spacing, to match the heading's depth.  Those two are disabled by
default and the <code>prot-logos-org-presentation</code> toggle determines whether
they should be activated.</dd>

<dt>Scroll lock</dt><dd>Sometimes you want the cursor to remain centred on the
screen while your focus is on writing or reading.  This is controlled
by the variable <code>prot-logos-scroll-lock</code> (off by default), which
controls the activation of the built-in <code>scroll-lock-mode</code>.</dd>

<dt>Modeline</dt><dd>The variable <code>prot-logos-hidden-modeline</code> (off by default)
can be set to <code>t</code> to hide the modeline while entering the focused state.
For me this is mostly useful for presentations.</dd>

<dt>Fringes</dt><dd>There is also a function that unconditionally disables
fringes on the edge of the window.  It ensures that we do not see that
area and any indicators that may be placed on it while entering the
focus state (refer to <a href="#h:26a4fac6-33e2-4f6c-8589-9463df8525c9">Fringe mode</a> for the relevant configurations,
while their overall presentation is controlled by the active theme).</dd>

<dt>Cursor</dt><dd>My <code>prot-cursor.el</code> defines some convenient extras for setting
the overall style of the cursor: the shape and the blink rate.  When
in a "focus mode" we may want to have one particular style available,
which differs from the default (for all the technicalities refer to
<a href="#h:cf9086c1-1b33-4127-a716-de94259e14a0">Cursor appearance and tweaks (prot-cursor.el)</a>).</dd>
</dl>

<p>
All those combined contribute to an outcome that is appropriate for long
reading or writing sessions, as well as presentations.  I intentionally
do not introduce any font-resizing effect, as my needs vary in that
regard depending on the context (though do refer to the <code>prot-fonts.el</code> I
linked to earlier).
</p>

<p>
For video demonstrations, albeit with earlier versions of my code, watch
these:
</p>

<ul class="org-ul">
<li><a href="https://protesilaos.com/codelog/2020-07-16-emacs-focused-editing/">“Focused editing” tools for Emacs</a> (2020-07-16)</li>
<li><a href="https://protesilaos.com/codelog/2020-07-17-emacs-mixed-fonts-org/">Configuring mixed fonts for Org mode and others</a> (2020-07-17)</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Custom extensions for "focus mode" (prot-logos.el)
(prot-emacs-builtin-package 'face-remap)

(prot-emacs-elpa-package 'olivetti
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(prot-emacs-elpa-package 'org-tree-slide
  (setq org-tree-slide-breadcrumbs nil)
  (setq org-tree-slide-header nil)
  (setq org-tree-slide-slide-in-effect nil)
  (setq org-tree-slide-heading-emphasis nil)
  (setq org-tree-slide-cursor-init t)
  (setq org-tree-slide-modeline-display nil)
  (setq org-tree-slide-skip-done nil)
  (setq org-tree-slide-skip-comments t)
  (setq org-tree-slide-fold-subtrees-skipped t)
  (setq org-tree-slide-skip-outline-level 8)
  (setq org-tree-slide-never-touch-face t)
  (setq org-tree-slide-activate-message
        (format "Presentation %s" (propertize "ON" 'face 'success)))
  (setq org-tree-slide-deactivate-message
        (format "Presentation %s" (propertize "OFF" 'face 'error)))
  (let ((map org-tree-slide-mode-map))
    (define-key map (kbd "&lt;C-down&gt;") #'org-tree-slide-display-header-toggle)
    (define-key map (kbd "&lt;C-right&gt;") #'org-tree-slide-move-next-tree)
    (define-key map (kbd "&lt;C-left&gt;") #'org-tree-slide-move-previous-tree)))

(prot-emacs-builtin-package 'prot-logos
  (setq prot-logos-org-presentation nil)
  (setq prot-logos-variable-pitch nil)
  (setq prot-logos-scroll-lock nil)
  (setq prot-logos-hidden-modeline t)
  (setq prot-logos-affect-prot-cursor t)
  (define-key global-map (kbd "&lt;f9&gt;") #'prot-logos-focus-mode))
</pre>
</div>

<p>
And here is <code>prot-logos.el</code> in its totality.  It is available as a file in
<a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (same for all my Emacs libraries):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-logos.el --- Extensions for my dotemacs to help read, write, present -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions to help me read, write, present.  For use in my Emacs
;; setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-logos ()
  "Setup for reading and presenting text-heavy buffers."
  :group 'files)

(defcustom prot-logos-org-presentation nil
  "Org files should switch to presentation view.
This concerns cases where variable `prot-logos-focus-mode' is set
to non-nil and determines whether headings should be converted
into pseudo slides and indentation be adjusted accordingly."
  :type 'boolean
  :group 'prot-logos)

(defcustom prot-logos-variable-pitch nil
  "Non-programming buffers should switch to `variable-pitch-mode'.
In programming modes the default font is always used, as that is
assumed to be a monospaced typeface."
  :type 'boolean
  :group 'prot-logos)

(defcustom prot-logos-scroll-lock nil
  "Use centred scrolling while in focused view."
  :type 'boolean
  :group 'prot-logos)

(defcustom prot-logos-hidden-modeline nil
  "Hide the modeline."
  :type 'boolean
  :group 'prot-logos)


(defcustom prot-logos-affect-prot-cursor nil
  "Change the cursor style.
This expects the `prot-cursor.el' library."
  :type 'boolean
  :group 'prot-logos)

(defvar prot-logos--focus-mode-hook nil
  "Hook that runs from function `prot-logos-focus-mode'.")

;;;###autoload
(define-minor-mode prot-logos-focus-mode
  "Buffer-local wrapper mode for presentations.
Other tools should hook into `prot-logos--focus-mode-hook' to
introduce their effects.  Otherwise this minor mode has no effect
on its own."
  :init-value nil
  :global nil
  :lighter " -Λ-"           ; greek lambda majuscule
  (run-hooks 'prot-logos--focus-mode-hook))

(autoload 'buffer-face-mode "face-remap")
(autoload 'variable-pitch-mode "face-remap")

(defun prot-logos--variable-pitch-toggle ()
  "Make text use `variable-pitch' face, except for programming."
  (when (and prot-logos-variable-pitch
             (derived-mode-p 'text-mode))
    (if (or (bound-and-true-p buffer-face-mode)
            (not (bound-and-true-p prot-logos-focus-mode)))
        (variable-pitch-mode -1)
      (variable-pitch-mode 1))))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--variable-pitch-toggle)

(autoload 'olivetti-mode "olivetti")

(defun prot-logos--olivetti-toggle ()
  "Toggle the variable `olivetti-mode', if available."
  (if (or (bound-and-true-p olivetti-mode)
          (not (bound-and-true-p prot-logos-focus-mode)))
      (olivetti-mode -1)
    (olivetti-mode 1)))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--olivetti-toggle)

(defface prot-logos-fringe
  `((((class color) (background light))
     :background "#ffffff")
    (((class color) (background dark))
     :background "#000000")
    (t :background ,(face-attribute 'default :background)))
  "Face to remove background from fringes.
Only tested with the Modus themes.")

(defvar-local prot-logos--fringe-cookie nil
  "Cookie returned by `face-remap-add-relative'.")

(declare-function face-remap-add-relative "face-remap" (face &amp;rest specs))
(declare-function face-remap-remove-relative "face-remap" (cookie))

(defun prot-logos--fringe-toggle ()
  "Toggle fringe visibility."
  (if (bound-and-true-p prot-logos-focus-mode)
      (progn
        (set-window-fringes (selected-window) 0 0)
        (setq prot-logos--fringe-cookie
              (face-remap-add-relative 'olivetti-fringe 'prot-logos-fringe)))
    (set-window-fringes (selected-window) nil)
    (face-remap-remove-relative prot-logos--fringe-cookie)))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--fringe-toggle)

(autoload 'org-tree-slide-mode "org-tree-slide")

(defun prot-logos--org-tree-slide-mode ()
  "Toggle variable `org-tree-slide-mode' if loaded and needed."
  (let* ((buf (window-buffer (get-mru-window)))
         (mode (with-current-buffer buf major-mode)))
    (when (and prot-logos-org-presentation
               (eq mode 'org-mode))
      (if (or (bound-and-true-p org-tree-slide-mode)
              (not (bound-and-true-p prot-logos-focus-mode)))
          (org-tree-slide-mode -1)
        (org-tree-slide-mode 1)))))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--org-tree-slide-mode)

(autoload 'org-indent-mode "org")

(defun prot-logos--org-indent-mode ()
  "Toggle variable `org-tree-slide-mode' if loaded and needed."
  (let* ((buf (window-buffer (get-mru-window)))
         (mode (with-current-buffer buf major-mode)))
    (when (and prot-logos-org-presentation
               (eq mode 'org-mode))
      (if (or (bound-and-true-p org-indent-mode)
              (not (bound-and-true-p prot-logos-focus-mode)))
          (org-indent-mode -1)
        (org-indent-mode 1)))))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--org-indent-mode)

(defun prot-logos--scroll-lock ()
  "Keep the point at the centre."
  (when prot-logos-scroll-lock
    (if (or (bound-and-true-p scroll-lock-mode)
            (not (bound-and-true-p prot-logos-focus-mode)))
        (scroll-lock-mode -1)
      (recenter nil)
      (scroll-lock-mode 1))))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--scroll-lock)

;; Based on Paul W. Rankin's code:
;; https://gist.github.com/rnkn/a522429ed7e784ae091b8760f416ecf8
(defun prot-logos--hidden-modeline ()
  "Toggle mode line visibility."
  (when prot-logos-hidden-modeline
    (if (or (null mode-line-format)
            (not (bound-and-true-p prot-logos-focus-mode)))
        (kill-local-variable 'mode-line-format)
      (setq-local mode-line-format nil)
      (force-mode-line-update))))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--hidden-modeline)

(defvar prot-logos--prot-cursor-preset nil
  "Current `prot-cursor-presets' preset.")

(defvar prot-cursor--style-hist)
(defvar prot-cursor--recovered-preset)
(declare-function prot-cursor-set-cursor "prot-cursor")

(defun prot-logos--prot-cursor-preset ()
  "Change cursor style using `prot-cursor.el'."
  (when prot-logos-affect-prot-cursor
    (if (bound-and-true-p prot-logos-focus-mode)
        (progn
          (cond
           (prot-cursor--style-hist
            (setq prot-logos--prot-cursor-preset
                  (intern (car prot-cursor--style-hist))))
           (prot-cursor--recovered-preset
            (setq prot-logos--prot-cursor-preset
                  prot-cursor--recovered-preset)))
          (prot-cursor-set-cursor 'box))
      (prot-cursor-set-cursor prot-logos--prot-cursor-preset))))

(add-hook 'prot-logos--focus-mode-hook #'prot-logos--prot-cursor-preset)

(provide 'prot-logos)
;;; prot-logos.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:787df548-0d95-4512-a61d-27852198f561" class="outline-3">
<h3 id="h:787df548-0d95-4512-a61d-27852198f561"><span class="section-number-3">5.3.</span> USLS &#x2014; Unassuming Sidenotes of Little Significance</h3>
<div class="outline-text-3" id="text-h:787df548-0d95-4512-a61d-27852198f561">
<p>
NOTE 2021-12-29: USLS is subject to a rewrite.  I have been using it
daily since its inception, though the code needs to be refactored.  As a
proof-of-concept of its utility, check out my <code>invtr</code> (only for curious
hackers, not actual users): <a href="#h:c66a0f25-840a-49f0-a615-66dfca61890b">INVTR (toy inventory and client manager)</a>.
</p>

<p>
This is a library that I am developing to help me flesh out my
note-taking system.  In essence, <code>usls</code> is a set of helper functions
around standard Emacs tools, such as <code>find-file</code>, <code>dired</code>, and internal
libraries like <code>thingatpt</code>.  It has no external dependencies whatsoever.
This blog post of mine documents the principles and general ideas about
it: <a href="https://protesilaos.com/codelog/2020-10-08-intro-usls-emacs-notes/">My simple note-taking system for Emacs (without Org)</a> (2020-10-08).
</p>

<p>
Because this is standard Emacs stuff, I can always benefit from the rest
of my setup, such as to search for file contents in the current
directory.  Study the entirety of my <a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>.
</p>

<p>
In the <code>usls.el</code> code I wanted to respect key binding conventions, so I
did not bind any keys: this is a user-level customisation.  The other
options I have here are for the sake of visibility and are left to their
default values.
</p>

<p>
The code for this project is on the <a href="https://gitlab.com/protesilaos/usls">USLS Gitlab repo</a> and reproduced in
the subsequent code block.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; USLS --- Unassuming Sidenotes of Little Significance
(prot-emacs-builtin-package 'usls
  (setq usls-directory (expand-file-name "~/Documents/notes/"))
  (setq usls-known-categories '("economics" "philosophy" "politics"))
  (setq usls-file-type-extension ".txt") ; {.txt,.org,.md}
  (setq usls-subdir-support nil)
  (setq usls-file-region-separator 'line) ; {'line,'heading, OR string of your choice}
  (setq usls-file-region-separator-heading-level 1)
  (setq usls-custom-header-function nil)

  (add-hook 'usls-mode-hook #'goto-address-mode)

  (let ((map global-map))               ; globally bound keys
    (define-key map (kbd "C-c n d") #'usls-dired)
    (define-key map (kbd "C-c n f") #'usls-find-file)
    (define-key map (kbd "C-c n a") #'usls-append-region-buffer-or-file)
    (define-key map (kbd "C-c n n") #'usls-new-note))
  (let ((map usls-mode-map))            ; only for usls buffers
    (define-key map (kbd "C-c n i") #'usls-id-insert)
    (define-key map (kbd "C-c n l") #'usls-follow-link)))
</pre>
</div>

<p>
Here is the <code>usls.el</code> code, which is also part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (as
with all my Elisp code):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; usls.el --- Unassuming Sidenotes of Little Significance -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://gitlab.com/protesilaos/usls
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Consult the project's README.

;;; Code:

(require 'cl-lib)
(require 'ffap)
(require 'thingatpt)

;;; User-facing options

(defgroup usls ()
  "Simple tool for plain text notes."
  :group 'files
  :prefix "usls-")

(defcustom usls-directory (expand-file-name "~/Documents/notes/")
  "Directory for storing personal notes."
  :group 'usls
  :type 'directory)

(defcustom usls-known-categories '("economics" "philosophy" "politics")
  "List of strings with predefined categories for `usls-new-note'.

The implicit assumption is that a category is a single word.  If
you need a category to be multiple words long, use underscores to
separate them.  Do not use hyphens, as those are assumed to
demarcate distinct categories, per `usls--inferred-categories'.

Also see `usls-categories' for a dynamically generated list that
gets combined with this one in relevant prompts."
  :group 'usls
  :type '(repeat string))

(defcustom usls-subdir-support nil
  "Enable support for subdirectories in `usls-directory'.

The default workflow of USLS is to maintain a flat directory
where all the notes are stored in.  This allows us to omit the
common filesystem path and only show file names.

When set to non-nil, the USLS workflow can handle subdirectories
at the expense of making all file names more verbose, as it needs
to include the complete path.

NOTE: such subdirectories must be created manually to make sure
that no destructive filesystem operations are performed by
accident."
  :group 'usls
  :type 'boolean)

(defcustom usls-file-type-extension ".txt"
  "File type extension for new USLS notes.

Available options cover plain text (.txt), Markdown (.md), and
Org (.org) formats."
  :group 'usls
  :type '(choice
          (const :tag "Plain text format" ".txt")
          (const :tag "Markdown format" ".md")
          (const :tag "Org format" ".org")))

(defcustom usls-file-region-separator 'line
  "Separator for `usls-new-note' delimiting the captured region.

The default value of 'line' produces a horizontal rule depending
on the `usls-file-type-extension'.

* For plain text and Markdown this results in the following
  string (without the quotes): '\\n\\n* * *\\n\\n'.  It means to put
  two new lines before and two after the three space-separated
  asterisks.  In practice, that means an empty line before and
  after.  This notation is a common way to denote a horizontal
  rule or page/section break and is a standard in Markdown.

* For Org files it produces five consecutive hyphens with
  newlines before and after ('\\n\\n-----\\n\\n').  This is the
  valid syntax for a horizontal rule in Org mode.

Option 'heading' produces a heading that is formatted according
to `usls-file-type-extension'.  Its text is 'Reference':

* For plain text, the formatting of the heading involves a series
  of hyphens below the heading's text, followed by an empty line.
  The length of the hyphens is equal to that of the heading's
  text.

* For Markdown and Org the heading is formatted per the
  respective major mode's syntax, plus an empty line before and
  after.

It is also possible to provide a string of your own.  This should
contain just the text that you wish to turn into a heading.  For
example, you want to use the word 'Captured region' instead of
'Reference', so provide only that.  Your input will be processed
according to `usls-file-type-extension' to offer the correct
heading format.  The result will mimic that of the aforementioned
options.

The level of the heading is controlled by the customisation
option `usls-file-region-separator-heading-level' and defaults to
1 (one # for Markdown or one * for Org)."
  :group 'usls
  :type '(choice
          (const :tag "Line with surrounding space (default)" line)
          (const :tag "A 'Reference' heading" heading)
          (string :tag "A heading with text of your choice")))

(defcustom usls-file-region-separator-heading-level 1
  "Heading level for `usls-file-region-separator'.
Has effect when `usls-file-type-extension' is either that of
Markdown or Org types."
  :group 'usls
  :type 'integer)

(defcustom usls-custom-header-function nil
  "Function to format headers for new files (EXPERIMENTAL!!!).

It should accept five arguments and catenate them as a string,
preferably with the appropriate new lines in place.  The
arguments are: title, date, categories, filename, id.  Those are
supplied by `usls-new-note'.

While all five arguments will be passed to this function, not all
of them need to be part of the output.  Users may prefer, for
example, to only include a title, a date, and a category.

For ideas on how to format such a function, refer to the source
code of `usls--file-meta-header'.

Although this customisation can be set globally, another viable
use-case is to `let' bind it in wrapper functions around
`usls-new-note'.  In that scenario, it could be desirable to also
set the value of `usls-file-type-extension', so as to generate a
different type of note than the default: such as to write
something in '.tex' while the default extension remains intact.
In this case, users are expected to define a wrapper for
`usls-new-note' like this (without the backslashes that appear in
the source of this docstring):

  (defun my-usls-new-note-for-tex ()
    (let ((usls-file-type-extension \".tex\")
          (usls-custom-header-function #'my-usls-custom-header))
      (usls-new-note)))"
  :group 'usls
  :type '(choice (const nil) function))

;;; Main variables

(defconst usls-id "%Y%m%d_%H%M%S"
  "Format of ID prefix of a note's filename.")

(defconst usls-id-regexp "\\([0-9_]+\\{15\\}\\)"
  "Regular expression to match `usls-id'.")

(defconst usls-category-regexp "\\(--\\)\\([0-9A-Za-z_+]*\\)\\(--\\)"
  "Regular expression to match `usls-categories'.")

(defconst usls-file-regexp
  (concat usls-id-regexp usls-category-regexp "\\(.*\\)\\.\\(txt\\|md\\|org\\)")
  "Regular expression to match file names from `usls-new-note'.")

(defvar usls--file-link-regexp "^\\(@@\\|\\^^\\) \\(.*\\.\\)\\(txt\\|md\\|org\\)"
  "Regexp for file links.")

;;;; Input history lists

(defvar usls--title-history '()
  "Used internally by `usls-new-note' to record titles.")

(defvar usls--category-history '()
  "Used internally by `usls-new-note' to record categories.")

(defvar usls--file-history '()
  "Used internally by `usls-find-file' to record file names.")

(defvar usls--link-history '()
  "Used internally by `usls-id-insert' to record links.")

(defvar usls--subdirectory-history '()
  "Used internally by `usls-new-note' to record subdirectories.")

;;; Basic utilities

;; Contributed by Omar Antolín Camarena in another context:
;; &lt;https://github.com/oantolin&gt;.
(defun usls--completion-table (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category))
      (complete-with-action action candidates string pred))))

(defvar crm-separator)

;; Contributed by Igor Lima in another context :
;; &lt;https://github.com/0x462e41&gt;.
(defun usls-crm-exclude-selected-p (input)
  "Filter out INPUT from `completing-read-multiple'.
Hide non-destructively the selected entries from the completion
table, thus avoiding the risk of inputting the same match twice.

To be used as the PREDICATE of `completing-read-multiple'."
  (if-let* ((pos (string-match-p crm-separator input))
            (rev-input (reverse input))
            (element (reverse
                      (substring rev-input 0
                                 (string-match-p crm-separator rev-input))))
            (flag t))
      (progn
        (while pos
          (if (string= (substring input 0 pos) element)
              (setq pos nil)
            (setq input (substring input (1+ pos))
                  pos (string-match-p crm-separator input)
                  flag (when pos t))))
        (not flag))
    t))

(defvar usls-mode)

(defun usls--barf-non-text-usls-mode ()
  "Throw error if not in a proper USLS buffer."
  (unless (and usls-mode (derived-mode-p 'text-mode))
    (user-error "Not in a writable USLS buffer; aborting")))

;;;; File name helpers

(defun usls--directory ()
  "Valid name format for `usls-directory'."
  (file-name-as-directory usls-directory))

(defun usls--extract (regexp str &amp;optional group)
  "Extract REGEXP from STR, with optional regexp GROUP."
  (when group
    (unless (and (integerp group) (&gt; group 0))
      (error "`%s' is not a positive integer" group)))
  (with-temp-buffer
    (insert str)
    (when (re-search-forward regexp nil t -1)
      (match-string (or group 1)))))

(defvar usls--punctuation-regexp "[][{}!@#$%^&amp;*()_=+'\"?,.\|;:~`‘’“”]*"
  "Regular expression of punctionation that should be removed.")

(defun usls--slug-no-punct (str)
  "Convert STR to a file name slug."
  (replace-regexp-in-string usls--punctuation-regexp "" str))

(defun usls--slug-hyphenate (str)
  "Replace spaces with hyphens in STR.
Also replace multiple hyphens with a single one and remove any
trailing hyphen."
  (replace-regexp-in-string
   "-$" ""
   (replace-regexp-in-string
    "-\\{2,\\}" "-"
    (replace-regexp-in-string "--+\\|\s+" "-" str))))

(defun usls--sluggify (str)
  "Make STR an appropriate file name slug."
  (downcase (usls--slug-hyphenate (usls--slug-no-punct str))))

;;;; Files in directory

(defun usls--directory-files-flat (&amp;optional directory)
  "List `usls-directory' files, assuming flat directory.
With optional DIRECTORY, find files there, else use
`usls--directory'."
  (let ((dotless directory-files-no-dot-files-regexp)
        (dir (or directory (usls--directory))))
    (cl-remove-if
     (lambda (x)
       ;; TODO: generalise this for all VC backends?  Which ones?
       (or (string-match-p "\\.git" x)
           (file-directory-p x)))
     (directory-files dir nil dotless t))))

(defun usls--directory-files-recursive ()
  "List `usls-directory' files, assuming directory tree."
    (cl-remove-if
     (lambda (x)
       ;; TODO: generalise this for all VC backends?  Which ones?
       (string-match-p "\\.git" x))
     (directory-files-recursively (usls--directory) ".*" nil t)))

(defun usls--make-directory (directory)
  "Make DIRECTORY, if missing."
  (let ((path directory))
    (unless (file-directory-p path)
      (make-directory path t))))

(defun usls--directory-files (&amp;optional directory)
  "List directory files.
With optional DIRECTORY, specify path for
`usls--directory-files-flat'."
  (usls--make-directory (usls--directory))
  (if usls-subdir-support
      (usls--directory-files-recursive)
    (usls--directory-files-flat directory)))

(defun usls--directory-subdirs ()
  "Return list of subdirectories in `usls-directory'."
  (cl-remove-if-not
   (lambda (x)
     (file-directory-p x))
   (directory-files-recursively (usls--directory) ".*" t t)))

;; TODO: generalise this for all VC backends?  Which ones?
(defun usls--directory-subdirs-no-git ()
  "Remove .git directories from `usls--directory-subdirs'."
  (cl-remove-if
   (lambda (x)
     (string-match-p "\\.git" x))
   (usls--directory-subdirs)))

(defun usls--directory-subdirs-completion-table (dirs)
  "Match DIRS as a completion table."
  (let ((def (car usls--subdirectory-history))
        (table (usls--completion-table 'file dirs)))
    (completing-read
     (format "Subdirectory of new note [%s]: " def)
     table nil t nil 'usls--subdirectory-history def)))

(defun usls--directory-subdirs-prompt ()
  "Handle user input on choice of subdirectory."
  (let* ((subdirs
          (if (null (usls--directory-subdirs-no-git))
              (user-error "No subdirs in `%s'; create them manually"
                          (usls--directory))
            (usls--directory-subdirs-no-git)))
         (choice (usls--directory-subdirs-completion-table subdirs))
         (subdir (file-truename choice)))
    (add-to-history 'usls--subdirectory-history choice)
    subdir))

;;;; Categories

(defun usls--categories-in-files ()
  "Produce list of categories in `usls--directory-files'."
  (delq nil
   (mapcar (lambda (x)
             (usls--extract (concat usls-id-regexp usls-category-regexp) x 3))
           (usls--directory-files))))

(defun usls--inferred-categories ()
  "Extract categories from `usls--directory-files'."
  (let ((sequence (usls--categories-in-files)))
    (mapcan (lambda (s)
              (split-string s "+" t))
            sequence)))

(defun usls-categories ()
  "Combine `usls--inferred-categories' with `usls-known-categories'."
  (delete-dups (append (usls--inferred-categories) usls-known-categories)))

(defun usls--categories-prompt ()
  "Prompt for one or more categories.
In the case of multiple entries, those are separated by the
`crm-sepator', which typically is a comma.  In such a case, the
output is sorted with `string-lessp'."
  (let* ((categories (usls-categories))
         (choice (completing-read-multiple
                  "File category: " categories
                  #'usls-crm-exclude-selected-p
                  nil nil 'usls--category-history)))
    (if (= (length choice) 1)
        (car choice)
      (sort choice #'string-lessp))))

(defun usls--categories-combine (categories)
  "Format CATEGORIES output of `usls--categories-prompt'."
  (if (and (&gt; (length categories) 1)
           (not (stringp categories)))
      (mapconcat #'downcase categories "+")
    categories))

(defun usls--categories-capitalize (categories)
  "`capitalize' CATEGORIES output of `usls--categories-prompt'."
  (if (and (&gt; (length categories) 1)
           (not (stringp categories)))
      (mapconcat #'capitalize categories ", ")
    (capitalize categories)))

(defun usls--categories-add-to-history (categories)
  "Append CATEGORIES to `usls--category-history'."
  (if (and (listp categories)
           (&gt; (length categories) 1))
      (let ((cats (delete-dups
                   (mapc (lambda (cat)
                           (split-string cat "," t))
                         categories))))
        (mapc (lambda (cat)
                (add-to-history 'usls--category-history cat))
              cats)
        (setq usls--category-history
              (cl-remove-if (lambda (x)
                              (string-match-p crm-separator x))
                            usls--category-history)))
    (add-to-history 'usls--category-history categories)))

;;; Templates

(defun usls--file-meta-header (title date categories filename id)
  "Front matter template based on `usls-file-type-extension'.

This helper function is meant to integrate with `usls-new-note'.
As such TITLE, DATE, CATEGORIES, FILENAME, ID are all retrieved
from there."
  (let ((cat (usls--categories-capitalize categories)))
    (pcase usls-file-type-extension
      ;; TODO: make those templates somewhat customisable.  We need to
      ;; determine what should be parametrised.
      (".md" `(concat "---" "\n"
                      "title:     " ,title "\n"
                      "date:      " ,date "\n"
                      "category:  " ,cat "\n"
                      "orig_name: " ,filename "\n"
                      "orig_id:   " ,id "\n"
                      "---" "\n\n"))
      (".org" `(concat "#+title:     " ,title "\n"
                       "#+date:      " ,date "\n"
                       "#+category:  " ,cat "\n"
                       "#+orig_name: " ,filename "\n"
                       "#+orig_id:   " ,id "\n\n"))
      (_ `(concat "title:     " ,title "\n"
                  "date:      " ,date "\n"
                  "category:  " ,cat "\n"
                  "orig_name: " ,filename "\n"
                  "orig_id:   " ,id "\n"
                  (make-string 26 ?-) "\n\n")))))

(defun usls--file-region-separator-heading-level (mark str)
  "Format MARK and STR for `usls--file-region-separator-str'.
MARK must be a single character string.  For multiple character
strings only the first one is used."
  (let ((num usls-file-region-separator-heading-level)
        (char (when (stringp mark)
                (string-to-char (substring mark 0 1)))))
    (format "\n\n%s %s\n\n" (make-string num char) str)))

(defun usls--file-region-separator-str ()
  "Produce region delimiter string for use in `usls-new-note'."
  (let* ((str (format "%s" usls-file-region-separator))
         (num (length str)))
    (pcase usls-file-region-separator
      ('line (pcase usls-file-type-extension
               (".org" (format "\n\n%s\n\n" (make-string 5 ?-)))
               (_ "\n\n* * *\n\n")))
      ('heading (pcase usls-file-type-extension
                  (".md" (usls--file-region-separator-heading-level "#" "Reference"))
                  (".org" (usls--file-region-separator-heading-level "*" "Reference"))
                  (_ (format "\n\nReference\n%s\n\n" (make-string 9 ?-)))))
      (_ (pcase usls-file-type-extension
           (".md" (usls--file-region-separator-heading-level "#" str))
           (".org" (usls--file-region-separator-heading-level "*" str))
           (_ (format "\n\n%s\n%s\n\n" str (make-string num ?-))))))))

;; This just silences the compiler for the subsequent function
(defvar eww-data)

;; TODO: get some link for gnus, mu4e?  What else?
(defun usls--file-region-source ()
  "Capture path to file or URL for `usls--file-region'."
  (cond
   ((derived-mode-p 'eww-mode)
    (if (plist-get eww-data :title)
        (format "%s &lt;%s&gt;\n\n" (plist-get eww-data :title) (plist-get eww-data :url))
      (concat (plist-get eww-data :url) "\n\n")))
   ((buffer-file-name)
    (concat (buffer-file-name) "\n\n"))
   (t
    "")))

(defun usls--file-region-separator (region)
  "`usls--file-region-separator-str' and `usls-new-note' REGION."
  `(concat
    (usls--file-region-separator-str)
    (usls--file-region-source)
    ,region))

(defun usls--file-region ()
  "Capture active region for use in `usls-new-note'."
  (if (use-region-p)
      (eval (usls--file-region-separator
             (buffer-substring-no-properties
              (region-beginning)
              (region-end))))
    ""))

(defun usls--file-region-append ()
  "Capture active region for use in `usls-append-region-buffer-or-file'."
  (if (use-region-p)
      (eval (buffer-substring-no-properties
             (region-beginning)
             (region-end)))
    ""))

;;; Commands and their helper functions

;;;; New note

(defun usls--format-file (path id categories slug extension)
  "Helper for `usls-new-note' to format file names.
PATH, ID, CATEGORIES, SLUG, AND EXTENSION are expected to be
supplied by `usls-new-note': they will all be converted into a
single string."
  (format "%s%s--%s--%s%s"
          path
          id
          categories
          slug
          extension))

;;;###autoload
(defun usls-new-note (&amp;optional arg)
  "Create new note with the appropriate metadata and file name.
If the region is active, append it to the newly created file.

This command first prompts for a file title and then for a
category.  The latter supports completion.

To input multiple categories, separate them with a comma or
whatever the value of `crm-separator' is on your end.  While
inputting multiple categories, those already selected are removed
from the list of completion candidates, meaning that it is not
possible to select the same item twice.

With prefix key (\\[universal-argument]) as optional ARG also
prompt for a subdirectory of `usls-directory' to place the new
note in.  Subdirectories must already exist."
  (interactive "P")
  (let* ((subdir (when arg (usls--directory-subdirs-prompt)))
         (title (read-string "File title: " nil 'usls--title-history))
         (categories (usls--categories-prompt))
         (slug (usls--sluggify title))
         (path (file-name-as-directory (or subdir usls-directory)))
         (id (format-time-string usls-id))
         (filename (usls--format-file path id
                    (usls--categories-combine categories)
                    slug usls-file-type-extension))
         (date (format-time-string "%F"))
         (region (usls--file-region)))
    (with-current-buffer (find-file filename)
      (insert (eval (if usls-custom-header-function
                        (funcall usls-custom-header-function title date
                                 categories filename id)
                      (usls--file-meta-header title date categories filename id))))
      (save-excursion (insert region)))
    (add-to-history 'usls--title-history title)
    (usls--categories-add-to-history categories)))

(defun usls--directory-files-not-current ()
  "Return list of files minus the current one."
  (cl-remove-if
   (lambda (x)
     (if usls-subdir-support
         (string= (abbreviate-file-name (buffer-file-name)) x)
       (string= (file-name-nondirectory (buffer-file-name)) x)))
   (usls--directory-files)))

;;;; Insert reference

(defun usls--insert-file-reference (file delimiter)
  "Insert formatted reference to FILE with DELIMITER."
  (save-excursion
    (goto-char (point-max))
    (newline 1)
    (insert
     (format "%s %s\n" delimiter file))))

(defun usls--delete-duplicate-links ()
  "Remove duplicate references to files."
  (delete-duplicate-lines
   (save-excursion
     (goto-char (point-min))
     (search-forward-regexp "\\(@@\\|\\^\\^\\) " nil t nil))
   (point-max)))

;;;###autoload
(defun usls-id-insert ()
  "Insert at point the identity of a file using completion."
  (interactive)
  (usls--barf-non-text-usls-mode)
  (let* ((files (usls--completion-table 'file (usls--directory-files-not-current)))
         (file (completing-read "Link to: " files nil t nil 'usls--link-history))
         (this-file (file-name-nondirectory (buffer-file-name)))
         (id (usls--extract usls-id-regexp file)))
    (insert (concat "^" id))
    (usls--insert-file-reference (format "%s" file) "^^")
    (with-current-buffer (find-file-noselect file)
      (save-excursion
        (usls--insert-file-reference this-file "@@")
        (usls--delete-duplicate-links))
      (save-buffer)
      (kill-buffer))
    (usls--delete-duplicate-links)
    (add-to-history 'usls--link-history file)))


;;;; Follow links

(defun usls--links ()
  "Gather links to files in the current buffer."
  (let ((links))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp usls--file-link-regexp nil t)
        (push
         (concat (match-string-no-properties 2)
                 (match-string-no-properties 3))
         links)))
    (cl-remove-duplicates links)))

;;;###autoload
(defun usls-follow-link ()
  "Visit link referenced in the note using completion.
If no links are available, call `usls-find-file'."
  (interactive)
  (usls--barf-non-text-usls-mode)
  (let* ((default-directory (usls--directory))
         (links (usls--links))
         (refs (when links (usls--completion-table 'file links))))
    (if refs
        (find-file
         (completing-read "Follow link: " refs nil t))
      (call-interactively 'usls-find-file))))

;;;; Find file

(defun usls--file-name (file)
  "Return properly formatted name of FILE."
  (if usls-subdir-support
     (file-truename file)
    (file-truename (concat (usls--directory) file))))

(defun usls--find-file-prompt ()
  "Completion prompt for `usls-find-file'."
  (let ((files (usls--completion-table 'file (usls--directory-files))))
    (completing-read "Visit file: " files nil t nil 'usls--file-history)))

;;;###autoload
(defun usls-find-file (file)
  "Visit a FILE in `usls-directory'.
When called interactively use completion."
  (interactive (list (usls--find-file-prompt)))
  (let* ((default-directory (usls--directory))
         (item (usls--file-name file)))
    (find-file item)
    (add-to-history 'usls--file-history file)))

;;;; Append to file

;; REVIEW: Maybe all those filtered lists can be simplified into maybe
;; one or two.  This feels needlessly complex.

(defun usls--window-buffer-list ()
  "Return list of windows."
  (mapcar (lambda (x)
            (window-buffer x))
          (window-list)))

(defun usls--window-buffer-file-names-list ()
  "Return file names in `usls--window-buffer-list'."
  (delq nil
   (mapcar (lambda (x)
             (buffer-file-name x))
           (usls--window-buffer-list))))

(defun usls--window-usls-file-buffers ()
  "Return USLS files in `usls--window-buffer-file-names-list'."
  (let ((files (usls--directory-files-recursive))
        (buf-files (mapcar #'abbreviate-file-name (usls--window-buffer-file-names-list))))
    (delq nil
     (mapcar (lambda (x)
               (when (member x files)
                 x))
             buf-files))))

(defun usls--window-usls-buffers ()
  "Return buffer names from `usls--window-usls-file-buffers'."
  (mapcar (lambda (x)
            (get-file-buffer x))
          (usls--window-usls-file-buffers)))

(defun usls--window-buffers-live ()
  "Return live windows matching `usls--window-usls-buffers'."
  (cl-remove-if-not (lambda (x)
                      (window-live-p x))
                    (mapcar (lambda (y)
                              (get-buffer-window y))
                            (usls--window-usls-buffers))))

(defun usls--window-buffers ()
  "Return buffer names in `usls--window-buffers-live'."
  (mapcar (lambda (x)
            (window-buffer x))
          (usls--window-buffers-live)))

(defun usls--window-single-buffer-or-prompt ()
  "Return buffer name if one, else prompt with completion."
  (let* ((buffers
          (delete-dups
           (mapcar (lambda (x)
                     (format "%s" x))
                   (usls--window-buffers))))
         (bufs (usls--completion-table 'buffer buffers))
         (buf (if (&gt; (length buffers) 1)
                  (completing-read "Pick buffer: "
                                   bufs nil t)
                (if (listp buffers) (car buffers) buffers))))
    (unless (null buf)
      (get-buffer-window buf))))

(defun usls--window-buffer-or-file ()
  "Return window with a USLS buffer or prompt for a file."
  (let ((files (usls--directory-files)))
    (or (usls--window-single-buffer-or-prompt)
        (completing-read "Visit file: " files nil t nil 'usls--file-history))))

(defun usls--append-region (buf region arg)
  "Routines to append active region.
All of BUF, REGION, ARG are intended to be passed by another
function, such as with `usls-append-region-buffer-or-file'."
  (let ((window (get-buffer-window buf))
        (mark (gensym)))
    (with-current-buffer buf
      (goto-char (if (not (null arg)) (point-max) (window-point window)))
      (setq mark (point))
      (insert region)
      (goto-char mark))))

;;;###autoload
(defun usls-append-region-buffer-or-file (&amp;optional arg)
  "Append active region to buffer or file.

To 'append' is to insert at point.  To insert at the end of text
instead, pass a \\[universal-argument] prefix argument ARG.

If there exist one or more windows whose buffers visit a file
found in `usls-directory', then they are used as targets for
appending the active region.  When multiple windows are
available, a minibuffer prompt with completion is provided to
select one among them.

When no such windows are live, the minibuffer prompt asks for a
file to visit.

The appended region is not preceded by a delimiter, as is the
case with `usls-new-note'."
  (interactive "P")
  (let* ((object (usls--window-buffer-or-file))
         (buf (when (windowp object) (window-buffer object)))
         (region (usls--file-region-append))
         (append (if arg t nil)))
    (if (bufferp buf)
        (usls--append-region buf region append)
      (usls--append-region (find-file (usls--file-name object)) region append)
      ;; Only add to history when we are dealing with a file
      (add-to-history 'usls--file-history object))))

;;;; Dired

;;;###autoload
(defun usls-dired (&amp;optional arg)
  "Switch to `usls-directory' using `dired'.
With optional \\[universal-argument] prefix ARG prompt for a usls
subdirectory to switch to.  If none is available, the main
directory will be directly displayed instead."
  (interactive "P")
  (let ((path usls-directory)
        (subdirs (usls--directory-subdirs-no-git)))
    (unless (file-directory-p path)
      (user-error "`usls-directory' not found at %s" usls-directory))
    (if (and arg subdirs)
        (dired (usls--directory-subdirs-prompt))
      (dired path))))

;;; User-facing setup

(defvar usls-mode-map
  (let ((map (make-sparse-keymap)))
    map)
  "Key map for use when USLS mode is active.")

(define-minor-mode usls-mode
  "Extras for working with `usls' notes.

\\{usls-mode-map}"
  :init-value nil
  :global nil
  :lighter " usls"
  :keymap usls-mode-map)

(defun usls-mode-activate ()
  "Activate mode when inside `usls-directory'."
  (when (or (string-match-p (expand-file-name usls-directory) default-directory)
            (string-match-p (abbreviate-file-name usls-directory) default-directory)
            (string-match-p usls-directory default-directory))
      (usls-mode 1)))

(add-hook 'find-file-hook #'usls-mode-activate)
(add-hook 'dired-mode-hook #'usls-mode-activate)

(defgroup usls-faces ()
  "Faces for USLS mode."
  :group 'faces)

(defface usls-header-data-date
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#2544bb")
    (((class color) (min-colors 88) (background dark))
     :foreground "#79a8ff")
    (t :inherit font-lock-string-face))
  "Face for header date entry.")

(defface usls-header-data-category
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#5317ac")
    (((class color) (min-colors 88) (background dark))
     :foreground "#b6a0ff")
    (t :inherit font-lock-keyword-face))
  "Face for header category entry.")

(defface usls-header-data-title
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#8f0075")
    (((class color) (min-colors 88) (background dark))
     :foreground "#f78fe7")
    (t :inherit font-lock-builtin-face))
  "Face for header title entry.")

(defface usls-header-data-secondary
  '((((class color) (min-colors 88) (background light))
     :foreground "#61284f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#fbd6f4")
    (t :inherit (bold shadow)))
  "Face for secondary header information.")

(defface usls-header-data-key
  '((((class color) (min-colors 88) (background light))
     :foreground "#00538b")
    (((class color) (min-colors 88) (background dark))
     :foreground "#00d3d0")
    (t :inherit font-lock-variable-name-face))
  "Face for secondary header information.")

(defface usls-section-delimiter
  '((((class color) (min-colors 88) (background light))
     :background "#d7d7d7" :foreground "#404148")
    (((class color) (min-colors 88) (background dark))
     :background "#323232" :foreground "#bfc0c4")
    (t :inherit shadow))
  "Face for section delimiters.")

(defface usls-dired-field-date
  '((((class color) (min-colors 88) (background light))
     :foreground "#005077")
    (((class color) (min-colors 88) (background dark))
     :foreground "#90c4ed")
    (t :inherit font-lock-variable-name-face))
  "Face for file name date in `dired-mode' buffers.")

(defface usls-dired-field-delimiter
  '((t :inherit shadow))
  "Face for file name field delimiters in `dired-mode' buffers.")

(defface usls-dired-field-category
  '((((class color) (min-colors 88) (background light))
     :foreground "#5317ac")
    (((class color) (min-colors 88) (background dark))
     :foreground "#b6a0ff")
    (t :inherit font-lock-keyword-face))
  "Face for file name category in `dired-mode' buffers.")

(defface usls-dired-field-name
  '((((class color) (min-colors 88) (background light))
     :foreground "#000000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#ffffff")
    (t :inherit default))
  "Face for file name title in `dired-mode' buffers.")

;; TODO: re-use regular expressions as is already done for
;; `usls-file-regexp'.
(defconst usls-font-lock-keywords
  `((,usls-file-regexp
     (1 'usls-dired-field-date)
     (2 'usls-dired-field-delimiter)
     (3 'usls-dired-field-category)
     (4 'usls-dired-field-delimiter)
     (5 'usls-dired-field-name)
     (6 'usls-dired-field-delimiter))
    ("\\(title:\\) \\(.*\\)"
     (1 'usls-header-data-key)
     (2 'usls-header-data-title))
    ("\\(date:\\) \\(.*\\)"
     (1 'usls-header-data-key)
     (2 'usls-header-data-date))
    ("\\(category:\\) \\(.*\\)"
     (1 'usls-header-data-key)
     (2 'usls-header-data-category))
    ("\\(orig_\\(name\\|id\\):\\) \\(.*\\)"
     (1 'usls-header-data-key)
     (2 'usls-header-data-key)
     (3 'usls-header-data-secondary t))
    ("^\\(-\\{26\\}\\|[*\s]\\{5\\}\\)$"
     (1 'usls-section-delimiter))
    ("\\(\\^\\)\\([0-9_]\\{15\\}\\)"
     (1 'escape-glyph)
     (2 'font-lock-variable-name-face))
    (,usls--file-link-regexp
     (1 'escape-glyph)
     (2 'font-lock-constant-face t)
     (3 'font-lock-constant-face t)))
  "Rules to apply font-lock highlighting with `usls--fontify'.")

(defun usls--fontify ()
  "Font-lock setup for `usls-font-lock-keywords'."
  (font-lock-flush (point-min) (point-max))
  (if usls-mode
      (font-lock-add-keywords nil usls-font-lock-keywords t)
    (font-lock-remove-keywords nil usls-font-lock-keywords))
  (font-lock-flush (point-min) (point-max)))

(add-hook 'usls-mode-hook #'usls--fontify)

(provide 'usls)

;;; usls.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:c66a0f25-840a-49f0-a615-66dfca61890b" class="outline-3">
<h3 id="h:c66a0f25-840a-49f0-a615-66dfca61890b"><span class="section-number-3">5.4.</span> INVTR (toy inventory and client manager)</h3>
<div class="outline-text-3" id="text-h:c66a0f25-840a-49f0-a615-66dfca61890b">
<p>
I am intentionally not documenting this because it is not intended for
public use.  It is a <b>highly experimental proof-of-concept</b> of a nimble
inventory and client manager that extends the file-naming methodology of
my USLS (see <a href="#h:787df548-0d95-4512-a61d-27852198f561">USLS &#x2014; Unassuming Sidenotes of Little Significance</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; INVTR (toy inventory and client manager)
;; DO NOT USE THIS!!!
(prot-emacs-builtin-package 'invtr)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; invtr.el --- INVTR Needn't Vindicate Thorough Rationalists -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos/emacs/invtr
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; INVTR or "Inventory" or else "INVTR Needn't Vindicate Thorough
;; Rationalists" is toy of an inventory management setup that handles
;; the creation of entries and the recording of data within them.  It
;; does not reinvent grep, find, dired, and friends.  Just use those.
;; Instead, it relies on a structured file format that is easy to target
;; with regular expressions.  INVTR extends USLS, which is another toy
;; program of mine.  Read the USLS documentation about the file format
;; and the general workflow (I might do a comprehensive video one day).
;;
;; The target audience of INVTR is small business owners who want to go
;; bankrupt.  Seriously though, DON'T USE THIS HIGHLY EXPERIMENTAL
;; PROGRAM.  I might turn it into a useful package at some point, either
;; on its own or by rewriting USLS, but until then DO NOT USE THIS.  I
;; am just coming up with reasons to play with Elisp.
;;
;; The URL noted above does not exist yet.  Will add it when/if I think
;; this can be remotely useful.

;;; Code:

(require 'usls)

;; TODO 2021-12-26: Make this a `defcustom'.
(defvar invtr-directory (expand-file-name "~/Documents/inventory/"))

(defun invtr--directory ()
  "Valid name format for `invtr-directory'."
  (file-name-as-directory invtr-directory))

;; TODO 2021-12-26: Make this a `defcustom'.
(defvar invtr-known-categories
  '("plastic" "metal" "wood" "glass")
  "List of user-defined categories.
Note that `invtr-new-record' can accept an arbitrary category
and that categories are inferred from existing files, all of
which are available for completion.")

(defvar invtr--title-history '())
(defvar invtr--cost-history '())
(defvar invtr--discount-history '())
(defvar invtr--productID-history '())
(defvar invtr--producer-history '())
(defvar invtr--producer-history '())
(defvar invtr--price-history '())
(defvar invtr--quantity-history '())
(defvar invtr--dimensions-history '())
(defvar invtr--weight-history '())

(defun invtr--file-name-construction (path id categories slug dimensions weight price)
  "Construct file name of `invtr-new-record'.
Catenate PATH, ID, CATEGORIES, SLUG, DIMENSIONS, WEIGHT, PRICE in
this order.  The dimensions and weight can be nil, both at once
or separately.  In that case the constructed name will omit their
corresponding fields."
  (let ((cats (usls--categories-combine categories))
        (ext usls-file-type-extension)
        (dimensions-p (and dimensions (not (string-empty-p dimensions))))
        (weight-p (and weight (not (string-empty-p weight)))))
    (cond
     ((and dimensions-p weight-p)
      (format "%s%s--%s--%s--%s--%s--%s%s"
              path id cats slug dimensions weight price ext))
     (dimensions-p
      (format "%s%s--%s--%s--%s--%s%s"
              path id cats slug dimensions price ext))
     (weight-p
      (format "%s%s--%s--%s--%s--%s%s"
              path id cats slug weight price ext))
     (t
      (format "%s%s--%s--%s--%s%s"
              path id cats slug price ext)))))

;; ;; Test for the above:
;; (let ((path "0")
;;       (id "1")
;;       (categories "2")
;;       (slug "3")
;;       (dimensions "4")
;;       (weight "5")
;;       (price "6"))
;;   (invtr--file-name-construction path id categories slug dimensions weight price))

;; NOTE 2021-12-27: Copied from my prot-common.el
(defun invtr-percentage-change (n-original n-final)
  "Find percentage change between N-ORIGINAL and N-FINAL numbers.

When the percentage is not an integer, it is rounded to 4
floating points: 16.666666666666664 =&gt; 16.667."
  (unless (numberp n-original)
    (user-error "N-ORIGINAL must satisfy numberp"))
  (unless (numberp n-final)
    (user-error "N-FINAL must satisfy numberp"))
  (let* ((difference (float (abs (- n-original n-final))))
         (n (* (/ difference n-original) 100))
         (round (floor n)))
    (if (&gt; n round) (string-to-number (format "%0.4f" n)) round)))

;; NOTE 2021-12-27: Copied from my prot-common.el
(defun invtr-reverse-percentage (number percent change-p)
  "Determine the original value of NUMBER given PERCENT.

CHANGE-P should specify the increase or decrease.  For simplicity,
nil means decrease while non-nil stands for an increase.

NUMBER must satisfy `numberp', while PERCENT must be `natnump'."
  (unless (numberp number)
    (user-error "NUMBER must satisfy numberp"))
  (unless (natnump percent)
    (user-error "PERCENT must satisfy natnump"))
  (let* ((pc (/ (float percent) 100))
         (pc-change (if change-p (+ 1 pc) pc))
         (n (if change-p pc-change (float (- 1 pc-change)))))
    (/ number n)))

(defun invtr--new-truecost-from-discount (cost discount)
  "Find the original value of COST given DISCOUNT."
  (if (and discount (not (string-empty-p discount)))
      (format "%.2f"
              (invtr-reverse-percentage (string-to-number cost)
                                        (string-to-number discount)
                                        nil))
    ""))

;;;###autoload
(defun invtr-new-record (title categories cost discount productID producer price quantity dimensions weight)
  "Produce a new record for the inventory at `invtr-directory'.

When called interactively, prompt for TITLE, CATEGORIES, COST,
DISCOUNT, PRODUCTID, PRODUCER, PRICE, QUANTITY.  It will also ask
for DIMENSIONS and WEIGHT though those can be left as empty to be
ignored (just type RET at the prompt).

Internally, this is a variant of `usls-new-note'."
  (interactive
   (list
    (read-string "File title of inventory item: " nil 'invtr--title-history)
    (let ((usls-directory (invtr--directory)) ; We need this to infer correct categories
          (usls-known-categories invtr-known-categories))
      (usls--categories-prompt))
    (format "%.2f" (read-number "Cost of item: " nil 'invtr--cost-history))
    (format "%s%%" (read-number "Discount? (number without % sig or '0'): " nil 'invtr--discount-history))
    (read-string "Product number/code (from producer): " nil 'invtr--productID-history)
    (read-string "Producer or supplier and Invoice No. (e.g. NAME #123456): " nil 'invtr--producer-history)
    (format "%.2f" (read-number "Price we sell at: " nil 'invtr--price-history))
    (read-string "Total quantity (e.g. '50' for pieces, '2x10' for sets): " nil 'invtr--quantity-history)
    (read-string "Dimensions (e.g 200x100cm): " nil 'invtr--dimensions-history)
    (read-string "Weight (e.g 150g): " nil 'invtr--weight-history)))
  (let* ((usls-file-type-extension ".org")
         (slug (usls--sluggify title))
         (path (invtr--directory))
         (id (format-time-string usls-id))
         (date (format-time-string "%F"))
         (profit (format "%s%%" (invtr-percentage-change (string-to-number cost) (string-to-number price))))
         (filename (invtr--file-name-construction path id categories slug dimensions weight price))
         (truecost (invtr--new-truecost-from-discount cost discount))
         (dimensions-p (and dimensions (not (string-empty-p dimensions))))
         (weight-p (and weight (not (string-empty-p weight)))))
    (with-current-buffer (find-file filename)
      (insert
       (concat "#+title:      " title "\n"
               "#+date:       " date "\n"
               "#+orig_name:  " filename "\n"
               "#+orig_id:    " id "\n"
               "#+category:   " (usls--categories-capitalize categories) "\n"
               "#+cost:       " cost "\n"
               "#+discount:   " discount "\n"
               "#+truecost:   " truecost "\n"
               "#+producer:   " producer "\n"
               "#+productID:  " productID "\n"
               "#+price:      " price "\n"
               "#+profit:     " profit "\n"
               "#+quantity:   " quantity "\n")
       (cond
        ((and dimensions-p weight-p)
         (concat
          "#+dimensions: " dimensions "\n"
          "#+weight:     " weight "\n\n"))
        (dimensions-p
         (concat "#+dimensions: " dimensions "\n\n"))
        (weight-p
         (concat "#+weight:     " weight "\n"))
        (t
         "\n"))))))

;; Test for the above

;; (invtr-new-record
;;  "This is a test"
;;  '("one" "two" "three")
;;  "2.15"
;;  "30"
;;  "12345567101092"
;;  "Name #098765"
;;  "10"
;;  "40"
;;  "10x20cm"
;;  "30g")

(defvar invtr--add-acquisition-quantity-history '())
(defvar invtr--add-acquisition-invoice-history '())

(defun invtr--maybe-add-records-heading ()
  "Add a heading for records, if necessary."
  (unless (search-forward "* Records" nil t)
    (goto-char (point-max))
    (insert "\n* Records\n")))

(defun invtr--find-key-value-pair (regexp)
  "Produce a cons cell from REGEXP by searching the file."
  (goto-char (point-min))
  (re-search-forward regexp)
  (cons (match-string-no-properties 1) (match-string-no-properties 2)))

(defun invtr--make-replacement (regexp stock total &amp;optional float-p)
  "Help `invtr-add-acquisition', `invtr-remove-stock' restock.
REGEXP is the key to search for in the file.  STOCK is the
available quantity.  TOTAL is the stock after the performed
operation.

If optional FLOAT-P the inserted number is added with two decimal
points, such as 5 =&gt; 5.00."
  (goto-char (point-min))
  (re-search-forward regexp nil t)
  (re-search-backward stock nil t)
  (if float-p
      (replace-match (format "%.2f" (string-to-number total)))
    (replace-match total))
  (invtr--maybe-add-records-heading)
  (goto-char (point-max)))

;;;###autoload
(defun invtr-add-acquisition (quantity invoice-code)
  "Add acquisition record for QUANTITY with INVOICE-CODE."
  (interactive
   (list
    (read-string "Quantity added: " nil 'invtr--add-acquisition-quantity-history)
    (read-string "New invoice code: " nil 'invtr--add-acquisition-invoice-history)))
  (let* ((regexp "^\\(#\\+quantity:\\)\s+\\([0-9a-z]+\\)$")
         (datum (invtr--find-key-value-pair regexp))
         (key (car datum))
         (stock (cdr datum))
         (total (number-to-string (+ (string-to-number stock) (string-to-number quantity)))))
    (invtr--make-replacement regexp stock total)
    (insert
     (format "#+buy:  %s (+ %s %s) =&gt; %s, Invoice: %s\n"
             ;; The discrepancy with `invtr-remove-stock' is intentional
             ;; because we may have a scenario where we grep for "new
             ;; items" based on a timestamp which would cover those
             ;; #+buy entries as well as the #+orig_id.
             (format-time-string "%Y%m%d_%H%M%S") stock quantity total invoice-code))))

(defvar invtr--remove-stock-quantity-hist '())

;;;###autoload
(defun invtr-remove-stock (quantity &amp;optional arg)
  "Remove QUANTITY from stock.
With optional ARG, produce a receipt buffer."
  (interactive
   (list
    (read-string "Quantity sold/removed: " nil 'invtr--remove-stock-quantity-hist)
    current-prefix-arg))
  (let* ((contents (buffer-substring-no-properties (point-min) (point-max)))
         (regexp "^\\(#\\+quantity:\\)\s+\\([0-9a-z]+\\)$")
         (datum (invtr--find-key-value-pair regexp))
         (key (car datum))
         (stock (cdr datum))
         (total (number-to-string (- (string-to-number stock) (string-to-number quantity)))))
    (invtr--make-replacement regexp stock total)
    (insert
     (format "#+sell: %s      (- %s %s) =&gt; %s\n"
             (format-time-string "%F") stock quantity total)))
  (when arg
    (invtr-create-receipt quantity)))

(defun invtr--reset-cost (cost)
  "Reset file's cost entry to COST.
Helper for `invtr-reset-cost-discount'."
  (let* ((regexp "^\\(#\\+cost:\\)\s+\\([0-9a-z.,]+\\)$")
         (datum (invtr--find-key-value-pair regexp))
         (key (car datum))
         (old-cost (cdr datum)))
    (invtr--make-replacement regexp old-cost cost :float-p)
    (cons old-cost cost)))

(defun invtr--reset-discount (discount)
  "Reset file's discount entry to DISCOUNT.
Helper for `invtr-reset-cost-discount'."
  (let* ((regexp "^\\(#\\+discount:\\)\s+\\([0-9a-z.,]+\\)%$")
         (datum (invtr--find-key-value-pair regexp))
         (key (car datum))
         (old-discount (cdr datum)))
    (invtr--make-replacement regexp old-discount discount)
    (cons old-discount discount)))

(defun invtr--reset-truecost (truecost)
  "Reset file's truecost entry to TRUECOST.
Helper for `invtr-reset-cost-discount'."
  (let* ((regexp "^\\(#\\+truecost:\\)\s+\\([0-9a-z.,]+\\)$")
         (datum (invtr--find-key-value-pair regexp))
         (key (car datum))
         (old-truecost (cdr datum)))
    (invtr--make-replacement regexp old-truecost truecost :float-p)
    (cons old-truecost truecost)))

(defvar invtr--reset-cost-history '())
(defvar invtr--reset-cost-discount-history '())

;;;###autoload
(defun invtr-reset-cost-discount (cost discount)
  "Write COST and recalculate true cost given DISCOUNT."
  (interactive
   (list
    (read-string "New cost: " nil 'invtr--reset-cost-history)
    (read-string "New discount (number without %): " nil 'invtr--reset-cost-discount-history)))
  (let* ((costs (invtr--reset-cost cost))
         (old-cost (car costs))
         (new-cost (cdr costs))
         (discounts (invtr--reset-discount discount))
         (old-discount (car discounts))
         (new-discount (cdr discounts))
         (truecost (invtr--new-truecost-from-discount cost discount))
         (truecosts (invtr--reset-truecost truecost))
         (old-truecost (car truecosts))
         (new-truecost (cdr truecosts)))
    (insert
     ;; NOTE the (% X Y) is not Lisp notation.  It just makes it easier
     ;; to parse a long list of such entries with + (acquisitions), -
     ;; (sales), % (price changes).
     (format "#+calc: %s      (%% %s %s) =&gt; %s :: Old cost, discount, true cost: (%% %s %s) =&gt; %s\n"
             (format-time-string "%F") cost discount truecost
             old-cost old-discount old-truecost))))

(defvar invtr--reset-price-history '())

(defun invtr--reset-price (price)
  "Reset file's price entry to PRICE.
Helper for `invtr-reset-price'."
  (let* ((regexp "^\\(#\\+price:\\)\s+\\([0-9,.]+\\)$")
         (datum (invtr--find-key-value-pair regexp))
         (key (car datum))
         (old-price (cdr datum)))
    (cons old-price price)))

(defun invtr--reset-price-rename (price)
  "Update file's PRICE component (rename the file accordingly).
Helper for `invtr-reset-price'."
  (let* ((file (buffer-file-name))
         ;; We are hardcoding the file extension here, which is
         ;; technically wrong, though I do not mind since I am only
         ;; including prices for org-mode files.
         (name (replace-regexp-in-string "--[0-9,.]+\\.org" (format "--%s.org" price) file)))
    (if (vc-registered file)
        (vc-rename-file file name)
      (rename-file file name))
    (set-visited-file-name name t t)))

;;;###autoload
(defun invtr-reset-price (price)
  "Change PRICE of item."
  (interactive
   (list
    (format "%.2f" (read-number "New price: " nil 'invtr--reset-price-history))))
  (let* ((price-regexp "^\\(#\\+price:\\)\s+\\([0-9,.]+\\)$")
         (datum (invtr--find-key-value-pair price-regexp))
         (key (car datum))
         (old-price (cdr datum))
         (cost-regexp "^\\(#\\+cost:\\)\s+\\([0-9,.]+\\)$")
         (datum (invtr--find-key-value-pair cost-regexp))
         (key (car datum))
         (cost (cdr datum))
         (profit-regexp "^\\(#\\+profit:\\)\s+\\([0-9,.]+\\)%$")
         (datum (invtr--find-key-value-pair profit-regexp))
         (key (car datum))
         (old-profit (cdr datum))
         (profit (format "%.2f" (invtr-percentage-change (string-to-number cost) (string-to-number price)))))
    (invtr--reset-price-rename price)
    (invtr--make-replacement price-regexp old-price price :float-p)
    (invtr--make-replacement profit-regexp old-profit profit :float-p)
    (insert
     (format "#+markup: %s    (€ %s %s%%) :: Old cost and profit: (€ %s %s%%)\n"
             (format-time-string "%F") price profit old-price old-profit))))

;; TODO 2021-12-28: The receipt's template should be a defcustom.
(defvar invtr-receipt-template-function #'invtr--single-item-receipt
  "Function that produces a template for `invtr-create-receipt'.
It should accept a QUANTITY argument, followed by a PRICE and
TITLE of the item being recorded.

The `invtr--single-item-receipt' serves as a demo.")

(defun invtr--single-item-receipt (quantity price id title)
  "Produce receipt template given QUANTITY, PRICE, ID, TITLE.
This function is called by `invtr-create-receipt'."
  (let ((receiptid (format-time-string "%H%M%S_%d%m%Y"))
        (sum (format "%.2f" (* (string-to-number price) (string-to-number quantity)))))
    (insert
     (concat
      "Definitely not real company Ltd." "\n"
      "\n\n"
      "Sales receipt   #" receiptid      "\n"
      "================================" "\n"
      "\n\n"
      id "  " title "\n"
      "                 .........  " quantity
      " x " price   "\n"
      "\n\n"
      "                            " "———" "\n"
      "Total cost                  " sum "\n"))))

;;;###autoload
(defun invtr-create-receipt (quantity)
  "Produce receipt for QUANTITY of stock."
  (interactive
   (list
    (read-string "Quantity sold: " nil 'invtr--remove-stock-quantity-hist)))
  (let* ((title (cdr (invtr--find-key-value-pair "^\\(#\\+title:\\)\s+\\(.+\\)$")))
         (id (cdr (invtr--find-key-value-pair "^\\(#\\+orig_id:\\)\s+\\([0-9_]+\\)$")))
         (price (cdr (invtr--find-key-value-pair "^\\(#\\+price:\\)\s+\\([0-9_,.]+\\)$")))
         (date (format-time-string "%F")))
    (with-current-buffer (pop-to-buffer (format "*invtr receipt for: %s on %s*" id date))
      (delete-region (point-min) (point-max))
      (funcall invtr-receipt-template-function quantity price id title))))

(defvar invtr-receipt-multi-template-function #'invtr--multi-item-receipt
  "Function to handle `invtr-create-receipt-multiple' output.
It should accept a list of strings for ENTRIES and another list
of number strings for the calculation of TOTAL-COST.  An ENTITY
to whom the receipt is for is optional.

The `invtr--multi-item-receipt' provides a concrete example.")

(defun invtr--multi-item-receipt (receiptid entries total-cost entity &amp;optional phone address mail)
  "Prepare receipt for `invtr-create-receipt-multiple'.

RECEIPTID is the unique timestamp of the receipt.  ENTRIES is a
list of strings that holds information about the items being
sold.  The TOTAL-COST is a list of number strings that must be
converted into a lump sum.

ENTITY is a string holding the name of the person for the receipt
is for.  Optional PHONE, ADDRESS, MAIL are strings that describe
the ENTITY."
  (let* ((receipt-heading
          (cond
           ((and (and phone (not (string-empty-p phone)))
                 (and address (not (string-empty-p address)))
                 (and mail (not (string-empty-p mail))))
            (concat "Receipt   #" receiptid "\n"
                    "--------------------------" "\n"
                    "Buyer:    " entity    "\n"
                    "Phone:    " phone     "\n"
                    "Address:  " address   "\n"
                    "Mail:     " mail     "\n"))
           ((and (and phone (not (string-empty-p phone)))
                 (and address (not (string-empty-p address))))
            (concat "Receipt   #" receiptid "\n"
                    "--------------------------" "\n"
                    "Buyer:    " entity    "\n"
                    "Phone:    " phone     "\n"
                    "Address:  " address   "\n"))
           ((and phone (not (string-empty-p phone)))
            (concat "Receipt   #" receiptid "\n"
                    "--------------------------" "\n"
                    "Buyer:    " entity    "\n"
                    "Phone:    " phone     "\n"))
           (t
            (concat "Receipt   #" receiptid "\n"
                    "--------------------------" "\n"
                    "Buyer:    " entity    "\n"))))
         (receipt-heading-sep (make-string 60 ?=)))
    (insert
     (concat
      "Definitely not real company Ltd." "\n"
      "\n\n"
      receipt-heading
      receipt-heading-sep
      "\n\n\n\n"))
    (apply #'insert entries)
    (let ((lumpsum (format "%.2f" (apply #'+ total-cost))))
      (insert
       (concat
        "\n"
        "                             " "———" "\n"
        "Total cost                   " lumpsum "\n")))))

(defvar invtr--receipt-multi-items-history '())
(defvar invtr--receipt-multi-entity-history '())

(defun invtr--multi-item-receipt-client-prompt ()
  "Prompt for client with completion, when appropriate."
  (if-let ((data (invtr--collate-client-data))
           (prompt "For whom is this receipt? "))
      ;; NOTE 2021-12-29: Should we REQUIRE-MATCH in this case?
      (completing-read prompt data nil t nil 'invtr--receipt-multi-entity-history)
    (read-string prompt nil 'invtr--receipt-multi-entity-history)))

;;;###autoload
(defun invtr-create-receipt-multiple (items entity)
  "Produce receipt for ITEMS (files) from the inventory.
ENTITY is the natural or legal personal to whom the receipt is
for.  If ENTITY is nil the field will be left blank."
  (interactive
   (list
    (completing-read-multiple "Prepare receipt for items: "
                              (let* ((dir (invtr--directory))
                                     (default-directory dir))
                                (usls--directory-files dir))
                              nil t nil 'invtr--receipt-multi-items-history)
    (invtr--multi-item-receipt-client-prompt)))
  (let ((default-directory (invtr--directory))
        (receiptid (format-time-string "%H%M%S_%d%m%Y"))
        (entries)
        (total-cost))
    (dolist (file items)
      (with-current-buffer (find-file file) ; test `find-file-noselect'.
        (let* ((title (cdr (invtr--find-key-value-pair "^\\(#\\+title:\\)\s+\\(.+\\)$")))
               (id (cdr (invtr--find-key-value-pair "^\\(#\\+orig_id:\\)\s+\\([0-9_]+\\)$")))
               (price (cdr (invtr--find-key-value-pair "^\\(#\\+price:\\)\s+\\([0-9_,.]+\\)$")))
               (quantity (read-string (format "Quantity sold for %s: " id) nil 'invtr--remove-stock-quantity-hist))
               (sum (format "%.2f" (* (string-to-number price) (string-to-number quantity)))))
          (funcall #'invtr-remove-stock quantity)
          ;; TODO 2021-12-28: Maybe we should abstract this like we do
          ;; for `invtr-receipt-multi-template-function'?
          (push (format "%s  %s\n%s %s x %s\n"
                        id title
                        "                 .........  "
                        quantity price)
                entries)
          (push (string-to-number sum) total-cost))))
    ;; TODO 2021-12-29: Use find-file with the default-directory being
    ;; an `invtr-receipt-directory'.
    (with-current-buffer (pop-to-buffer (format "%s--%s" receiptid entity))
      (if-let* ((data (cdr (assoc entity invtr--client-data))))
          (let* ((phone (nth 0 data))
                 (address (nth 1 data))
                 (mail (nth 2 data))
                 (a (or address ""))
                 (m (or mail "")))
            (funcall invtr-receipt-multi-template-function receiptid entries total-cost entity phone a m))
        (funcall invtr-receipt-multi-template-function receiptid entries total-cost entity)))))

;;;; Clients

(defvar invtr-client-directory (concat (invtr--directory) "clients")
  "Subdirectory of `invtr-directory' with client records.")

(defun invtr--client-directory ()
  "Valid name format for `invtr-client-directory'."
  (file-name-as-directory invtr-client-directory))

(defun invtr--make-clients-dir ()
  (unless (file-directory-p path)
    (make-directory path t)))

(defvar invtr--client-name-history '())
(defvar invtr--client-phone-history '())
(defvar invtr--client-adress-history '())
(defvar invtr--client-email-history '())

;;;###autoload
(defun invtr-new-client (name &amp;optional phone address email)
  "Produce a new record of a client at `invtr-client-directory'.

When called interactively, prompt for NAME, PHONE, ADDRESS,
EMAIL.

Internally, this is a variant of `invtr-new-record' and
`usls-new-note'."
  (interactive
   (list
    (read-string "Name of client: " nil 'invtr--client-name-history)
    (read-string "Phone number: " nil 'invtr--client-phone-history)
    (read-string "Adress: " nil 'invtr--client-address-history)
    (read-string "Email: " nil 'invtr--client-email-history)))
  (let* ((usls-file-type-extension ".org")
         (slug (usls--sluggify name))
         (path (invtr--client-directory))
         (filename (format "%s%s%s" path slug usls-file-type-extension)))
    (usls--make-directory (invtr--client-directory))
    (with-current-buffer (find-file filename)
      (insert
       (concat "#+name:     " name "\n"
               "#+phone:    " phone "\n"
               "#+address:  " address "\n"
               ;; I don't use "email" because Org fontifies it
               ;; differently...
               "#+mail:     " email "\n")))))

(defvar invtr--client-data nil)

(defun invtr--collate-client-data ()
  "Gather client data in `invtr--client-data'."
  (let* ((dir (invtr--client-directory))
         (default-directory dir)
         (files (usls--directory-files dir)))
    (dolist (file files)
      (with-current-buffer (find-file-noselect file)
        (let ((name (cdr (invtr--find-key-value-pair "^\\(#\\+name:\\)\s+\\(.+\\)$")))
              (phone (cdr (invtr--find-key-value-pair "^\\(#\\+phone:\\)\s+\\(.+\\)$")))
              (address (cdr (invtr--find-key-value-pair "^\\(#\\+address:\\)\s+\\(.+\\)$")))
              (email (cdr (invtr--find-key-value-pair "^\\(#\\+mail:\\)\s+\\(.+\\)$"))))
          (push (list name phone address email) invtr--client-data)))))
  (delete-dups invtr--client-data))

;;;; Minor mode setup

(defun invtr-usls-mode-activate ()
  "Activate usls mode when inside `invtr-directory'."
  (when (or (string-match-p (abbreviate-file-name invtr-directory) default-directory)
            (string-match-p (invtr--directory) default-directory)
            (string-match-p invtr-directory default-directory))
    (usls-mode 1)))

;; FIXME 2021-12-26: This should not stay like this.
(add-hook 'dired-mode-hook #'invtr-usls-mode-activate)

(provide 'invtr)

;;; invtr.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa" class="outline-3">
<h3 id="h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa"><span class="section-number-3">5.5.</span> tmr.el (TMR Must Recur)</h3>
<div class="outline-text-3" id="text-h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa">
<p>
Sometimes I need to set off a timer with a notification.  I used to rely
on a homegrown shell script for such a task, but where is the fun in
that?
</p>

<p>
This package of mine provides a single command for setting a timer: <code>tmr</code>.
</p>

<p>
The command prompts for a unit of time, which is represented as a string
that consists of a number and, optionally, a single character suffix
which specifies the unit of time.
</p>

<p>
Valid formats:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Input</th>
<th scope="col" class="org-left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">5</td>
<td class="org-left">5 minutes</td>
</tr>

<tr>
<td class="org-left">5m</td>
<td class="org-left">5 minutes</td>
</tr>

<tr>
<td class="org-left">5s</td>
<td class="org-left">5 seconds</td>
</tr>

<tr>
<td class="org-left">5h</td>
<td class="org-left">5 hours</td>
</tr>
</tbody>
</table>

<p>
If <code>tmr</code> is called with an optional prefix argument (<code>C-u</code>), it also asks
for a description which accompanies the given timer.  Preconfigured
candidates are specified in the user option <code>tmr-descriptions-list</code>,
though any arbitrary input is acceptable at the minibuffer prompt.
</p>

<p>
When the timer is set, a message is sent to the echo area recording the
current time and the point in the future when the timer elapses.  Echo
area messages can be reviewed with the <code>view-echo-area-messages</code> which is
bound to <code>C-h e</code> by default.
</p>

<p>
Once the timer runs its course, it produces a desktop notification and
plays an alarm sound.  The notification's message is practically the
same as that which is sent to the echo area.  The sound file for the
alarm is defined in <code>tmr-sound-file</code>, while the urgency of the
notification can be set through the <code>tmr-notification-urgency</code> option.
</p>

<p>
The <code>tmr-cancel</code> command cancels the last <code>tmr</code>.  Note that for the time
being it has no notion of multiple timers&#x2014;just the last one.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; TMR Must Recur (just my generic timer)
(prot-emacs-builtin-package 'tmr
  (setq tmr-sound-file
        "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga")
  (setq tmr-notification-urgency 'normal)
  (setq tmr-descriptions-list (list "Boil water" "Prepare tea" "Bake bread"))
  (let ((map global-map))
    (define-key map (kbd "C-c t t") #'tmr)
    (define-key map (kbd "C-c t c") #'tmr-cancel)))
</pre>
</div>

<p>
This is its code (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; tmr.el --- TMR Must Recur -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; TMR Must Recur.  Else a timer for my Emacs setup:
;; &lt;https://protesilaos.com/emacs/dotemacs&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'notifications)

(defgroup tmr ()
  "TMR Must Recur (super simple timer for my private use)."
  :group 'data)

(defcustom tmr-sound-file
  "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga"
  "Path to sound file used by `tmr--play-sound'."
  :type 'file
  :group 'tmr)

(defcustom tmr-notification-urgency 'normal
  "The urgency level of the desktop notification.
Values can be `low', `normal' (default), or `critical'."
  :type '(choice
          (const :tag "Low" low)
          (const :tag "Normal" normal)
          (const :tag "Critical" critical))
  :group 'tmr)

(defcustom tmr-descriptions-list (list "Boil water" "Prepare tea" "Bake bread")
  "Optional description candidates for the current `tmr'."
  :type '(repeat string)
  :group 'tmr)

(defun tmr--unit (time)
  "Determine common time unit for TIME."
  (cond
   ((and (stringp time)
         (string-match-p "[0-9]\\'" time))
    (let ((time (string-to-number time)))
      (* time 60)))
   ((natnump time)
    (* time 60))
   (t
    (let* ((unit (substring time -1))
           (str (substring time 0 -1))
           (num (abs (string-to-number str))))
      (pcase unit
        ("s" num)
        ("h" (* num 60 60))
        ;; This is not needed, of course, but we should not miss a good
        ;; chance to make some fun of ourselves.
        ("w" (user-error "TMR Made Ridiculous; append [m]inutes, [h]ours, [s]econds"))
        (_ (* num 60)))))))

(defun tmr--play-sound ()
  "Play `tmr-sound-file' using the 'ffplay' executable (ffmpeg)."
  (let ((sound tmr-sound-file))
    (when (file-exists-p tmr-sound-file)
      (unless (executable-find "ffplay")
        (user-error "Cannot play %s without `ffplay'" sound))
      (call-process-shell-command
       (format "ffplay -nodisp -autoexit %s &gt;/dev/null 2&gt;&amp;1" sound) nil 0))))

(defun tmr--notify-send (start &amp;optional description)
  "Send system notification for timer with START time.
Optionally include DESCRIPTION."
  (let ((end (format-time-string "%T"))
        (desc-plain)
        (desc-propertized))
    (if description
        (setq desc-plain (concat "\n" description)
              desc-propertized (concat " [" (propertize description 'face 'bold) "]"))
      (setq desc-plain ""
            desc-propertized ""))
    ;; Read: (info "(elisp) Desktop Notifications")
    (notifications-notify
     :title "TMR Must Recur"
     :body (format "Time is up!\nStarted: %s\nEnded: %s%s"
                   start end desc-plain)
     :app-name "GNU Emacs"
     :urgency tmr-notification-urgency
     :sound-file tmr-sound-file)
    ;; TODO 2021-10-01: Maybe add those messages to a tmr buffer?
    (message
     "TMR %s %s ; %s %s%s"
     (propertize "Start:" 'face 'success) start
     (propertize "End:" 'face 'warning) end
     desc-propertized)
    (unless (plist-get (notifications-get-capabilities) :sound)
      (tmr--play-sound))))

;; TODO 2021-09-21: Maybe we should use a list instead of storing just
;; the last one?
(defvar tmr--last-timer nil
  "Last timer object, used by `tmr-cancel'.")

;;;###autoload
(defun tmr-cancel ()
  "Cancel last timer object set with `tmr' command."
  (interactive)
  (if tmr--last-timer
      (cancel-timer tmr--last-timer)
    (message "No `tmr' to cancel")))

(defun tmr--echo-area (time &amp;optional description)
  "Produce `message' for current `tmr' TIME.
Optionally include DESCRIPTION."
  (let* ((specifier (substring time -1))
         (amount (substring time 0 -1))
         (start (format-time-string "%T"))
         (unit (pcase specifier
                 ("s" (format "%ss (s == second)" amount))
                 ("h" (format "%sh (h == hour)" amount))
                 (_   (concat time "m (m == minute)")))))
    (message "`tmr' started at %s for %s%s"
             ;; Remember: these are just faces.  Don't get caught in the
             ;; semantics.
             (propertize start 'face 'success)
             (propertize unit 'face 'error)
             (if description
                 (concat " [" (propertize description 'face 'bold) "]")
               ""))))

(defvar tmr--description-hist '()
  "Minibuffer history of `tmr' descriptions.")

(defun tmr--description-prompt ()
  "Helper prompt for descriptions in `tmr'."
  (let ((def (nth 0 tmr--description-hist)))
    (completing-read
     (format "Description for this tmr [%s]: " def)
     tmr-descriptions-list nil nil nil
     'tmr--description-hist def)))

;;;###autoload
(defun tmr (time &amp;optional description)
  "Set timer to TIME duration and notify after it elapses.

When TIME is a number, it is interpreted as a count of minutes.
Otherwise TIME must be a string that consists of a number and a
special final character denoting a unit of time: 'h' for 'hours',
's' for 'seconds'.

With optional DESCRIPTION as a prefix (\\[universal-argument]),
prompt for a description among `tmr-descriptions-list', though
allow for any string to serve as valid input.

This command also plays back `tmr-sound-file'.

To cancel the timer, use the `tmr-cancel' command."
  (interactive
   (list
    (read-string "N minutes for timer (append `h' or `s' for other units): ")
    (when current-prefix-arg (tmr--description-prompt))))
  (let ((start (format-time-string "%T"))
        (unit (tmr--unit time)))
    (tmr--echo-area time description)
    (setq tmr--last-timer
          (run-with-timer
           unit nil
           'tmr--notify-send start description))))

(provide 'tmr)
;;; tmr.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7" class="outline-3">
<h3 id="h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7"><span class="section-number-3">5.6.</span> Version control tools</h3>
<div class="outline-text-3" id="text-h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7">
</div>

<div id="outline-container-h:2ff46d23-09d5-4d92-b0af-2339dc19719f" class="outline-4">
<h4 id="h:2ff46d23-09d5-4d92-b0af-2339dc19719f"><span class="section-number-4">5.6.1.</span> Diff-mode (and prot-diff.el extensions)</h4>
<div class="outline-text-4" id="text-h:2ff46d23-09d5-4d92-b0af-2339dc19719f">
<p>
This covers the standard <code>diff-mode.el</code>, which I use quite often, such as
while interfacing with the built-in Version Control framework (see the
section on <a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a>), or while
browsing various code-related mailing lists through notmuch (refer to
the <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">email settings</a>).
</p>

<p>
Overview of my preferences for how diffs should look:
</p>

<ul class="org-ul">
<li>Always start the buffer in a read-only state.  A typo will mess things
up when trying to apply a patch.</li>
<li>After applying a diff hunk (<code>diff-apply-hunk</code> with <code>C-c C-a</code>) move on to
the next one.</li>
<li>Update hunk headers automatically following an edit to the diff.</li>
<li>Do not show word-wise ("refined") changes upon activation.  I prefer
to do so manually.  All such highlights are removed if you generate
the buffer again (with <code>g</code> as expected) and the default is to not show
word-wise changes.</li>
<li>Do not prettify headers.  I like the standard "patch" looks.  It also
makes it easier to copy the diff elsewhere.</li>
</ul>

<p>
Now some notes on my <code>prot-diff.el</code> extensions, combined with a
description of the basics of <code>diff-mode</code> (as always you can get
documentation about the current buffer's major mode with <code>C-h m</code>&#x2014;read
<a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a> in the FAQ section appended to this document):
</p>

<ul class="org-ul">
<li><code>prot-diff-buffer-dwim</code> will produce a diff that compares the current
buffer to the last saved state of the underlying file.  If the buffer
has no unsaved edits, the command will produce a diff that compares
the file to its last registered version-controlled state.  Calling the
command with an optional prefix argument (<code>C-u</code>) will enable word-wise
highlighting across the diff.</li>

<li><code>prot-diff-refine-cycle</code> is how I manually control word-wise diff
highlights.  This command has a buffer-local cyclic behaviour.  The
first time it is called, it acts on the diff hunk at point.  Upon
second invocation, it operates on the entire buffer.  And on third
call it removes the word-wise diffs altogether.</li>

<li><code>prot-diff-narrow-dwim</code> narrows to the diff hunk at point.  If narrowing
is already present, it widens the buffer.  When invoked with an
optional prefix argument, it narrows to the current file.</li>

<li><code>C-c C-c</code> or <code>M-o</code> takes you to the point of the changes in the source
file.  If you run this of the diff hunk's heading, you go to the
beginning of the context.  But if you place the point somewhere inside
of the diff's added changes or context, you will visit that exact
position in the original file (does not work for removed text because
technically it does not exist).</li>

<li>When working with patches to source code, which are distributed
e.g. through email, you can apply the current hunk with <code>C-c C-a</code> or
test for compatibility with <code>C-c C-t</code>.  This is a nice way to easily
merge contributions from others, without having to go through the
workflow of some proprietary Git/Version-Control forge.</li>

<li>With <code>M-n</code> and <code>M-p</code> you move between hunks.  With <code>M-}</code> and <code>M-{</code> or <code>M-N</code>, <code>M-P</code>
do the same between files.</li>
</ul>

<p>
The <code>prot-diff-*</code> commands are part of my <code>prot-diff.el</code> library, reproduced
in its entirety after this set of package configurations.
</p>

<p>
<b>Pro tip:</b> enable <code>outline-minor-mode</code> to make diff sections foldable.
Check <a href="#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1">Outline mode, outline minor mode, and extras (prot-outline.el)</a>.
</p>

<p>
Also read these sections:
</p>

<ul class="org-ul">
<li><a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>.</li>
<li><a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a>.</li>
</ul>

<p>
Changes to all tracked files are optionally highlighted in the fringe
thanks to the <code>diff-hl</code> package by Dmitry Gutov (refer to the section on
<a href="#h:cb76fcee-e304-4b86-a764-6c3c6775da51">Line numbers and relevant indicators (prot-sideline.el)</a>).  Any rules
that control the placement of VC-related (and other) buffers are defined
in the section on <a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">window rules and basic tweaks</a> (specifically, refer to
the variable <code>display-buffer-alist</code>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Diff-mode (and prot-diff.el extensions)
(prot-emacs-builtin-package 'diff-mode
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)                ; I do it on demand
  (setq diff-font-lock-prettify nil)    ; better for patches
  ;; The following is further controlled by
  ;; `prot-diff-modus-themes-diffs'
  (setq diff-font-lock-syntax 'hunk-also))

(prot-emacs-builtin-package 'prot-diff
  (prot-diff-modus-themes-diffs)
  (add-hook 'modus-themes-after-load-theme-hook #'prot-diff-modus-themes-diffs)

  (prot-diff-extra-keywords 1)

  ;; `prot-diff-buffer-dwim' replaces the default for `vc-diff' (which I
  ;; bind to another key---see VC section).
  (define-key global-map (kbd "C-x v =") #'prot-diff-buffer-dwim)
  (let ((map diff-mode-map))
    (define-key map (kbd "C-c C-b") #'prot-diff-refine-cycle) ; replace `diff-refine-hunk'
    (define-key map (kbd "C-c C-n") #'prot-diff-narrow-dwim)))
</pre>
</div>

<p>
This is <code>prot-diff.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-diff.el --- Extensions to diff-mode.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my diff-mode.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Make sure to also inspect prot-vc.el and prot-project.el for a more
;; complete view of what I have on the topic of version control.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'diff-mode)

(defgroup prot-diff ()
  "Extensions for diff mode."
  :group 'diff)

;;;###autoload
(defun prot-diff-buffer-dwim (&amp;optional arg)
  "Diff buffer with its file's last saved state, or run `vc-diff'.
With optional prefix ARG (\\[universal-argument]) enable
highlighting of word-wise changes (local to the current buffer)."
  (interactive "P")
  (let ((buf))
    (if (buffer-modified-p)
        (progn
          (diff-buffer-with-file (current-buffer))
          (setq buf "*Diff*"))
      (vc-diff)
      (setq buf "*vc-diff*"))
    (when arg
      (with-current-buffer (get-buffer buf)
        (unless diff-refine
          (setq-local diff-refine 'font-lock))))))

(defvar-local prot-diff--refine-diff-state 0
  "Current state of `prot-diff-refine-dwim'.")

;;;###autoload
(defun prot-diff-refine-cycle ()
  "Produce buffer-local, 'refined' or word-wise diffs in Diff mode.

Upon first invocation, refine the diff hunk at point or, when
none exists, the one closest to it.  On second call, operate on
the entire buffer.  And on the third time, remove all word-wise
fontification."
  (interactive)
  (let ((point (point)))
    (pcase prot-diff--refine-diff-state
      (0
       (diff-refine-hunk)
       (setq prot-diff--refine-diff-state 1))
      (1
       (setq-local diff-refine 'font-lock)
       (font-lock-flush)
       (goto-char point)
       (setq prot-diff--refine-diff-state 2))
      (_
       (revert-buffer)
       (goto-char point)
       (recenter)
       (setq prot-diff--refine-diff-state 0)))))

;;;###autoload
(defun prot-diff-narrow-dwim (&amp;optional arg)
  "Use `diff-restrict-view', or widen when already narrowed.
By default the narrowing effect applies to the focused diff hunk.
With optional prefix ARG (\\[universal-argument]) do it for the
current file instead."
  (interactive "P")
  (when (derived-mode-p 'diff-mode)
    (if (buffer-narrowed-p)
        (progn
          (widen)
          (message "Widened the view"))
      (if arg
          (progn
            (diff-restrict-view arg)
            (message "Narrowed to file"))
        (diff-restrict-view)
        (message "Narrowed to diff hunk")))))

(defvar modus-themes-diffs)

;;;###autoload
(defun prot-diff-modus-themes-diffs ()
  "Configure `diff-font-lock-syntax' for accessibility.

A non-nil value for that variable will apply fontification to the
text while also trying to add the familiar diff styles.  This can
easily result in inaccessible colour combinations.

My Modus themes, which are designed for the highest accessibility
standard in legibility, provide an option that can work well with
such non-nil values.  Otherwise `diff-font-lock-syntax' should be
set to nil.

Run this function at the post theme load phase, such as with the
hook `modus-themes-after-load-theme-hook'."
  (if (eq modus-themes-diffs 'bg-only)
      (setq diff-font-lock-syntax 'hunk-also)
    (setq diff-font-lock-syntax nil)))

;;; Extend diff-mode font lock

(defface prot-diff-diffstat-added
  '((t :inherit diff-indicator-added))
  "Face for diffstat added indicators (+).")

(defface prot-diff-diffstat-removed
  '((t :inherit diff-indicator-removed))
  "Face for diffstat removed indicators (-).")

(defface prot-diff-commit-header
  '((((class color) (min-colors 88) (background light))
     :foreground "#000000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#ffffff"))
  "Face for diff commit header keys like 'Author:'.")

(defface prot-diff-commit-hash
  '((((class color) (min-colors 88) (background light))
     :foreground "#184034")
    (((class color) (min-colors 88) (background dark))
     :foreground "#bfebe0")
    (t :inherit shadow))
  "Face for diff commit unique identifier (hash).")

(defface prot-diff-commit-author
  '((((class color) (min-colors 88) (background light))
     :foreground "#00538b")
    (((class color) (min-colors 88) (background dark))
     :foreground "#00d3d0")
    (t :foreground "cyan"))
  "Face for diff commit author name.")

(defface prot-diff-commit-email
  '((((class color) (min-colors 88) (background light))
     :foreground "#0031a9")
    (((class color) (min-colors 88) (background dark))
     :foreground "#2fafff")
    (t :foreground "blue"))
  "Face for diff commit author email.")

(defface prot-diff-commit-date
  '((((class color) (min-colors 88) (background light))
     :foreground "#55348e")
    (((class color) (min-colors 88) (background dark))
     :foreground "#cfa6ff")
    (t :foreground "magenta"))
  "Face for diff commit date.")

(defface prot-diff-commit-subject
  '((((class color) (min-colors 88) (background light))
     :foreground "#005a5f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#6ae4b9")
    (t :foreground "cyan"))
  "Face for diff commit message subject.")

;; NOTE 2021-01-30: These work in all scenaria I tried, but there may
;; still be errors or omissions.
(defconst prot-diff-keywords
  '(("\\(^[^+@-]?\\)\\(.*?\s+|\s+\\)\\([0-9]*\\) \\(\\++\\)"
     ;; (2 'prot-diff-diffstat-file-changed)
     (4 'prot-diff-diffstat-added))
    ("\\(^[^+-]?\\)\\(\\+\\{3\\}\\) \\([ab].*?\\)"
     (2 'prot-diff-diffstat-added))
    ("\\(^[^+-]?\\)\\(-+\\{3\\}\\) \\([ab].*?\\)"
     (2 'prot-diff-diffstat-removed))
    ("\\(^[^+@-]?\\)\\(.*?\s+|\s+\\)\\([0-9]*\\) \\(\\++\\)?\\(-+\\)"
     ;; (2 'prot-diff-diffstat-file-changed)
     (5 'prot-diff-diffstat-removed))
    ;; ("\\([0-9]+ files? changed,.*\\)"
    ;;  (0 'prot-diff-diffstat-file-changed))
    ("^---\n"
     (0 'prot-diff-commit-header))
    ("\\(^commit \\)\\(.*\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-hash))
    ("\\(^Author: \\)\\(.*\\)\\(&lt;\\)\\(.*\\)\\(&gt;\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-author)
     (3 'prot-diff-commit-header)
     (4 'prot-diff-commit-email)
     (5 'prot-diff-commit-header))
    ("\\(^From:\\|^To:\\|^Cc:\\) ?\\(.*\\)?\\(&lt;\\)\\(.*\\)\\(&gt;\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-author)
     (3 'prot-diff-commit-header)
     (4 'prot-diff-commit-email)
     (5 'prot-diff-commit-header))
    ("\\(^Subject:\\) \\(.*\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-subject))
    ("\\(^From\\)\\( [0-9a-zA-Z]+ \\)\\(.*\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-hash)
     (3 'prot-diff-commit-date))
    ("\\(^Message-Id:\\) \\(&lt;.+&gt;\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-hash))
    ("\\(^Date: \\)\\(.*\\)"
     (1 'prot-diff-commit-header)
     (2 'prot-diff-commit-date)))
  "Extra font-lock patterns for diff mode.")

;;;###autoload
(define-minor-mode prot-diff-extra-keywords
  "Apply extra font-lock rules to diff buffers."
  :init-value nil
  :global t
  (if prot-diff-extra-keywords
      (progn
        (font-lock-flush (point-min) (point-max))
        (font-lock-add-keywords nil prot-diff-keywords nil)
        (add-hook 'diff-mode-hook #'prot-diff-extra-keywords))
    (font-lock-remove-keywords nil prot-diff-keywords)
    (remove-hook 'diff-mode-hook #'prot-diff-extra-keywords)
    (font-lock-flush (point-min) (point-max))))

(provide 'prot-diff)
;;; prot-diff.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:31deeff4-dfae-48d9-a906-1f3272f29bc9" class="outline-4">
<h4 id="h:31deeff4-dfae-48d9-a906-1f3272f29bc9"><span class="section-number-4">5.6.2.</span> Version control framework (vc.el and prot-vc.el)</h4>
<div class="outline-text-4" id="text-h:31deeff4-dfae-48d9-a906-1f3272f29bc9">
<p>
VC consists of set of libraries that provide the means for working with
several version control systems, else "backends".  It is built into
Emacs.  Compared with <code>magit</code> (see section on <a href="#h:76d1b392-e693-40dc-b320-d4c1047115ab">Magit configs</a>), <code>vc</code> offers a
more abstract, buffer-oriented paradigm that does a fine job at covering
all basic versioning needs.  It however never stands as Magit's peer
when it comes to the sheer coverage of Git features.
</p>

<p>
To my mind, VC and Magit can be used as part of the same setup.  Employ
the former for common tasks such as viewing diffs and logs, committing
changes in bulk, pushing and pulling from a remote.  And let Magit
handle the more involved and specialised cases of staging a partial
diff, rebasing commits interactively, writing a commit fixup, and so on.
</p>

<p>
Also refer to the section on <a href="#h:2ff46d23-09d5-4d92-b0af-2339dc19719f">Diff-mode (and prot-diff.el extensions)</a>
which includes various neat extras, such as extra fontification rules
for diff buffers.  And watch my videos on this topic:
</p>

<ol class="org-ol">
<li><a href="https://protesilaos.com/codelog/2020-03-30-emacs-intro-vc/">Introduction to the Emacs Version Control framework</a> (2020-03-30).</li>
<li><a href="https://protesilaos.com/codelog/2021-01-22-emacs-vc-git-extras/">Extensions for Emacs' vc-git</a> (2021-01-22).</li>
<li><a href="https://protesilaos.com/codelog/2021-02-08-emacs-vc-workflow/">My workflow with VC for Git projects</a> (2021-02-08).</li>
</ol>

<p>
Here is an overview of the keys I define, with only a few of them being
left to their default values (note that <code>prot-diff-buffer-dwim</code> is part of
the <code>prot-diff.el</code> that I linked to above):
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">C-x v prefix</th>
<th scope="col" class="org-left">Mnemonic</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">vc-update</td>
<td class="org-left">F</td>
<td class="org-left">Fetch and Fuse</td>
</tr>

<tr>
<td class="org-left">vc-push</td>
<td class="org-left">P</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vc-log-incoming</td>
<td class="org-left">f</td>
<td class="org-left">Fetch only</td>
</tr>

<tr>
<td class="org-left">vc-log-outgoing</td>
<td class="org-left">O</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vc-create-tag</td>
<td class="org-left">t</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">vc-retrieve-tag</td>
<td class="org-left">b</td>
<td class="org-left">Branch/tag switch</td>
</tr>

<tr>
<td class="org-left">vc-diff</td>
<td class="org-left">d</td>
<td class="org-left">Diff current file</td>
</tr>

<tr>
<td class="org-left">vc-root-diff</td>
<td class="org-left">D</td>
<td class="org-left">Diff project</td>
</tr>

<tr>
<td class="org-left">prot-diff-buffer-dwim</td>
<td class="org-left">=</td>
<td class="org-left">Equality check</td>
</tr>

<tr>
<td class="org-left">prot-vc-project-or-dir</td>
<td class="org-left">p</td>
<td class="org-left">Project status</td>
</tr>

<tr>
<td class="org-left">prot-vc-custom-log</td>
<td class="org-left">SPC</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-patch-apply</td>
<td class="org-left">a</td>
<td class="org-left">Apply patch</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-patch-create-dwim</td>
<td class="org-left">c</td>
<td class="org-left">Create patch</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-show</td>
<td class="org-left">s</td>
<td class="org-left">Show commit</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-grep</td>
<td class="org-left">g</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-log-grep</td>
<td class="org-left">G</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-find-revision</td>
<td class="org-left">r</td>
<td class="org-left">Revisit version</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-blame-region-or-file</td>
<td class="org-left">B</td>
<td class="org-left">Blame</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-log-insert-commits</td>
<td class="org-left">i</td>
<td class="org-left">Insert commit log</td>
</tr>

<tr>
<td class="org-left">prot-vc-git-reset</td>
<td class="org-left">R</td>
<td class="org-left">Reset (&#x2013;soft)</td>
</tr>
</tbody>
</table>

<p>
My <code>prot-vc.el</code> library (reproduced after the package configurations)
defines several commands that extend VC to suit my needs as a Git user.
Check the key maps I assign those commands to, in order to further
appreciate the scope of each action.  In short:
</p>

<ul class="org-ul">
<li><code>prot-vc-git-grep</code> is a simple wrapper around <code>vc-git-grep</code>.  Instead of
asking for a directory and a file extension pattern, it just prompts
for a regexp and performs the search across the entire VC-controlled
directory tree.  All matches are placed directly in a buffer.</li>

<li><code>prot-vc-git-log-edit-extract-file-name</code> is used in log-edit buffers to
derive the file name of the item being committed.  For example, as I
am writing this, I may want to compose a summary of my changes like
"prot-emacs: expand VC section docs".  The "prot-emacs: " part comes
directly from this command, which reads from the "prot-emacs.org"
file.  If there are multiple files to be committed, then a minibuffer
prompt asks to pick one among them.  This helps me write clean and
meaningful summaries.</li>

<li>The commands <code>prot-vc-git-log-edit-{next,previous,complete}-comment</code> are
used to access information about previous commit messages that are
stored in the dedicated ring.  The next/previous operations will cycle
through the ring in the given direction.  While the "complete" command
will use minibuffer completion to insert the select item at point.</li>

<li><code>prot-vc-git-log-insert-commits</code> will simply insert at point N number of
commits starting from the HEAD of the current project.  The number is
inserted at the minibuffer following a prompt.  This runs the <code>git log</code>
shell command in the background.  If the command is not called from
inside a version-controlled directory or if it is invoked with a
prefix argument (<code>C-u</code>), it first asks for a project and eventually
prints a log for it.  Again, this is useful while writing the message
of a commit, as I occasionally need to reference earlier changes.</li>

<li><code>prot-vc-git-patch-apply</code> prompts for a file system path to a patch
file.  By default, it applies the patch directly to the current git
repo.  If no such repository is found or if called with an optional
prefix argument the command prompts for a project to use.  This makes
it very simple to apply a patch from anywhere, such as while reading
my email (also refer to <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">Email settings</a>).  Arguments that are passed to
it are those specified in <code>prot-vc-git-patch-apply-args</code>, unless the
command is called from Lisp, in which case it accepts ARGS as a list
of strings (read the <code>git am</code> man pages if you ever need this).</li>

<li><code>prot-vc-git-patch-create-dwim</code> produces a properly formatted patch for
a given commit.  The outputted file is saved in a directory that is
selected via a minibuffer completion prompt: default candidates are
stored in <code>prot-vc-patch-output-dirs</code> and are complemented by the root
of the current project.

<ul class="org-ul">
<li>When browsing a <code>log-view</code> buffer, the commit is the one around point.</li>

<li>When the region is active in Log View buffers, the command will
capture the included range of commits, instead of just the one at
point.</li>

<li>With a prefix argument (<code>C-u</code>), a minibuffer completion prompt will
ask for a commit to use as the base in a range against HEAD.  This
will skip the check for the commit at point, though an active region
in Log View buffers will still take precedence.</li>

<li>Beware of how Git interprets those ranges: the base commit is the
one before the earliest in the range, so if you need to produce
patches for the topmost 4 commits, you must include the last 5 in
the region.</li>

<li>That granted, I also use <a href="#h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301">git-email.el for preparing patches</a> that
must be sent via email outright.</li>
</ul></li>

<li><code>prot-vc-git-checkout-remote</code> prompts for a remote branch and proceeds
to checkout a local branch that is set up to track it.  So if you have
a remote named <code>origin/dev</code> it will do <code>git checkout -b dev origin/dev</code>.
I only use this command inside VC-dir buffers.</li>

<li><code>prot-vc-custom-log</code> prints a log of commits that matches a custom file
set.  This is of great value when you need to inspect the history of
only some files rather than that of the entire repository.  What files
to choose is determined in two ways: (1) the file-at-point in Dired
buffers, or all marked files, and (2) files in the current directory
selected with minibuffer completion.</li>

<li><code>prot-vc-log-view-toggle-entry-all</code> will toggle the visibility of all
commits in a compact log view.  I often employ this in tandem with
<code>prot-vc-custom-log</code>.</li>

<li><code>prot-vc-git-show</code> lets you read a given commit that you access with
completion.  A simple and effective wrapper for <code>git show</code>.</li>

<li><code>prot-vc-git-log-grep</code> provides a search utility for commit logs.  It
accepts a regular expression, which may just be a string, and shows
all commits whose message includes that pattern.  When called with a
universal prefix argument (<code>C-u</code>), the log will also include the
corresponding diff of each commit.</li>

<li><code>prot-vc-git-find-revision</code> allows you to revisit a previous state of the
current file, by selecting a commit with completion.  Quite powerful
when you want to search, for example, my dotemacs from when I first
introduced a certain package, say, <code>prot-vc.el</code>.</li>

<li><code>prot-vc-git-reset</code> prompts for a commit to reset back to, using
minibuffer completion.  This is a "soft" undo process in that all
changes are kept in place while any commits are removed.  Remember to
only do this for local logs as it is not good practice to reset
publicly available histories: it will break the local copies of other
users.</li>

<li><code>prot-vc-git-log-reset</code> is like the above command, only that it is meant
to be called from inside a Log View buffer (e.g.  <code>vc-print-root-log</code>
which is bound to <code>C-x v L</code> by default).  The commit to reset back to is
the one at point.  Calling the command with a prefix argument (<code>C-u</code>)
will change the meaning of the reset operation from a soft to a hard
one.  The latter deletes all commits up to the selected commit <i>and
removes all changes</i>, so please be careful.</li>

<li><code>prot-vc-project-or-dir</code> produces a <code>vc-dir</code> buffer for the current
project (also see <a href="#h:7862f39e-aed0-4d02-9f1e-60c4601a9734">Projects (project.el and prot-project.el)</a>).  With a
<code>C-u</code> prefix argument the command limits the matches to the present
directory.</li>

<li><code>prot-vc-log-kill-hash</code> appends to the kill-ring the hash of the commit
around point.  It is meant to be used in <code>log-view</code> buffers.</li>

<li><code>prot-vc-git-setup-mode</code> is a minor mode that refashions the log edit
buffer while adding a small tweak to the log view buffers.

<ul class="org-ul">
<li>Normally the log edit buffer (what you use to write the commit
message) will pop up in a window with a smaller window below it
showing the files to be committed.  The window layout does not
automatically show the corresponding diff, while there is no readily
available information as to what branch we are about to commit the
changes to.  So my minor mode removes the small window with the
files and in its stead adds a comment block in the main message
composition buffer (like the standard <code>git commit</code>).  It then displays
the diff window on one side and the edit buffer on the other (yes,
just like Magit, though the order of the windows is always the
same).  The prior window configuration and the point are saved
before entering the log edit session and immediately restored upon
exit (either by committing the changes or aborting).</li>

<li>The behaviour of cycling the ring of prior commits is reworked to
account for the custom git comment.  In addition to back/forth
motions through the ring's items (<code>M-p</code>, <code>M-n</code>), a command for picking a
commit message with minibuffer completion is also made available in
the stead of the generic commands for searching through the ring,
with <code>M-s</code> or <code>M-r</code> (the defaults lack visual feedback and are, in my
opinion, not appropriate for the task).</li>

<li>The <code>Amend</code> pseudo header is displayed by default to make it easier to
edit the last commit, if necessary, and to raise awareness about
this possibility.</li>

<li>For the log view buffers (commit logs) the minor mode instructs the
command that expands the message of a commit on the current line to
include more information from <code>git log</code> than what it normally would.
It shows diff stats and affected file names, while also creating
some much needed negative space for better usability.  Those file
names are not purely cosmetic, as they can now serve to power Emacs'
contextuality and "future history" such as when you put point over
the name and type <code>C-x p f</code> (<code>project-find-file</code>): the file at point
becomes the default choice and the one you will also get with <code>M-n</code> in
the minibuffer (<code>next-history-element</code>).</li>
</ul></li>
</ul>

<p>
Finally, a few tips for acting in the log-edit buffer (remember to use
<code>C-h m</code> (<code>M-x describe-mode</code>) in every unfamiliar major mode and read the
manual for more on the matter):
</p>

<ul class="org-ul">
<li>Use <code>C-c C-d</code> (<code>log-edit-show-diff</code>) to produce a diff of the changes
to-be-committed.  Of course this is of no use if my aforementioned
minor mode is enabled.  Still, it is good to know (by the way, this
command also works in Magit's commit composition buffers).</li>

<li>With <code>C-c C-w</code> (<code>log-edit-generate-changelog-from-diff</code>) generate an
overview of documented changes to the given file set.  While this may
not be useful for everyday commits, it is mandatory when preparing
patches for upstream Emacs (and probably other GNU projects).</li>

<li>Normally the window layout is set up to include files for the given
commit, but I disable that via my minor mode.  You can opt to display
them with <code>C-c C-f</code> (<code>log-edit-show-files</code>).</li>

<li><code>C-c C-k</code> (<code>log-edit-kill-buffer</code>) cancels the log editing process.</li>

<li><code>M-n</code> (<code>log-edit-next-comment</code>) and <code>M-p</code> (<code>log-edit-previous-comment</code>) let
you cycle through prior commit messages.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Version control framework (vc.el and prot-vc.el)
(prot-emacs-builtin-package 'vc
  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; Note that `prot-vc-git-setup-mode' will run the following when
  ;; activated:
  ;;
  ;;   (remove-hook 'log-edit-hook #'log-edit-show-files)
  ;;
  ;; If you need the window to pop back up, do it manually with C-c C-f
  ;; which calls `log-edit-show-files'.

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  (setq add-log-mailing-address "info@protesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        '("%d %h %ad %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?\
\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date))))

  (add-hook 'log-view-mode-hook #'hl-line-mode)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v b") #'vc-retrieve-tag)  ; "branch" switch
    (define-key map (kbd "C-x v t") #'vc-create-tag)
    (define-key map (kbd "C-x v f") #'vc-log-incoming)  ; the actual git fetch
    (define-key map (kbd "C-x v o") #'vc-log-outgoing)
    (define-key map (kbd "C-x v F") #'vc-update)        ; "F" because "P" is push
    (define-key map (kbd "C-x v d") #'vc-diff))
  (let ((map vc-dir-mode-map))
    (define-key map (kbd "b") #'vc-retrieve-tag)
    (define-key map (kbd "t") #'vc-create-tag)
    (define-key map (kbd "O") #'vc-log-outgoing)
    (define-key map (kbd "o") #'vc-dir-find-file-other-window)
    (define-key map (kbd "f") #'vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
    (define-key map (kbd "F") #'vc-update)       ; symmetric with P: `vc-push'
    (define-key map (kbd "d") #'vc-diff)         ; parallel to D: `vc-root-diff'
    (define-key map (kbd "k") #'vc-dir-clean-files)
    (define-key map (kbd "G") #'vc-revert)
    (let ((prot-vc-git-branch-map (make-sparse-keymap)))
      (define-key map "B" prot-vc-git-branch-map)
      (define-key prot-vc-git-branch-map "n" #'vc-create-tag) ; new branch/tag
      (define-key prot-vc-git-branch-map "s" #'vc-retrieve-tag) ; switch branch/tag
      (define-key prot-vc-git-branch-map "c" #'prot-vc-git-checkout-remote) ; "checkout" remote
      (define-key prot-vc-git-branch-map "l" #'vc-print-branch-log))
    (let ((prot-vc-git-stash-map (make-sparse-keymap)))
      (define-key map "S" prot-vc-git-stash-map)
      (define-key prot-vc-git-stash-map "c" 'vc-git-stash) ; "create" named stash
      (define-key prot-vc-git-stash-map "s" 'vc-git-stash-snapshot)))
  (let ((map vc-git-stash-shared-map))
    (define-key map "a" 'vc-git-stash-apply-at-point)
    (define-key map "c" 'vc-git-stash) ; "create" named stash
    (define-key map "D" 'vc-git-stash-delete-at-point)
    (define-key map "p" 'vc-git-stash-pop-at-point)
    (define-key map "s" 'vc-git-stash-snapshot))
  (let ((map vc-annotate-mode-map))
    (define-key map (kbd "M-q") #'vc-annotate-toggle-annotation-visibility)
    (define-key map (kbd "C-c C-c") #'vc-annotate-goto-line)
    (define-key map (kbd "&lt;return&gt;") #'vc-annotate-find-revision-at-line))
  (let ((map log-view-mode-map))
    (define-key map (kbd "&lt;tab&gt;") #'log-view-toggle-entry-display)
    (define-key map (kbd "&lt;return&gt;") #'log-view-find-revision)
    (define-key map (kbd "s") #'vc-log-search)
    (define-key map (kbd "o") #'vc-log-outgoing)
    (define-key map (kbd "f") #'vc-log-incoming)
    (define-key map (kbd "F") #'vc-update)
    (define-key map (kbd "P") #'vc-push)))

(prot-emacs-builtin-package 'prot-vc
  (setq prot-vc-log-limit 100)
  (setq prot-vc-log-bulk-action-limit 50)
  (setq prot-vc-git-log-edit-show-commits t)
  (setq prot-vc-git-log-edit-show-commit-count 10)
  (setq prot-vc-shell-output "*prot-vc-output*")
  (setq prot-vc-patch-output-dirs (list "~/" "~/Desktop/"))
  (add-to-list' log-edit-headers-alist '("Amend"))

  ;; This refashions log view and log edit buffers
  (prot-vc-git-setup-mode 1)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v i") #'prot-vc-git-log-insert-commits)
    (define-key map (kbd "C-x v p") #'prot-vc-project-or-dir)
    (define-key map (kbd "C-x v SPC") #'prot-vc-custom-log)
    (define-key map (kbd "C-x v g") #'prot-vc-git-grep)
    (define-key map (kbd "C-x v G") #'prot-vc-git-log-grep)
    (define-key map (kbd "C-x v a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "C-x v c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "C-x v s") #'prot-vc-git-show)
    (define-key map (kbd "C-x v r") #'prot-vc-git-find-revision)
    (define-key map (kbd "C-x v B") #'prot-vc-git-blame-region-or-file)
    (define-key map (kbd "C-x v R") #'prot-vc-git-reset))
  (let ((map vc-git-log-edit-mode-map))
    (define-key map (kbd "C-C C-n") #'prot-vc-git-log-edit-extract-file-name)
    (define-key map (kbd "C-C C-i") #'prot-vc-git-log-insert-commits)
    ;; Also done by `prot-vc-git-setup-mode', but I am putting it here
    ;; as well for visibility.
    (define-key map (kbd "C-c C-c") #'prot-vc-git-log-edit-done)
    (define-key map (kbd "C-c C-a") #'prot-vc-git-log-edit-toggle-amend)
    (define-key map (kbd "M-p") #'prot-vc-git-log-edit-previous-comment)
    (define-key map (kbd "M-n") #'prot-vc-git-log-edit-next-comment)
    (define-key map (kbd "M-s") #'prot-vc-git-log-edit-complete-comment)
    (define-key map (kbd "M-r") #'prot-vc-git-log-edit-complete-comment))
  (let ((map log-view-mode-map))
    (define-key map (kbd "&lt;C-tab&gt;") #'prot-vc-log-view-toggle-entry-all)
    (define-key map (kbd "a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "R") #'prot-vc-git-log-reset)
    (define-key map (kbd "w") #'prot-vc-log-kill-hash)))
</pre>
</div>

<p>
And here is <code>prot-vc.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-vc.el --- Extensions to vc.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my vc.el extensions, which mostly concern Git.  For use
;; in my Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Make sure to also inspect prot-project.el and prot-diff.el for a more
;; complete view of what I have on the topic of version control.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'vc)
(require 'log-edit)
(require 'prot-common)

;;;; Customisation options

(defgroup prot-vc ()
  "Extensions for vc.el and related libraries."
  :group 'project)

(defcustom prot-vc-log-limit 100
  "Limit commits in `prot-vc-custom-log' and others."
  :type 'integer
  :group 'prot-vc)

(defcustom prot-vc-log-bulk-action-limit 50
  "Limit for `prot-vc-log-view-toggle-entry-all'.
This is to ensure that performance does not take a hit.  The
default value is conservative."
  :type 'integer
  :group 'prot-vc)

(defcustom prot-vc-git-log-edit-show-commits nil
  "Show recent commits in Git Log Edit comments."
  :type 'boolean
  :group 'prot-vc)

(defcustom prot-vc-git-log-edit-show-commit-count 10
  "Commit number for `prot-vc-git-log-edit-show-commits'."
  :type 'integer
  :group 'prot-vc)

(defcustom prot-vc-shell-output "*prot-vc-output*"
  "Name of buffer for VC-related shell output."
  :type 'string
  :group 'prot-vc)

(defcustom prot-vc-patch-output-dirs (list "~/" "~/Desktop/")
  "List of directories to save `prot-vc-patch-dwim' output."
  :type 'list
  :group 'prot-vc)

(defcustom prot-vc-git-patch-apply-args (list "--3way")
  "List of strings to pass as arguments to 'git am'."
  :type '(repeat string)
  :group 'prot-vc)

;;;; Commands and helper functions

(defun prot-vc--current-project ()
  "Return root directory of current project."
  (or (vc-root-dir)
      (locate-dominating-file "." ".git")))

;;;###autoload
(defun prot-vc-project-or-dir (&amp;optional arg)
  "Run `vc-dir' for the current project root.
With optional prefix ARG (\\[universal-argument]), use the
`default-directory' instead."
  (interactive "P")
  (let* ((root (prot-vc--current-project))
         (dir (if arg default-directory root)))
    (vc-dir dir)))

(defun prot-vc--log-edit-files-prompt ()
  "Helper completion for `prot-vc-extract-file-name'."
  (let ((files (log-edit-files)))
    (completing-read
     "Derive shortname from: " files nil nil)))

;;;###autoload
(defun prot-vc-git-log-edit-extract-file-name ()
  "Insert at point shortname from file in log edit buffers.
If multiple files are part of the log, a minibuffer completion
prompt will be produced: it can be used to narrow down to an
existing item or input an arbitrary string of characters."
  (interactive)
  (unless (derived-mode-p 'log-edit-mode)
    (user-error "Only try this in Log Edit mode"))
  (let* ((files (log-edit-files))
         (file (if (&gt; (length files) 1)
                   (prot-vc--log-edit-files-prompt)
                 (car files)))
         (name (file-name-sans-extension
                (file-name-nondirectory
                 file))))
    (insert (concat name ": "))))

(autoload 'project-current "project")

(defvar prot-vc--log-insert-num-hist '()
  "History for `prot-vc-git-log-insert-commits'.")

(declare-function project-prompt-project-dir "project")

;;;###autoload
(defun prot-vc-git-log-insert-commits (&amp;optional arg)
  "Insert at point number of commits starting from git HEAD.
If in a version-controlled directory, the commit log is based on
the root of the project, else a prompt for project selection is
produced with `project-current'.

With optional prefix ARG (\\[universal-argument]) always prompt
for a known project."
  (interactive "P")
  (let* ((dir (when arg (project-prompt-project-dir)))
         (default-directory (or dir
                                (prot-vc--current-project)
                                (cdr (project-current t))))
         (number (number-to-string
                  (read-number "Insert N commits from HEAD: " 5
                               'prot-vc--log-insert-num-hist))))
    (insert
     (with-temp-buffer
       (apply 'vc-git-command t nil nil
              (list "log" "--pretty=format:%h  %cs  %s" "-n" number "--"))
       (buffer-string)))
    (add-to-history 'prot-vc--log-insert-num-hist number)))

(autoload 'log-view-current-entry "log-view")
(autoload 'dired-get-marked-files "dired")

(defun prot-vc--commit-num ()
  "Determime whether `prot-vc-log-limit' is a positive integer."
  (let ((num prot-vc-log-limit))
    (if (and (integerp num)
             (&gt; num 0))
        num
      (error "'%s' is not a valid number" num))))

;;;###autoload
(defun prot-vc-custom-log (&amp;optional arg)
  "Like `vc-print-log' but for a custom fileset.

With optional prefix ARG (\\[universal-argument]), prompt for a
number to limit the log to.  Then prompt the user for matching
files in the `default-directory' with `completing-read-multiple'.
The default limit is controlled by the `prot-vc-log-limit'
variable.

In a `dired-mode' buffer, print log for the file at point, or any
marked files, except for when a double prefix argument is passed.
A single prefix arg still provides for a limit to the log.

With a double prefix ARG, prompt for a limit and produce a log
that covers all files in the present directory."
  (interactive "P")
  (let* ((lim (if arg
                  (read-number "Limit log to N entries: " 5)
                (prot-vc--commit-num)))
         (dir default-directory)
         (dotless directory-files-no-dot-files-regexp)
         (files (directory-files dir nil dotless t))
         (set (cond                     ; REVIEW: this is confusing
               ((equal arg '(16))
                files)
               ((eq major-mode 'dired-mode) ; REVIEW: any downside over `derived-mode-p'?
                (dired-get-marked-files t nil))
               (t
                (completing-read-multiple
                 "Select files in current dir: " files
                 #'prot-common-crm-exclude-selected-p t))))
         (backend (vc-backend set))
         (vc-log-short-style (if (&gt; (length set) 1) '(file) '(directory))))
    (vc-print-log-internal backend set nil nil lim nil)))

(autoload 'log-view-msg-prev "log-view")
(autoload 'log-view-msg-next "log-view")
(autoload 'log-view-toggle-entry-display "log-view")

(defvar vc-git-root-log-format)

;;;###autoload
(defun prot-vc-log-view-toggle-entry-all ()
  "Run `log-view-toggle-entry-display' on all commits."
  (interactive)
  (let ((oldlines (count-lines (point-min) (point-max)))
        (point (point))
        (newlines)
        (commits (count-matches (nth 1 vc-git-root-log-format)
                                (point-min) (point-max)))
        (limit prot-vc-log-bulk-action-limit))
    (cond
     ((&lt;= commits limit)
      (save-excursion
        (goto-char (point-max))
        (while (not (eq (line-number-at-pos) 1))
          (log-view-msg-prev)
          (log-view-toggle-entry-display))
        (goto-char point)
        (setq newlines (count-lines (point-min) (point-max))))
      (when (&gt; newlines oldlines)
        (log-view-msg-next))
      (recenter))
     (t
      (user-error "%d commits here; won't expand more than %d" commits limit)))))

;;;###autoload
(defun prot-vc-log-kill-hash ()
  "Save to `kill-ring' contextual commit hash in `vc-print-log'."
  (interactive)
  (let ((commit (cadr (log-view-current-entry (point) t))))
    (kill-new (format "%s" commit))
    (message "Copied: %s" commit)))

(defvar prot-vc--commit-hist '()
  "Minibuffer history for commit logs.")

(defvar prot-vc--patch-output-hist '()
  "Minibuffer history for `prot-vc-patch-dwim' output.")

(defun prot-vc--log-commit-hash (fn)
  "Extract commit hash from FN.
FN is assumed to be something like `prot-vc--log-commit-prompt'."
  (string-match "· \\([a-z0-9]*\\) ·" fn)
  (match-string-no-properties 1 fn))

(defun prot-vc--log-commit-prompt (&amp;optional prompt limit)
  "Select git log commit with completion.

Optional PROMPT pertains to the minibuffer's input field.  While
optional LIMIT will apply `prot-vc-log-limit' as a constraint,
instead of producing a complete log."
  (let ((text (or prompt "Select a commit: "))
        (vc (prot-vc--current-project))
        (num (cond
              ((integerp limit)
               (format "%d" limit))
              (limit
               (format "%d" (prot-vc--commit-num)))
              (t
               (format "%d" -1)))))
    (if vc
        (completing-read
         text
         (prot-common-completion-table
          'line
          (process-lines "git" "log" "--pretty=format:%d · %h · %cs %an: %s" "-n" num))
         nil t nil 'prot-vc--commit-hist)
      (error "'%s' is not under version control" default-directory))))

;;;###autoload
(defun prot-vc-git-patch-apply (patch project &amp;optional args)
  "Apply PATCH to current project using 'git am'.

PROJECT is a path to the root of a git repo, automatically
defaulting to the current project.  If none is found or if this
command is called with a prefix argument (\\[universal-argument])
prompt for a project instead.

When called non-interactively, ARGS is a list of strings with
command line flags for 'git am'.  Otherwise it takes the value of
`prot-vc-git-patch-apply-args'."
  (interactive
   (list
    (read-file-name "Path to patch: ")
    (when (or current-prefix-arg
              (null (prot-vc--current-project)))
      (project-prompt-project-dir))))
  ;; FIXME 2021-06-30: Avoid calling `prot-vc--current-project' twice
  (let* ((default-directory (or project (prot-vc--current-project)))
         (buf-name prot-vc-shell-output)
         (buf (get-buffer-create buf-name))
         (resize-mini-windows nil)
         (arguments (or args prot-vc-git-patch-apply-args))
         (arg-string (mapconcat #'identity arguments " ")))
    (shell-command (format "git am %s %s" arg-string patch) buf)))

;;;###autoload
(defun prot-vc-git-patch-create-dwim (&amp;optional arg)
  "Do-What-I-mean to output Git patches to a directory.

When the region is active inside of a Log View buffer, produce
patches for the commits within that range.  Remember how Git
interprets those ranges where the base commit is the one before
the earliest in the range: if you need to produce patches for the
topmost 4 commits, you must include the last 5 in the region.

With no active region, and while in a Log View buffer, a patch is
produced for the commit at point.

While not in a Log View buffer, prompt for a single commit to
produce a patch for.

Optional prefix ARG (\\[universal-argument]) prompts for a commit
using completion.  The selected item is used as the base of a
range against HEAD (in the format of 'base..HEAD').  When in Log
View buffers, and while no region is active, ARG will skip the
check for the commit at point in order to produce the prompt for
a base commit.  If the region is active in Log View buffers, ARG
is ignored.

Whatever the case, the list of completion candidates for commits
is always confined to `prot-vc-log-limit'."
  (interactive "P")
  (let* ((vc-dir (or (prot-vc--current-project)
                     default-directory))
         (dirs (append (list vc-dir) prot-vc-patch-output-dirs))
         (out-dir
          (completing-read
           "Output directory: "
           (prot-common-completion-table 'file dirs)
           nil t nil 'prot-vc--patch-output-hist))
         (buf (get-buffer-create prot-vc-shell-output)))
    (cond
     ((and (use-region-p) (derived-mode-p 'log-view-mode))
      (let* ((beg (region-beginning))
             (end (region-end))
             (one (cadr (log-view-current-entry beg t)))
             (two (cadr (log-view-current-entry end t)))
             (line-count (count-lines beg end))
             (range (if (&gt; line-count 1)
                        (cond
                         ((&gt; beg end)
                          (format "%s..%s" one two))
                         ((&lt; beg end)
                          (format "%s..%s" two one)))
                      (format "-1 %s" (cadr (log-view-current-entry (point) t))))))
        (shell-command
         (format "git format-patch %s -o %s --" range out-dir) buf)
        (message "Prepared patch for `%s' and sent it to %s"
                 (propertize range 'face 'bold)
                 (propertize out-dir 'face 'success))))
     (arg
      (let ((base (prot-vc--log-commit-hash
                   (prot-vc--log-commit-prompt
                    "Select base commit for base..HEAD: " t))))
        (shell-command
         (format "git format-patch %s..HEAD -o %s --" base out-dir) buf)
        (message "Prepared patch for `%s..HEAD' and sent it to %s"
                 (propertize base 'face 'bold)
                 (propertize out-dir 'face 'success))))
     (t
      (let* ((commit-at-point (when (derived-mode-p 'log-view-mode)
                                (cadr (log-view-current-entry (point) t))))
             (commit (if (not commit-at-point)
                         (prot-vc--log-commit-hash
                          (prot-vc--log-commit-prompt
                           "Prepare patch for commit: " t))
                       commit-at-point)))
        (shell-command
         (format "git format-patch -1 %s -o %s --" commit out-dir) buf)
        (message "Prepared patch for `%s' and sent it to %s"
                 (propertize commit 'face 'bold)
                 (propertize out-dir 'face 'success))
        (add-to-history 'prot-vc--commit-hist commit)))
     (add-to-history 'prot-vc--patch-output-hist out-dir))))

;;;###autoload
(defun prot-vc-git-show (&amp;optional limit)
  "Run git show for commit selected via completion.
With optional LIMIT as a prefix arg (\\[universal-argument]),
prompt for a number to confine the log to.  If LIMIT is a number,
accept it directly.  In the absence of LIMIT, `prot-vc-log-limit'
will be used instead."
  (interactive "P")
  (let* ((num (cond
               ((and limit (listp limit))
                (read-number "Limit to N commits: " 100))
               (limit
                (prefix-numeric-value limit))
               (t
                t)))
         (commit (prot-vc--log-commit-hash
                  (prot-vc--log-commit-prompt "Commit to git-show: " num)))
         (buf-name prot-vc-shell-output)
         (buf (get-buffer-create buf-name)))
    (shell-command (format "git show %s -u --stat -1 --" commit) buf)
    (with-current-buffer buf-name
      (setq-local revert-buffer-function nil)
      (diff-mode))
    (add-to-history 'prot-vc--commit-hist commit)))

(autoload 'vc-git-grep "vc-git")

;;;###autoload
(defun prot-vc-git-grep (regexp)
  "Run 'git grep' for REGEXP in current project.
This is a simple wrapper around `vc-git-grep' to streamline the
basic task of searching for a regexp in the current project.  Use
the original command for its other features."
  (interactive
   (list (read-regexp "git-grep for PATTERN: "
                      nil 'grep-history)))
  (vc-git-grep regexp "*" (prot-vc--current-project)))

(autoload 'vc-git-region-history-mode "vc-git")

;;;###autoload
(defun prot-vc-git-log-grep (pattern &amp;optional diff)
  "Run ’git log --grep’ for PATTERN.
With optional DIFF as a prefix (\\[universal-argument])
argument, also show the corresponding diffs."
  (interactive
   (list (read-regexp "Run 'git log --grep' for PATTERN")
         current-prefix-arg))
  (let* ((buf-name prot-vc-shell-output)
         (buf (get-buffer-create buf-name))
         (diffs (if diff "-p" ""))
         (type (if diff 'with-diff 'log-search))
         (resize-mini-windows nil))
    (shell-command (format "git log %s --grep=%s -E --" diffs pattern) buf)
    (with-current-buffer buf
      (setq-local vc-log-view-type type)
      (setq-local revert-buffer-function nil)
      (vc-git-region-history-mode)
      (setq-local log-view-vc-backend 'git))))

(defun prot-vc-git--file-rev (file &amp;optional limit)
  "Select revision for FILE using completion.
Optionally apply LIMIT to the log."
  (let ((num (cond
              ((integerp limit)
               (format "%d" limit))
              (limit
               (format "%d" (prot-vc--commit-num)))
              (t
               (format "%d" -1)))))
    (completing-read
     (format "Find revision for %s: " file)
     (prot-common-completion-table
      'line
      (process-lines "git" "log" "--pretty=format:%d · %h · %cs %an: %s" "-n" num "--" file))
     nil t nil 'prot-vc--commit-hist)))

;;;###autoload
(defun prot-vc-git-find-revision (&amp;optional limit)
  "Visit a version of the current file using completion.
With optional LIMIT as a prefix arg (\\[universal-argument]),
prompt for a number to confine the log to.  If LIMIT is a number,
accept it directly.  In the absence of LIMIT, `prot-vc-log-limit'
will be used instead."
  (interactive "P")
  (let* ((num (cond
               ((and limit (listp limit))
                (read-number "Limit to N commits: " 100))
               (limit
                (prefix-numeric-value limit))
               (t
                t)))
         (rev (prot-vc--log-commit-hash
               (prot-vc-git--file-rev buffer-file-name num))))
    (switch-to-buffer-other-window
     (vc-find-revision buffer-file-name rev))
    (add-to-history 'prot-vc--commit-hist rev)))

(autoload 'vc-annotate-mode "vc-annotate")
(autoload 'vc-annotate-display-select "vc-annotate")

;; XXX NOTE XXX 2021-07-31: Those are meant to enable `revert-buffer'
;; inside of `prot-vc-git-blame-region-or-file'.  I do not know whether
;; this is a good approach.  It seems very convoluted and fragile.  But
;; anyway, I tried and it seems to work.
(defvar prot-vc--blame-beg nil)
(defvar prot-vc--blame-end nil)
(defvar prot-vc--blame-file nil)
(defvar prot-vc--blame-origin nil)

;;;###autoload
(defun prot-vc-git-blame-region-or-file (beg end &amp;optional file)
  "Git blame lines in region between BEG and END.
Optionally specify FILE, else default to the current one."
  (interactive "r")
  (let* ((buf-name prot-vc-shell-output)
         (buf (get-buffer-create buf-name))
         (f (or file buffer-file-name))
         (backend (vc-backend f))
         (rev (vc-working-revision f))
         (e (if (region-active-p) beg (point-min)))
         (b (if (region-active-p) end (- (point-max) 1)))
         (beg-line (line-number-at-pos b t))
         (end-line (line-number-at-pos e t))
         (default-directory (prot-vc--current-project))
         (origin (current-buffer))
         (resize-mini-windows nil))
    (shell-command
     (format "git blame -L %d,%d -- %s" beg-line end-line f) buf)
    ;; FIXME 2021-07-31: Learn how to implement a cleaner
    ;; `revert-buffer'.  See NOTE above.
    (setq-local prot-vc--blame-beg beg
                prot-vc--blame-end end
                prot-vc--blame-file f
                prot-vc--blame-origin origin)
    (with-current-buffer buf-name
      (unless (equal major-mode 'vc-annotate-mode)
        (vc-annotate-mode))
      ;; FIXME 2021-07-31: Same issue with `revert-buffer'.
      (setq-local revert-buffer-function
                  (lambda (_ignore-auto _noconfirm)
                    (let ((inhibit-read-only t))
                      (with-current-buffer origin
                        (prot-vc-git-blame-region-or-file prot-vc--blame-beg
                                                          prot-vc--blame-end
                                                          prot-vc--blame-file)))))
      (setq-local vc-annotate-backend backend)
      (setq-local vc-annotate-parent-file f)
      (setq-local vc-annotate-parent-rev rev)
      (setq-local vc-annotate-parent-display-mode 'scale)
      (vc-annotate-display-select buf 'fullscale))))

(autoload 'vc-refresh-state "vc-hooks")

;;;###autoload
(defun prot-vc-git-reset (&amp;optional limit)
  "Select commit to 'git reset --soft' back to.
With optional LIMIT as a prefix arg (\\[universal-argument]),
prompt for a number to confine the log to.  If LIMIT is a number,
accept it directly.  In the absence of LIMIT, `prot-vc-log-limit'
will be used instead."
  (interactive "P")
  (let* ((num (cond
               ((and limit (listp limit))
                (read-number "Limit to N commits: " 50))
               (limit
                (prefix-numeric-value limit))
               (t
                t)))
         (commit (prot-vc--log-commit-hash
                  (prot-vc--log-commit-prompt "Run 'git reset --soft' on: " num)))
         (buf-name prot-vc-shell-output)
         (buf (get-buffer-create buf-name)))
    (when (yes-or-no-p (format "Run 'git reset --soft %s'?" commit))
      (shell-command (format "git reset --soft %s --quiet --" commit) buf)
      (vc-refresh-state))))

;;;###autoload
(defun prot-vc-git-log-reset (&amp;optional hard)
  "Select commit in VC Git Log to 'git reset --soft' back to.
With optional prefix argument (\\[universal-argument]) for HARD,
pass the '--hard' flag instead."
  (interactive "P")
  (let* ((commit (cadr (log-view-current-entry (point) t)))
         (buf-name prot-vc-shell-output)
         (buf (get-buffer-create buf-name))
         (flag (if hard "--hard" "--soft")))
    (when (yes-or-no-p (format "Run 'git reset %s %s'?" flag commit))
      (shell-command (format "git reset %s %s --quiet --" flag commit) buf)
      (revert-buffer))))

;;;###autoload
(defun prot-vc-git-checkout-remote (remote)
  "Checkout new local branch tracking REMOTE (git checkout -b)."
  (interactive
   (list (completing-read
          "Select remote tracking branch: "
          (mapcar #'string-trim (process-lines "git" "branch" "-r"))
          nil t)))
  (let* ((name (split-string remote "\\(-&gt;\\|[\/]\\)" t "[\s\t]+"))
         (local (if (&gt; (length name) 1)
                    (car (reverse name)) ; Better way than car reverse?
                  (car name))))
    (shell-command (format "git checkout -b %s %s" local remote))))

;;;; User Interface setup

;; This is a tweaked variant of `vc-git-expanded-log-entry'
(defun prot-vc-git-expanded-log-entry (revision)
  "Expand git commit message for REVISION."
  (with-temp-buffer
    (apply 'vc-git-command t nil nil (list "log" revision "--stat" "-1" "--"))
    (goto-char (point-min))
    (unless (eobp)
      (while (re-search-forward "^" nil t)
        (replace-match "  ")
        (forward-line))
      (concat "\n" (buffer-string)))))

(defun prot-vc-git-expand-function ()
  "Set `log-view-expanded-log-entry-function' for `vc-git'."
  (when (eq vc-log-view-type 'short)
    (setq-local log-view-expanded-log-entry-function
                #'prot-vc-git-expanded-log-entry)))

(defvar prot-vc-git-log-view-mode-hook nil
  "Hook that runs after `vc-git-log-view-mode'.")

(defun prot-vc-git-log-view-add-hook (&amp;rest _)
  "Run `prot-vc-git-log-view-mode-hook'."
  (run-hooks 'prot-vc-git-log-view-mode-hook))

(declare-function log-edit-add-field "log-edit")

(defun prot-vc--format-git-comment (branch remote files &amp;optional commits)
  "Add Git Log Edit comment with BRANCH, REMOTE, FILES, COMMITS."
  (let ((log (if commits (concat "\n# Recent commits:\n#\n" commits "\n#") "")))
    (concat
     "\n\n# ---\n# "
     "Files to be committed to branch " "`" branch "' tracking `" remote "':"
     "\n#\n" files "\n#" log
     "\n# All lines starting with `#' are ignored.")))

(defun prot-vc-git-log-edit-comment (&amp;optional no-headers)
  "Append comment block to Git Log Edit buffer.
With optional NO-HEADERS skip the step of inserting the special
headers 'Amend' and 'Summary'."
  (let* ((branch-name (process-lines "git" "branch" "--show-current"))
         (branch (or (car branch-name) "Detached HEAD"))
         (remotes (process-lines "git" "branch" "-r"))
         (remote-name (if remotes
                          (cl-remove-if-not (lambda (s)
                                              (string-match-p "-&gt;" s))
                                            remotes)
                        "None"))
         (remote (if (and remote-name (listp remote-name))
                     (cadr (split-string (car remote-name) "-&gt;" t "[\s\t]+"))
                   "No Remote Found"))
         (files (mapconcat (lambda (x)
                             (concat "#   " x))
                           (log-edit-files)
                           "\n"))
         (commits (when (and prot-vc-git-log-edit-show-commits
                             (ignore-errors (process-lines "git" "log" "-1")))
                    (mapconcat (lambda (x)
                                 (concat "#   " x))
                               (process-lines
                                "git" "log" "--pretty=format:%h  %cs  %s"
                                (format "-n %d" prot-vc-git-log-edit-show-commit-count))
                               "\n"))))
    (unless no-headers
      (save-excursion
        (rfc822-goto-eoh)
        (unless (re-search-backward "Amend: .*" nil t)
          (log-edit-add-field "Amend" ""))
        (rfc822-goto-eoh)
        (unless (re-search-backward "Summary: .*" nil t)
          (log-edit-add-field "Summary" ""))))
    (goto-char (point-max))
    (insert "\n")
    (insert (prot-vc--format-git-comment branch remote files commits))
    (rfc822-goto-eoh)
    (when (looking-at "\n") (forward-char -1))))

;;;###autoload
(defun prot-vc-git-log-edit-previous-comment (arg)
  "Cycle backwards through comment history.
With a numeric prefix ARG, go back ARG comments."
  (interactive "*p")
  (let ((len (ring-length log-edit-comment-ring)))
    (if (&lt;= len 0)
        (progn (message "Empty comment ring") (ding))
      ;; Don't use `erase-buffer' because we don't want to `widen'.
      (delete-region (point-min) (point-max))
      (setq log-edit-comment-ring-index (log-edit-new-comment-index arg len))
      (message "Comment %d" (1+ log-edit-comment-ring-index))
      (insert (ring-ref log-edit-comment-ring log-edit-comment-ring-index))
      (prot-vc-git-log-edit-comment t)
      (save-excursion
        (goto-char (point-min))
        (search-forward "# ---")
        (forward-line -1)
        (delete-blank-lines)
        (newline 2)))))

;;;###autoload
(defun prot-vc-git-log-edit-next-comment (arg)
  "Cycle forwards through comment history.
With a numeric prefix ARG, go forward ARG comments."
  (interactive "*p")
  (prot-vc-git-log-edit-previous-comment (- arg)))

(defvar prot-vc--log-edit-comment-hist '()
  "History of inputs for `prot-vc-git-log-edit-complete-comment'.")

(defun prot-vc--log-edit-complete-prompt (comments)
  "Select entry from COMMENTS."
  (completing-read
   "Select comment: "
   comments nil t nil 'prot-vc--log-edit-comment-hist))

;;;###autoload
(defun prot-vc-git-log-edit-complete-comment ()
  "Insert text from Log Edit history ring using completion."
  (interactive)
  (let* ((newline (propertize "^J" 'face 'escape-glyph))
         (ring (ring-elements log-edit-comment-ring))
         (completions
          (mapcar (lambda (s)
                    (string-replace "\n" newline s))
                  ring))
         (selection (prot-vc--log-edit-complete-prompt completions))
         (comment (string-replace newline "\n" selection)))
    (add-to-history 'prot-vc--log-edit-comment-hist comment)
    (delete-region (point-min) (point-max))
    (insert comment)
    (prot-vc-git-log-edit-comment t)
    (save-excursion
      (goto-char (point-min))
      (search-forward "# ---")
      (forward-line -1)
      (delete-blank-lines)
      (newline 2))))

(defun prot-vc-git-log-remove-comment ()
  "Remove Git Log Edit comment, empty lines; keep final newline."
  (let ((buffer (get-buffer "*vc-log*"))) ; REVIEW: This is fragile
    (with-current-buffer (when (buffer-live-p buffer) buffer)
      (save-excursion
        (goto-char (point-min)))
      (when (derived-mode-p 'log-edit-mode)
        (flush-lines "^#")))))

;;;###autoload
(defun prot-vc-git-log-edit-toggle-amend ()
  "Toggle 'Amend' header for current Log Edit buffer.

Setting the header to 'yes' means that the current commit will
edit the previous one.

Unlike `vc-git-log-edit-toggle-amend', only change the state of
the 'Amend' header, without attempting to alter the contents of
the buffer."
  (interactive)
  (when (log-edit-toggle-header "Amend" "yes")))

(defun prot-vc--buffer-string-omit-comment ()
  "Remove Git comment and empty lines from buffer string."
  (let* ((buffer (get-buffer "*vc-log*"))
         (string (when buffer
                   (with-current-buffer buffer
                     (buffer-substring-no-properties (point-min) (point-max))))))
    (when string
      (replace-regexp-in-string "^#.*" "" string))))

(defvar log-edit-comment-ring)
(autoload 'ring-empty-p "ring")
(autoload 'ring-ref "ring")
(autoload 'ring-insert "ring")

(defun prot-vc-git-log-edit-remember-comment (&amp;optional comment)
  "Store Log Edit text or optional COMMENT.
Remove special Git comment block before storing the genuine
commit message."
  (let ((commit (or comment (gensym))))
    (setq commit (prot-vc--buffer-string-omit-comment))
    (when (or (ring-empty-p log-edit-comment-ring)
              (not (equal commit (ring-ref log-edit-comment-ring 0))))
      (ring-insert log-edit-comment-ring commit))))

(declare-function log-edit-show-diff "log-edit")

(defvar prot-vc--current-window-configuration nil
  "Current window configuration for use with Log Edit.")

(defvar prot-vc--current-window-configuration-point nil
  "Point in current window configuration for use with Log Edit.")

(defun prot-vc--store-window-configuration ()
  "Store window configuration before calling `vc-start-logentry'.
This should be called via `prot-vc-git-pre-log-edit-hook'."
  (setq prot-vc--current-window-configuration (current-window-configuration))
  (setq prot-vc--current-window-configuration-point (point)))

(defvar prot-vc-git-pre-log-edit-hook nil
  "Hook that runs right before `vc-start-logentry'.")

(defun prot-vc-git-pre-log-edit (&amp;rest _)
  "Run `prot-vc-git-pre-log-edit-hook'.
To be used as advice before `vc-start-logentry'."
  (run-hooks 'prot-vc-git-pre-log-edit-hook))

(defun prot-vc--log-edit-restore-window-configuration ()
  "Set window configuration to the pre Log Edit state."
  (when prot-vc--current-window-configuration
    (set-window-configuration prot-vc--current-window-configuration))
  (when prot-vc--current-window-configuration-point
    (goto-char prot-vc--current-window-configuration-point)))

(defun prot-vc--log-edit-diff-window-configuration ()
  "Show current diff for Git Log Edit buffer."
  (let ((buffer (get-buffer "*vc-log*")))
    (with-current-buffer (if (buffer-live-p buffer)
                             buffer
                           (window-buffer (get-mru-window)))
      (delete-other-windows)
      (when (ignore-errors ; This condition saves us from error on new repos
              (process-lines "git" "--no-pager" "diff-index" "-p" "HEAD" "--"))
        (log-edit-show-diff))
      (other-window -1))))

(defun prot-vc--kill-log-edit ()
  "Local hook to restore windows when Log Edit buffer is killed."
  (when (or (derived-mode-p 'log-edit-mode)
            (derived-mode-p 'diff-mode))
    (add-hook 'kill-buffer-hook #'prot-vc--log-edit-restore-window-configuration 0 t)))

(defvar prot-vc-git-log-edit-done-hook nil
  "Hook that runs after `prot-vc-git-log-edit-done'.")

;; FIXME: Why does `prot-vc-git-log-remove-comment' not work when added
;; to `log-edit-done-hook'?
;;;###autoload
(defun prot-vc-git-log-edit-done ()
  "Remove Git Log Edit comments and commit change set.
This is a thin wrapper around `log-edit-done', which first calls
`prot-vc-git-log-remove-comment'."
  (interactive)
  (prot-vc-git-log-remove-comment)
  (log-edit-done)
  (run-hooks 'prot-vc-git-log-edit-done-hook))

(defface prot-vc-git-log-edit-file-name
  '((default :inherit font-lock-comment-face)
    (((class color) (min-colors 88) (background light))
     :foreground "#2a486a")
    (((class color) (min-colors 88) (background dark))
     :foreground "#b0d6f5")
    (t :foreground "cyan"))
  "Face for file names in VC Git Log Edit buffers.")

(defface prot-vc-git-log-edit-local-branch-name
  '((default :inherit font-lock-comment-face)
    (((class color) (min-colors 88) (background light))
     :foreground "#0031a9")
    (((class color) (min-colors 88) (background dark))
     :foreground "#2fafff")
    (t :foreground "blue"))
  "Face for local branch name in VC Git Log Edit buffers.")

(defface prot-vc-git-log-edit-remote-branch-name
  '((default :inherit font-lock-comment-face)
    (((class color) (min-colors 88) (background light))
     :foreground "#55348e")
    (((class color) (min-colors 88) (background dark))
     :foreground "#cfa6ff")
    (t :foreground "magenta"))
  "Face for remote branch name in VC Git Log Edit buffers.")

(defconst prot-vc-git-log-edit-font-lock
  '(("^#.*"
     (0 'font-lock-comment-face))
    ("^#.*`\\(.+?\\)'.*`\\(.+?\\)'"
     (1 'prot-vc-git-log-edit-local-branch-name t)
     (2 'prot-vc-git-log-edit-remote-branch-name t))
    ("^#[\s\t][\s\t]+\\(.+\\)"
     (1 'prot-vc-git-log-edit-file-name t)))
  "Fontification rules for Log Edit buffers.")

(defun prot-vc-git-log-edit-extra-keywords ()
  "Apply `prot-vc-git-log-edit-font-lock' to Log Edit buffers."
  (font-lock-flush (point-min) (point-max))
  (font-lock-add-keywords nil prot-vc-git-log-edit-font-lock nil))

(autoload 'vc-git-log-view-mode "vc-git")
(autoload 'vc-git-checkin "vc-git")
(declare-function log-edit-show-files "log-edit")
(declare-function log-edit-kill-buffer "log-edit")
(declare-function log-edit-done "log-edit")
(declare-function log-edit-remember-comment "log-edit")
(declare-function vc-git-log-edit-toggle-amend "log-edit")
(defvar vc-git-log-edit-mode-map)

;;;###autoload
(define-minor-mode prot-vc-git-setup-mode
  "Extend `vc-git' Log View and Log Edit buffers.

Tweak the format of expanded commit messages in Log View buffers.  The
full information now includes a diff stat as well as all affected file
paths.  Those files can then be used for file-at-point operations like
`project-find-file'.

Make Log Edit window configurations split between the message
composition buffer and the corresponding diff view: the previous window
configuration is restored upon the successful conclusion of the commit
or its termination by means of `log-edit-kill-buffer'.

Append a comment block to the Log Edit buffer with information about the
files being committed and the branch they are a part of.  When
`prot-vc-git-log-edit-show-commits' is non-nil, also include a commit
log.  The number of commits in that log is controlled by
`prot-vc-git-log-edit-show-commit-count'.

For Log Edit buffers, bind C-c C-c to `prot-vc-git-log-edit-done' which
is designed to remove the comment block before checking in the changes.
Rebind other keys in the same vein.  `prot-vc-git-log-edit-done' calls
the normal hook `prot-vc-git-log-edit-done-hook' which is used to
restore the window layout.

Set up font-lock directives to make the aforementioned block look like a
comment in Log Edit buffers.  Also highlight file and branch names
inside the comment block."
  :init-value nil
  :global t
  (if prot-vc-git-setup-mode
      (progn
        ;; Log view expanded commits
        (advice-add #'vc-git-log-view-mode :after #'prot-vc-git-log-view-add-hook)
        (add-hook 'prot-vc-git-log-view-mode-hook #'prot-vc-git-expand-function)
        ;; Append comment block in Log edit showing branch and files.
        ;; This means that we no longer need the files' window to pop up
        ;; automatically
        (add-hook 'log-edit-hook #'prot-vc-git-log-edit-comment)
        (remove-hook 'log-edit-hook #'log-edit-show-files)
        ;; Window configuration with just the commit and the diff
        ;; (restores previous state after finalising or aborting the
        ;; commit).
        (advice-add #'vc-start-logentry :before #'prot-vc-git-pre-log-edit)
        (add-hook 'prot-vc-git-pre-log-edit-hook #'prot-vc--store-window-configuration)
        (advice-add #'log-edit-remember-comment :around #'prot-vc-git-log-edit-remember-comment)
        (let ((map vc-git-log-edit-mode-map))
          (define-key map (kbd "C-c C-c") #'prot-vc-git-log-edit-done)
          (define-key map (kbd "C-c C-e") #'prot-vc-git-log-edit-toggle-amend)
          (define-key map (kbd "M-p") #'prot-vc-git-log-edit-previous-comment)
          (define-key map (kbd "M-n") #'prot-vc-git-log-edit-next-comment)
          (define-key map (kbd "M-s") #'prot-vc-git-log-edit-complete-comment)
          (define-key map (kbd "M-r") #'prot-vc-git-log-edit-complete-comment))
        (add-hook 'log-edit-mode-hook #'prot-vc--kill-log-edit)
        (add-hook 'prot-vc-git-log-edit-done-hook #'prot-vc--log-edit-restore-window-configuration)
        (add-hook 'log-edit-hook #'prot-vc--log-edit-diff-window-configuration)
        ;; Extra font lock rules for Log Edit comment block
        (add-hook 'log-edit-hook #'prot-vc-git-log-edit-extra-keywords))
    (advice-remove #'vc-git-log-view-mode #'prot-vc-git-log-view-add-hook)
    (remove-hook 'prot-vc-git-log-view-mode-hook #'prot-vc-git-expand-function)
    (remove-hook 'log-edit-hook #'prot-vc-git-log-edit-comment)
    (add-hook 'log-edit-hook #'log-edit-show-files)
    (advice-remove #'vc-start-logentry #'prot-vc-git-pre-log-edit)
    (remove-hook 'prot-vc-git-pre-log-edit-hook #'prot-vc--store-window-configuration)
    (advice-remove #'log-edit-remember-comment #'prot-vc-git-log-edit-remember-comment)
    (let ((map vc-git-log-edit-mode-map))
      (define-key vc-git-log-edit-mode-map (kbd "C-c C-c") #'log-edit-done)
      (define-key vc-git-log-edit-mode-map (kbd "C-c C-e") #'vc-git-log-edit-toggle-amend)
      (define-key map (kbd "M-p") #'log-edit-previous-comment)
      (define-key map (kbd "M-n") #'log-edit-next-comment)
      (define-key map (kbd "M-s") #'log-edit-comment-search-forward)
      (define-key map (kbd "M-r") #'log-edit-comment-search-backward))
    (remove-hook 'log-edit-mode-hook #'prot-vc--kill-log-edit)
    (remove-hook 'prot-vc-git-log-edit-done-hook #'prot-vc--log-edit-restore-window-configuration)
    (remove-hook 'log-edit-hook #'prot-vc--log-edit-diff-window-configuration)
    (remove-hook 'log-edit-hook #'prot-vc-git-log-edit-extra-keywords)))

(provide 'prot-vc)
;;; prot-vc.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301" class="outline-5">
<h5 id="h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301"><span class="section-number-5">5.6.2.1.</span> git-email.el for preparing patches</h5>
<div class="outline-text-5" id="text-h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301">
<p>
This neat library by Xinglu Chen streamlines the process of formatting
and sending Git patches via email, all from the comfort of Emacs.  Its
main point of entry is the command <code>git-email-format-patch</code>, which prompts
you for a commit that is read as the range between the current HEAD and
the one you specify.  In doing so, it allows you to prepare a series of
patches, using the correct message headers.
</p>

<p>
<code>git-email.el</code> is meant to work with the standard message composition
buffer, such as the one you get when you call <code>M-x compose-email</code> (by
default that command is bound to <code>C-x m</code> and I keep it that way).  Email
clients like Gnus and Notmuch are also supported.  For my case as a user
of the latter, I just activate <code>git-email-notmuch-mode</code> in order to add
the relevant settings to the message composition buffers.  For more on
Notmuch and all related configurations, refer to the mega-section on
<a href="#h:5ad80664-3163-4d9d-be65-462637d77903">Email settings</a>.
</p>

<p>
So here is the typical workflow with this package:
</p>

<ul class="org-ul">
<li>Visit a file and make some changes.</li>
<li>Commit those changes.</li>
<li>Invoke <code>git-email-format-patch</code> and select the base commit against which
your commits are to be read.  So if your commit is the current HEAD,
then just pick the one right before.</li>
<li>Pass any optional flags.  Multiple flags can be completed against
using a comma as a separator (or whatever your <code>crm-separator</code> is).</li>
<li>Fill in the email details, which probably is just an email address
(and a cover letter, if you use that option).</li>
<li>Send.  Done!</li>
</ul>

<p>
The maintainer of the project will then be able to apply your patch,
using standard git commands (read the manpages of <code>git-apply</code> for
attachments and <code>git-am</code> for mailbox-type patches).
</p>

<p>
Alternatively, you may already have a patch available and wish to email
it directly.  Visit its directory and with the point over it call the
command <code>git-email-send-email</code>.  This also works for the marked items of
the Dired buffer (<a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">Dired (directory editor, file manager)</a>).
</p>

<p>
Overall, <code>git-email.el</code> is a welcome addition to the ecosystem.  Apart
from also working with the built-in Version Control framework of Emacs
(consult <a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a>), it offers us
the means to conveniently implement a truly decentralised workflow for
collaboration: git and email empower you to utilise the tools you want,
instead of forcing you through some unwieldy pull/merge request process
that certain git forges encourage.  I prefer this approach and am eager
to see it getting more widespread adoption.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; git-email.el for preparing patches
;; Project repo: &lt;https://git.sr.ht/~yoctocell/git-email&gt;.  This is one
;; of the packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'git-email
  (with-eval-after-load 'notmuch
    (require 'git-email-notmuch)
    (git-email-notmuch-mode 1))
  (define-key global-map (kbd "C-x v RET") #'git-email-format-patch) ; VC prefix and C-m
  (define-key dired-mode-map (kbd "C-x v RET") #'git-email-send-email))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:76d1b392-e693-40dc-b320-d4c1047115ab" class="outline-4">
<h4 id="h:76d1b392-e693-40dc-b320-d4c1047115ab"><span class="section-number-4">5.6.3.</span> Interactive and powerful git front-end (Magit)</h4>
<div class="outline-text-4" id="text-h:76d1b392-e693-40dc-b320-d4c1047115ab">
<p>
As noted in the <a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">section on the built-in Version Control framework</a> I use
Magit for easy access to the <i>advanced features of Git</i>.  While I rely on
the built-in tools for all day-to-day operations.
</p>

<p>
Magit offers a modal interface where the full power of <code>git</code> is neatly
organised in sets of keys that are directly accessible without holding
down any modifiers.
</p>

<p>
While inside the <code>magit-status</code> buffer, hit <code>?</code> to produce a transient menu
with the possible vectors to action.  Do it again inside each of the
Magit buffers to view the keys that work for their context.
</p>

<p>
Consider viewing my <a href="https://protesilaos.com/codelog/2020-04-04-emacs-intro-magit/">Introduction to Magit</a> (2020-04-04) for how to stage
diffs, commit changes, view logs, create branches, and so on.
</p>

<p>
Magit has great defaults and it should work admirably without any
further tweaks or extra setup.  That granted, the <code>git-commit</code> package
(part of Magit) is configured in accordance with the guidelines provided
by this article on <a href="https://chris.beams.io/posts/git-commit/">writing a Git commit message</a>.  The gist is to compose
commits that are clean and easy to read.  The <code>fill-column</code> is set
elsewhere in this document to 72 characters long.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Interactive and powerful git front-end (Magit)
(prot-emacs-elpa-package 'magit
  (setq magit-define-global-key-bindings nil)
  (define-key global-map (kbd "C-c g") #'magit-status)

  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))

  (require 'magit-diff)
  (setq magit-diff-refine-hunk t)

  (require 'magit-repos)
  (setq magit-repository-directories
        '(("~/Git/Projects" . 1))))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1" class="outline-4">
<h4 id="h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1"><span class="section-number-4">5.6.4.</span> Smerge and Ediff</h4>
<div class="outline-text-4" id="text-h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1">
<p>
<b>Read this section, because it matters more than the code below it.</b>
</p>

<p>
Sometimes we face a situation where we have conflicting versions of a
file and the version control backend cannot solve them on its own.  This
can happen fairly often when collaborating with other people or, more
generally, when we keep our work spread across multiple feature branches
with diverging histories.  Whenever such conflicts arise, Emacs will
automatically annotate the offending files with special markers that
show the conflicting differences.  Visiting those files will then
activate <code>smerge-mode</code>.  At which point we are in control.
</p>

<p>
Smerge revolves around the concept of dividing the conflicting part into
an "upper" (red) and a "lower" section (green), possibly with their
common ancestor or last point of convergence in the middle (yellow).
</p>

<p>
With this in mind we can operate on the marked differences by relying on
the functions that Smerge provides, all of which are accessed by default
through the common prefix of <code>C-c ^</code>.  Start by typing the prefix followed
by <code>C-h</code> to see all possible key chords.  These are the commands I have
used the most:
</p>

<ul class="org-ul">
<li><code>C-c ^ u</code> (<code>smerge-keep-upper</code>)</li>
<li><code>C-c ^ l</code> (<code>smerge-keep-lower</code>)</li>
<li><code>C-c ^ b</code> (<code>smerge-keep-base</code>)</li>
<li><code>C-c ^ a</code> (<code>smerge-keep-all</code>)</li>
<li><code>C-c ^ n</code> (<code>smerge-next</code>)</li>
<li><code>C-c ^ p</code> (<code>smerge-prev</code>)</li>
</ul>

<p>
Proceed to edit the file the way you want until no more conflicts exist.
You can also do things through manual editing, with standard commands
and motions, but that can be prone to errors (which lead to more
conflicts).  At any moment in this process, you can switch to <code>ediff</code>,
which offers a more powerful way of working with differences.  Type the
key chord <code>C-c ^ E</code> (<code>smerge-ediff</code>).
</p>

<p>
Ediff is a powerhouse that is likely to cover all your needs in this
area (including those you are not aware of).  For our purposes, what
matters is to understand the basic concepts.
</p>

<p>
The way this tool works is that it starts by producing a layout of the
two conflicting versions with access to a "control panel" for operating
on them.  By default, the panel is positioned on a new frame, but I find
that rather awkward&#x2014;my config puts it inside an Emacs window instead.
While focusing the control panel, you can move between each diff range
with <code>n</code> and <code>p</code>.  The focused section will be coloured using red, green,
and yellow, while all other diffs will be presented in gray.
</p>

<p>
On each diff, you have three options: to use the version of buffer A
(red), of buffer B (green), or a combination of the two.  The keys for
each of those are <code>a</code>, <code>b</code>, and <code>+</code> respectively.  Your choice will be
reflected in buffer C (the yellow one).  Use these to resolve all
conflicts and then quit the session with <code>q</code>.
</p>

<p>
Concerning the combination of versions between A and B, Ediff has the
behaviour of also inserting as plain text the annotation markers that
Smerge relied on.  As of this writing (2020-04-10), I am not aware of an
automatic or convenient way to omit those prior to confirming our edits.
To that end, I tweak the wording of the markers to some unique string
(see package below) and then run <code>flush-lines</code> to remove them before
saving the resulting buffer (so right after the <code>q</code>).  For more on this,
check <code>prot/ediff-flush-combination-pattern</code>.
</p>

<p>
For <code>git</code> users, to actually <i>reference the common ancestor</i> (the point
before the branching paths started) we must run this command once in our
command-line prompt (writes to your global <code>.gitconfig</code> file):
</p>

<pre class="example">
git config --global merge.conflictStyle diff3
</pre>

<p>
This is optional, but I find that I like it.  At any rate, the
configurations I have below are straightforward (learn more about this
powerful tool by hitting <code>?</code> inside of its control panel and by consulting
its comprehensive manual):
</p>

<ul class="org-ul">
<li>Do not keep all the buffers after exiting the Ediff session.</li>
<li>Keep buffers in an editable state.  Otherwise it is impossible to
perform the changes we are interested in.</li>
<li>Show the common ancestor in another buffer.  This helps provide
further context of how things took their form.</li>
<li>Show only the conflicting parts.  This is not a review of all diffs.</li>
<li>Prefer putting windows side-by-side, rather than one below the other.</li>
<li>Do not enter the ediff session in a new frame.  This also means that
the control panel will be inside an Emacs window (at the bottom part)
rather than in a tiny frame of its own.</li>
</ul>

<p>
There actually is nothing in terms of Smerge-related configurations.
The package is small and does one thing well.
</p>

<p>
Also watch my video of <a href="https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/">Smerge and Ediff for git conflict resolution</a>
(2020-04-10).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Smerge and Ediff
(prot-emacs-builtin-package 'smerge-mode)

(prot-emacs-builtin-package 'ediff
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("&lt;&lt;&lt;&lt;&lt;&lt;&lt; prot-ediff-combine Variant A" A
          "&gt;&gt;&gt;&gt;&gt;&gt;&gt; prot-ediff-combine Variant B" B
          "####### prot-ediff-combine Ancestor" Ancestor
          "======= prot-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun prot/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*prot-ediff.*" (point-min) (point-max) nil)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b" class="outline-3">
<h3 id="h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b"><span class="section-number-3">5.7.</span> Command-line shells</h3>
<div class="outline-text-3" id="text-h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b">
<p>
It should come to no surprise that Emacs can operate as both a <i>terminal
emulator for command line shells</i> and <i>toolkit for terminal emulators</i>.
The present section covers only the former category as I never use the
likes of <code>ansi-term</code> or <code>vterm</code>.
</p>
</div>

<div id="outline-container-h:103a8795-c29c-474f-9ddf-ecafaa2f6775" class="outline-4">
<h4 id="h:103a8795-c29c-474f-9ddf-ecafaa2f6775"><span class="section-number-4">5.7.1.</span> Eshell and prot-eshell.el</h4>
<div class="outline-text-4" id="text-h:103a8795-c29c-474f-9ddf-ecafaa2f6775">
<p>
Eshell is a strictly line-oriented command prompt written in Emacs Lisp.
This comes with its pros and cons: it can understand Elisp but does not
behave exactly like Unix shells, say, Bash.  Eshell cannot display the
kind of pseudo graphics a terminal emulator can, such as those you find
in <code>mutt</code>, <code>htop</code>, <code>ncmpcpp</code>, <code>newsboat</code> and so on.  As each user's needs are
different, you will have to determine whether Eshell can fit into your
workflow.  Start by reading its fairly short, yet insightful, manual.
</p>

<p>
For me this tool is one of the most promising in the Emacs milieu
because while it is a competent shell it can seamlessly integrate with
the rest of Emacs' capabilities.  This is best exemplified by its
extensibility, such as what I am doing with <code>prot-eshell.el</code>.  More on
that below.
</p>

<p>
The fact that Eshell cannot reproduce the artefacts of the ncurses
library does not pose a hindrance to my workflow, as I have replacements
for all such "graphical" programs within Emacs.  Notmuch has an Emacs
client which handles my email (yes, the CLI works as well), <code>M-x proced</code>
lets me interact with system processes, Bongo deals with media playback,
while Elfeed fills the niche of following RSS/Atom feed.
</p>

<p>
Read relevant sections:
</p>

<ul class="org-ul">
<li><a href="#h:a196812e-1644-4536-84ba-687366867def">Notmuch (mail indexer and mail user agent (MUA))</a>.</li>
<li><a href="#h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325">Proced (process monitor, similar to `top')</a>.</li>
<li><a href="#h:758afe0d-bc7c-4afc-9c6b-b5e569901591">Bongo (music or media manager)</a>.</li>
<li><a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">Elfeed (RSS/Atom feed reader)</a>.</li>
</ul>

<p>
Now an overview of <code>prot-eshell.el</code>, with the full code reproduced right
after the package configurations:
</p>

<ul class="org-ul">
<li>There are several <code>prot-eshell-ffap-*</code> commands that operate on the file
at point.  Say you have called <code>ls</code> and wish to expand the contents of a
file at the command prompt.  With point over the file name of
interest, use <code>prot-eshell-ffap-insert</code>.  Wish to visit the file
instead, so that you may edit it?  Try <code>prot-eshell-ffap-find-file</code>.
The command <code>prot-eshell-ffap-kill-save</code> copies the file's full file
system path, while <code>prot-eshell-ffap-dired-jump</code> opens a Dired buffer in
that file's directory (see <a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">Dired (directory editor, file manager)</a>).</li>

<li><code>prot-eshell-export</code> takes the prompt and output of the last command and
places it in a bespoke buffer.  The name of the buffer is controlled
by the variable <code>prot-eshell-output-buffer</code>.  If that buffer does not
exist, it is created.  Otherwise subsequent invocations of this
"export" command will append their contents to the existing ones.
This is good for keeping a record of something you are working on.
And because this is a standard buffer, you can edit it at will as well
as call <code>write-file</code> (<code>C-x C-w</code>) to save it permanently to a file.</li>

<li><code>prot-eshell-redirect-to-buffer</code> provides a completion prompt to help
you redirect the output of a command to a given buffer.  Simple and
effective.</li>

<li><code>prot-eshell-narrow-output-highlight-regexp</code> prompts for a regexp to
highlight in the output of the last command.  It then narrows the
Eshell buffer to the contents of that output and emphasises the
matches of the regexp.  Very useful when you need to inspect some logs
or other terse output.  Remember that to widen the view you use the
standard <code>widen</code> command, bound to <code>C-x n w</code> by default.</li>

<li><code>prot-eshell-complete-history</code> lets you pick a command from your history
using minibuffer completion.  Forget about a non-interactive regexp
search or, worse, consecutive calls to <code>M-p</code> and <code>M-n</code> to cycle through
your recent inputs one at a time.</li>

<li><code>prot-eshell-complete-recent-dir</code> provides a minibuffer prompt with
completion that queries through all paths in your <code>cd</code> input history.
This is much more convenient that standard actions like <code>cd -</code> or <code>cd -N</code>
where <code>N</code> is the position of the item in the history of entries
(retrieved with <code>cd =</code>).</li>

<li><code>prot-eshell-find-subdirectory-recursive</code> uses completion to help you
pick a subdirectory that extends the present working directory.  It
does so recursively, which makes it powerful, but can cause problems
when called from the root of some massive directory tree.  Exercise
restraint.</li>

<li><code>prot-eshell-root-dir</code> switches the present working directory to that of
the current project's root directory, if one is found.</li>
</ul>

<p>
Here is a <a href="https://protesilaos.com/codelog/2020-05-08-emacs-eshell-demo/">video on Eshell and my extras</a> (2020-05-08) which, however,
showcases older code than what I have here.
</p>

<p>
For further inspiration, check these valuable resources (in no
particular order):
</p>

<ul class="org-ul">
<li><a href="https://cestlaz.github.io/post/using-emacs-66-eshell-elisp">Mike Zamansky's video demo</a> that also shows how to program an Eshell
switcher.</li>
<li><a href="https://www.youtube.com/watch?v=RhYNu6i_uY4">Howard Abrahams' video</a> that covers the features of Eshell.</li>
<li><a href="https://ambrevar.xyz/emacs-eshell/">Pierre Neidhardt's detailed blog post</a> on the pros and cons of Eshell.</li>
<li><a href="https://git.spwhitton.name/dotfiles">Sean Whitton's comprehensive dotfiles repository</a> which includes lots
of useful snippets, including for Eshell.  Some commands/functions of
mine are either copied or adapted from Sean's implementation,
following the review that was done on 2022-01-04.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Eshell and prot-eshell.el
(prot-emacs-builtin-package 'eshell
  (require 'esh-mode)
  (require 'esh-module)
  (setq eshell-modules-list             ; It works but may need review
        '(eshell-alias
          eshell-basic
          eshell-cmpl
          eshell-dirs
          eshell-glob
          eshell-hist
          eshell-ls
          eshell-pred
          eshell-prompt
          eshell-script
          eshell-term
          eshell-tramp
          eshell-unix))
  (setenv "PAGER" "cat") ; solves issues, such as with 'git log' and the default 'less'
  (require 'em-cmpl)
  (require 'em-dirs)
  (setq eshell-cd-on-directory t)

  (require 'em-tramp)
  (setq password-cache t)
  (setq password-cache-expiry 600)

  (require 'em-hist)
  (setq eshell-hist-ignoredups t)
  (setq eshell-save-history-on-exit t))

(prot-emacs-builtin-package 'prot-eshell
  (setq prot-eshell-output-buffer "*Exported Eshell output*")
  (setq prot-eshell-output-delimiter "* * *")
  (let ((map eshell-mode-map))
    (define-key map (kbd "M-k") #'eshell-kill-input)
    (define-key map (kbd "C-c C-f") #'prot-eshell-ffap-find-file)
    (define-key map (kbd "C-c C-j") #'prot-eshell-ffap-dired-jump)
    (define-key map (kbd "C-c C-w") #'prot-eshell-ffap-kill-save)
    (define-key map (kbd "C-c C-&gt;") #'prot-eshell-redirect-to-buffer)
    (define-key map (kbd "C-c C-e") #'prot-eshell-export)
    (define-key map (kbd "C-c C-r") #'prot-eshell-root-dir))
  (let ((map eshell-cmpl-mode-map))
    (define-key map (kbd "C-c TAB") #'prot-eshell-ffap-insert) ; C-c C-i
    (define-key map (kbd "C-c C-h") #'prot-eshell-narrow-output-highlight-regexp))
  (let ((map eshell-hist-mode-map))
    (define-key map (kbd "M-s") #'nil) ; I use this prefix for lots of more useful commands
    (define-key map (kbd "M-r") #'prot-eshell-complete-history)
    (define-key map (kbd "C-c C-d") #'prot-eshell-complete-recent-dir)
    (define-key map (kbd "C-c C-s") #'prot-eshell-find-subdirectory-recursive)))
</pre>
</div>

<p>
This is <code>prot-eshell.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-eshell.el --- Extensions to Eshell for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my Eshell extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'eshell)
(require 'esh-mode)
(require 'em-dirs)
(require 'em-hist)

;;;; Customisation options

(defgroup prot-eshell ()
  "Extensions for Eshell and related libraries."
  :group 'shell)

(defcustom prot-eshell-output-buffer "*Exported Eshell output*"
  "Name of buffer with the last output of Eshell command.
Used by `prot-eshell-export'."
  :type 'string
  :group 'prot-eshell)

(defcustom prot-eshell-output-delimiter "* * *"
  "Delimiter for successive `prot-eshell-export' outputs.
This is formatted internally to have newline characters before
and after it."
  :type 'string
  :group 'prot-eshell)

;;;; Commands

(autoload 'ffap-file-at-point "ffap.el")

(defmacro prot-eshell-ffap (name doc &amp;rest body)
  "Make `find-file-at-point' commands for Eshell.
NAME is how the function is called.  DOC is the function's
documentation string.  BODY is the set of arguments passed to the
`if' statement to be evaluated when a file at point is present."
  `(defun ,name ()
     ,doc
     (interactive)
     (if-let ((file (ffap-file-at-point)))
         ,@body
       (user-error "No file at point"))))

(prot-eshell-ffap
 prot-eshell-ffap-insert
 "Insert (cat) contents of file at point."
 (progn
   (goto-char (point-max))
   (insert (format "cat %s" file))
   (eshell-send-input)))

(prot-eshell-ffap
 prot-eshell-ffap-kill-save
 "Add to kill-ring the absolute path of file at point."
 (progn
   (kill-new (format "%s/%s" (eshell/pwd) file))
   (message "Copied full path of %s" file)))

(prot-eshell-ffap
 prot-eshell-ffap-find-file
 "Run `find-file' for file at point (ordinary file or dir).
Recall that this will produce a `dired' buffer if the file is a
directory."
 (find-file file))

(prot-eshell-ffap
 prot-eshell-ffap-dired-jump
 "Jump to the parent directory of the file at point."
 (dired (file-name-directory file)))

(defun prot-eshell--command-prompt-output ()
  "Capture last command prompt and its output."
  (let ((beg (save-excursion
               (goto-char (eshell-beginning-of-input))
               (goto-char (point-at-bol)))))
  (when (derived-mode-p 'eshell-mode)
    (buffer-substring-no-properties beg (eshell-end-of-output)))))

;;;###autoload
(defun prot-eshell-export ()
  "Produce a buffer with output of the last Eshell command.
If `prot-eshell-output-buffer' does not exist, create it.  Else
append to it, while separating multiple outputs with
`prot-eshell-output-delimiter'."
  (interactive)
  (let ((eshell-output (prot-eshell--command-prompt-output)))
    (with-current-buffer (get-buffer-create prot-eshell-output-buffer)
      (goto-char (point-max))
      (unless (eq (point-min) (point-max))
        (insert (format "\n%s\n\n" prot-eshell-output-delimiter)))
      (goto-char (point-at-bol))
      (insert eshell-output)
      (switch-to-buffer-other-window (current-buffer)))))

;;;###autoload
(defun prot-eshell-redirect-to-buffer (buffer)
  "Complete the syntax for appending Eshell output to BUFFER."
  (interactive
   (list (read-buffer "Redirect to buffer: ")))
  (insert (format " &gt;&gt;&gt; #&lt;%s&gt;" buffer)))

(defconst prot-eshell--highlight-faces
  '(hi-yellow hi-blue hi-pink hi-green hi-salmon hi-aquamarine)
  "List of faces to highlight output.")

(defvar prot-eshell--highlight-last-face nil
  "Last used face used for highlighting output.")

(defun prot-eshell--highlight-random-face ()
  "Return random face except last used.
For use in `prot-eshell-narrow-output-highlight-regexp'."
  (let* ((faces prot-eshell--highlight-faces)
         (last prot-eshell--highlight-last-face)
         (remaining (when last (remove last faces)))
         (length (1- (length faces)))
         (n (random length))
         (face (nth n remaining)))
    (cond
     ((null face)
      (setq face (car faces)))
     ((eq face last)
      (setq remaining (remove face remaining))
      (setq face (car remaining))))
    (setq prot-eshell--highlight-last-face face)
    face))

(defvar prot-eshell--output-highlight-history '()
  "History of `prot-eshell-narrow-output-highlight-regexp'.")

;;;###autoload
(defun prot-eshell-narrow-output-highlight-regexp (regexp)
  "Narrow to last command output and highlight REGEXP."
  (interactive
   (list (read-regexp "Regexp to highlight" nil 'prot-eshell--output-highlight-history)))
  (narrow-to-region (eshell-beginning-of-output)
                    (eshell-end-of-output))
  (goto-char (point-min))
  (highlight-regexp regexp (prot-eshell--highlight-random-face))
  (message "%s to last output and highlighted '%s'"
           (propertize "Narrowed" 'face 'bold)
           (propertize regexp 'face 'italic)))

;; Copied on 2022-01-04 10:32 +0200 from Sean Whitton's `spw/eshell-cd'.
;; I had to change the symbol to use the prot-eshell prefix for lexical
;; binding.  Sean's dotfiles: &lt;https://git.spwhitton.name/dotfiles&gt;.
(defun prot-eshell--cd (dir)
  "Routine to cd into DIR."
  (delete-region eshell-last-output-end (point-max))
  (when (&gt; eshell-last-output-end (point))
    (goto-char eshell-last-output-end))
  (insert-and-inherit "cd " (eshell-quote-argument dir))
  (eshell-send-input))

;;;###autoload
(defun prot-eshell-complete-recent-dir (dir &amp;optional arg)
  "Switch to a recent Eshell directory.

When called interactively, DIR is selected with completion from
the elements of `eshell-last-dir-ring'.

With optional ARG prefix argument (\\[universal-argument]) also
open the directory in a `dired' buffer."
  (interactive
   (list
    (if-let ((dirs (ring-elements eshell-last-dir-ring)))
        (completing-read "Switch to recent dir: " dirs nil t)
      (user-error "There is no Eshell history for recent directories"))
    current-prefix-arg))
  (prot-eshell--cd dir)
  ;; UPDATE 2022-01-04 10:48 +0200: The idea for `dired-other-window'
  ;; was taken from Sean Whitton's `spw/eshell-cd-recent-dir'.  Check
  ;; Sean's dotfiles: &lt;https://git.spwhitton.name/dotfiles&gt;.
  (when arg
    (dired-other-window dir)))

(defvar prot-eshell--complete-history-prompt-history '()
  "History of `prot-eshell-narrow-output-highlight-regexp'.")

(defun prot-eshell--complete-history-prompt ()
  "Prompt with completion for history element.
Helper function for `prot-eshell-complete-history'."
  (if-let ((hist (ring-elements eshell-history-ring)))
      (completing-read "Input from history: "
                       hist nil t nil
                       'prot-eshell--complete-history-prompt-history)
    (user-error "There is no Eshell history")))

;;;###autoload
(defun prot-eshell-complete-history (elt)
  "Insert ELT from Eshell history using completion."
  (interactive
   (list (prot-eshell--complete-history-prompt)))
  (insert elt))

(autoload 'cl-remove-if-not "cl-seq")

;; TODO 2022-01-01: Maybe we can rewrite this using `find' and then
;; processing the output.
;;;###autoload
(defun prot-eshell-find-subdirectory-recursive ()
  "Recursive `eshell/cd' to subdirectory.
This command has the potential for infinite recursion: use it
wisely or prepare to call `eshell-interrupt-process'."
  (interactive)
  (let* ((dir (abbreviate-file-name (eshell/pwd)))
         (contents (directory-files-recursively dir ".*" t nil nil))
         (dirs (cl-remove-if-not (lambda (x)
                                   (or (file-directory-p x)
                                       (string-match-p "\\.git" x)))
                                 contents))
         (selection (completing-read
                     (format "Find sub-dir from %s: "
                             (propertize dir 'face 'success))
                     dirs nil t)))
    (prot-eshell--cd selection)))

;;;###autoload
(defun prot-eshell-root-dir ()
  "Switch to the root directory of the present project."
  (interactive)
  (if-let ((root (or (vc-root-dir) (locate-dominating-file "." ".git"))))
      (prot-eshell--cd root)
    (user-error "Cannot find a project root here")))

;;;; Bookmark handler for bookmark.el
;; The default pops up an existing Eshell buffer instead of creating a
;; new one which visits the bookmarked location.

(declare-function bookmark-get-handler "bookmark" (bookmark-name-or-record))
(declare-function bookmark-prop-get "bookmark" (bookmark prop))

;; Copied from the `eshell-conf.el' of JSDurand on 2021-09-17 17:47
;; +0300: &lt;https://git.jsdurand.xyz/emacsd.git/tree/eshell-conf.el&gt;.

(defun prot-eshell-bookmark-jump (bookmark)
  "Handle Eshell BOOKMARK in my preferred way."
  (let ((handler (bookmark-get-handler bookmark))
        (location (bookmark-prop-get bookmark 'location))
        (eshell-buffers
         (delq
          nil
          (mapcar
           (lambda (buffer)
             (cond
              ((provided-mode-derived-p
                (buffer-local-value
                 'major-mode buffer)
                'eshell-mode)
               buffer)))
           (buffer-list)))))
    (cond
     ((and (stringp location)
           (not (string= location ""))
           (memq handler (list #'eshell-bookmark-jump
                               #'prot-eshell-bookmark-jump)))
      (let (reuse-p)
        (mapc
         (lambda (buffer)
           (cond
            ((string= (buffer-local-value 'default-directory
                                          buffer)
                      location)
             (setq reuse-p buffer))))
         eshell-buffers)
        ;; Don't switch to that buffer, otherwise it will cause
        ;; problems if we want to open the bookmark in another window.
        (cond
         (reuse-p (set-buffer reuse-p))
         ;; eshell will pop the buffer
         ((let ((buffer (generate-new-buffer eshell-buffer-name)))
            (with-current-buffer buffer
              (setq-local default-directory location)
              (eshell-mode))
            (set-buffer buffer))))))
     ((user-error "Cannot jump to this bookmark")))))

(advice-add #'eshell-bookmark-jump :override #'prot-eshell-bookmark-jump)

(provide 'prot-eshell)
;;; prot-eshell.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a" class="outline-4">
<h4 id="h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a"><span class="section-number-4">5.7.2.</span> Shell (M-x shell)</h4>
<div class="outline-text-4" id="text-h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a">
<p>
NOTE: I normally use Eshell.  Refer to the <a href="#h:103a8795-c29c-474f-9ddf-ecafaa2f6775">Eshell and prot-eshell.el</a>
section.
</p>

<p>
This is a shell (Bash, in my case) that runs inside of Emacs.  Unlike
terminal emulators, this one can use standard Emacs keys and behaves
much like an ordinary buffer.  It also integrates nicely with the
built-in completion tools, which makes it particularly nice to work
with.
</p>

<p>
The one area where this Shell differs substantially from ordinary
buffers is with regard to the command prompt: you can re-run a command
on the scroll-back buffer by just hitting <code>RET</code> while point is on its line
(no need to go back to the end and cycle the command history with <code>M-p</code> or
<code>M-n</code>).
</p>

<p>
Another peculiarity relative to the standard commands in the terminal is
to search backward through your history with <code>M-r</code> (whereas in a terminal
emulator you use <code>C-r</code>).
</p>

<p>
Run <code>C-h m</code> inside of a shell buffer to learn about all the key bindings
and corresponding functions.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Shell (M-x shell)
(prot-emacs-builtin-package 'shell
  (setq shell-command-prompt-show-cwd t) ; Emacs 27.1
  (setq ansi-color-for-comint-mode t))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:4e8347de-415e-4804-b383-d61499e05ca1" class="outline-3">
<h3 id="h:4e8347de-415e-4804-b383-d61499e05ca1"><span class="section-number-3">5.8.</span> Org-mode (personal information manager)</h3>
<div class="outline-text-3" id="text-h:4e8347de-415e-4804-b383-d61499e05ca1">
<p>
Also watch: <a href="https://protesilaos.com/codelog/2021-08-31-emacs-second-brain-mindfulness/">Emacs as a 'second brain' and mindfulness</a> (2021-08-31).
</p>

<p>
In its purest form, Org is a markup language that is similar to
Markdown: symbols are used to denote the meaning of a construct in its
context, such as what may represent a headline element or a phrase that
calls for emphasis.
</p>

<p>
What lends Org its super powers though is everything else built around
it: a rich corpus of Elisp functions that automate, link, combine,
enhance, structure, or otherwise enrich the process of using this rather
straightforward system of plain text notation.
</p>

<p>
Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and
workflows on how to organise one's life with plain text.
</p>

<p>
The present document is written in <code>org-mode</code> while its website version is
outputted by a tool (also part of Org) that exports Org notation to its
HTML equivalent.
</p>

<p>
Regarding the following code block, I strongly encourage you to make
liberal use of Emacs' documentation facilities to learn more about
functions, variables, symbols provided herein.  And do not forget to
read Org's manual.
</p>

<p>
What follows in an exposition about each of the subsesctions of this
package configurations:
</p>

<dl class="org-dl">
<dt>Org links</dt><dd><p>
The <code>org-store-link</code> is one of the commands I use the most,
as it allows me to, inter alia, connect the various sections of this
document.  Use it to store a direct link to the heading you are
currently under.  Or to produce a properly formatted link to supported
buffers you are visiting (e.g. another file).
</p>

<p>
There are several ways to insert such links.  With <code>C-c C-l</code> (which
calls <code>org-insert-link</code>) you will be prompted to select a stored link
from the link.  It will be inserted at point, using the right markup,
but will first ask you for a description text.  Otherwise you can
invoke <code>C-c C-l</code> with an active region, to create a link to that
location with the selected text becoming the description.  Else just
call <code>org-insert-last-stored-link</code> to skip the interactive process and
insert the last link outright.
</p>

<p>
In addition to these, <code>org-insert-link</code> can be used to create references
on demand.  Say you have a URL on the kill-ring: <code>C-c C-l</code>, then <code>C-y</code>
followed by <code>RET</code> to confirm your input.  Complete the process with a
description and you are good to go.
</p></dd>

<dt>Org capture</dt><dd><p>
The <code>org-capture</code> tool is a powerful way to quickly
produce some kind of structured information that gets stored in the
appropriate place.  The type of data and the way to store is
determined by a system of templates which accepts a series of possible
specifiers as well as the evaluated part of arbitrary elisp code.
</p>

<p>
Each template is accessed via a key.  These are listed in a temporary
buffer when you call <code>org-capture</code>.  Unique keys give direct access to
their template, whereas templates that share a common initial key will
produce a second selection list with the remaining options.  In the
latter case, the initial key entry has no call to an actual function,
but is just written as a heading.
</p>

<p>
The visibility of a template is explicitly controlled by the alist
<code>org-capture-templates-contexts</code>.  This allows us to tell Org the
context in which we want certain options to appear in.  Otherwise they
remain concealed from our view.  Equipped with this piece of
functionality, we can freely write highly specialised templates that
capture structured text when viewing some particular item, but are not
needed for more general purposes.  I do this for certain actions that
only come into effect when reading email inside of the relevant
buffers (also check my <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">comprehensive configurations for email</a>).
</p>

<p>
Speaking of mail, you will notice some specifiers like <code>:fromname</code>.  This
refers to the <code>From</code> field in emails and will capture the name part only.
Other similar keywords are <code>:from</code> (name and email), <code>:fromaddress</code> (email
only), <code>:subject</code>.
</p>

<p>
Specifiers that start with the caret sign (<code>^</code>) represent prompts for
further user input.  The pattern <code>^{TEXT}</code> is a prompt whose expression
is <code>TEXT</code>.  To offer possible options, use <code>^{Initial|ONE|TWO|THREE}</code>,
where the first entry is the text of the prompt and all the rest are
the available choices (depending on your completion framework, you may
need to add an empty option as well, with <code>||</code>, should you ever want to
insert nothing).  In some templates I use the <code>^t</code> specifier, which is a
built-in method to ask for a specific date.
</p>

<p>
The text that goes into a template can be written as part of a string or
inside a function that is then evaluated.  I generally prefer to use
simple strings, though I might revise this approach going forward.  To
insert a new line inside of a string, use <code>\n</code>.
</p>

<p>
The <code>%?</code> specifier determines where the point shall end in once the
template is parsed.  While <code>%i</code> will insert the contents of the active
region, if any.
</p>

<p>
As things currently stand, my capture templates always write to headings
inside of files.  Note though that there are more possibilities, as
described in the manual.
</p>

<p>
A file can be specified by its absolute path or just a name.  In the
latter case, its location is understood relative to <code>org-directory</code>.
When using the <code>file+headline</code> pattern, non-existent files are created
automatically once you call the relevant template.  Same for their
respective headings.
</p>

<p>
Finally, the <code>prot-org--capture-no-delete-windows</code> from my <code>prot-org.el</code>
(reproduced after the Org configs) addresses a problem I have when
<code>org-capture</code> fails to carry out its operations when it is called from
inside of a side window (for more on those, refer to the section on
<a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">Window rules and basic tweaks</a>).  The code is taken directly from this
<a href="https://stackoverflow.com/a/54251825">Stack Overflow thread</a>.
</p>

<p>
Consider watching my <a href="https://protesilaos.com/codelog/2020-02-04-emacs-org-capture-intro/">primer on org-capture</a> (2020-02-04) which shows all
of the above in action.
</p></dd>

<dt>Org agenda</dt><dd><p>
The <code>org-agenda</code> is not just a single interface.  It
rather is your conduit to a set of utilities for reading timestamped
tasks.  From there you can keep track of all the relevant entries you
have inserted in the files declared as part of <code>org-agenda-files</code> list.
</p>

<p>
Running <code>org-agenda</code> will present you with a list of possible options:
the "dispatcher" as it called.  Here is a primer (there are many more
functions documented in the manual):
</p>

<ul class="org-ul">
<li>From the dispatcher, the <code>a</code> is where you keep track of all the items
that have a date assigned to them, be it <code>SCHEDULED</code> or <code>DEADLINE</code>.  To
assign such a value to a heading use <code>C-c C-s</code> or <code>C-c C-d</code> respectively.
Run those commands with a universal prefix (<code>C-u</code>) to remove the
timestamp.  Hit <code>/</code> to filter this view to match particular tags.</li>

<li>In the dispatcher's menu, the <code>t</code> will list all your tasks, regardless
of whether they have a date assigned to them.  You can then filter by
keyword, regular expression, etc.  Check the top of the buffer for
information on how to do that.</li>

<li>And the <code>n</code> in the dispatcher will offer you a combined view of the
above.</li>

<li>Those granted, I prefer to just use the Diary and Calendar for my
simple needs: <a href="#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9">Calendar and Diary (and prot-diary.el)</a>.  Though this
may change going forward, as I am starting to experiment with more
advanced workflows, including the creation of bespoke "block agenda"
views (watch my <a href="https://protesilaos.com/codelog/2021-12-09-emacs-org-block-agenda/">Demo of my custom Org block agenda</a> (2021-12-09)).</li>
</ul></dd>

<dt>Org export</dt><dd>I do not have much to offer here, apart from the setup
that handles consistent heading IDs and anchor tags (the latter
concerns the HTML output).  Everything in that segment, minus some
minor tweaks from my part, is copied from this detailed tutorial on
<a href="https://writequit.org/articles/emacs-org-mode-generate-ids.html">Org header IDs</a>.  Basically, the problem is that exported HTML does not
have reliable anchor tags for the various sections of the document.
This fixes the issue (read the article for more).</dd>
</dl>

<p>
Finally, note that I sometimes deliver simple presentations using Org.
Refer to <a href="#h:77d14350-978d-4820-ab7f-4641706c445a">Custom extensions for "focus mode" (prot-logos.el)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Org-mode (personal information manager)
;; Pro tip: If you are reading the source code, use C-c '
;; (`org-edit-special') to put the code block in a dedicated buffer and
;; then activate `prot-outline-minor-mode-safe' to conveniently browse
;; this massive code block.
(prot-emacs-builtin-package 'org
  (setq org-directory (convert-standard-filename "~/Documents/org"))
  (setq org-imenu-depth 7)
;;;; general settings
  (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-hide-leading-stars nil)
  (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-info ol-eww))
  (setq org-use-sub-superscripts '{})
  (setq org-insert-heading-respect-content t)

;;;; refile, todo
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "MAYBE(m)" "WAIT(w@/!)" "|" "CANCEL(c@)" "DONE(d!)")))
  (setq org-todo-keyword-faces
        '(("WAIT" . '(bold org-todo))
          ("MAYBE" . '(bold shadow))
          ("CANCEL" . '(bold org-done))))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-priority-faces
        '((?A . '(bold org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

;;;; tags
  (setq org-tag-alist ; I don't really use those, but whatever
        '(("meeting")
          ("admin")
          ("emacs")
          ("modus")
          ("politics")
          ("economics")
          ("philosophy")
          ("book")
          ("essay")
          ("mail")
          ("purchase")
          ("hardware")
          ("software")
          ("website")))

;;;; log
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-read-date-prefer-future 'time)

;;;; links
  (setq org-link-keep-stored-after-insertion nil)
  ;; TODO 2021-10-15 org-link-make-description-function

  ;; See my prot-pulse.el for what this does.  Basically it recentres
  ;; the window the way I like and pulse the line at point to make it
  ;; easier to make sense of the context.
  (add-hook 'org-follow-link-hook #'prot-pulse-recentre-top)

;;;; capture
  (setq org-capture-templates
        `(("b" "Basic task for future review" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%l")
           :empty-lines-after 1)
          ("c" "Clock in to a task" entry
           (file+headline "tasks.org" "Clocked tasks")
           ,(concat "* TODO %^{Title}\n"
                    "SCHEDULED: %T\n"
                    ":PROPERTIES:\n"
                    ":EFFORT: %^{Effort estimate in minutes|5|10|15|30|45|60|90|120}\n"
                    ":END:\n\n"
                    "%a\n")
           :prepend t
           :clock-in t
           :clock-keep t
           :immediate-finish t
           :empty-lines-after 1)
          ("m" "Memorandum of conversation" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* Memorandum of conversation with %^{Person}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%?")
           :empty-lines-after 1)
          ("t" "Task with a due date" entry
           (file+headline "tasks.org" "Tasks with a date")
           ,(concat "* TODO %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)
          ("e" "Email note" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* MAYBE %:subject :mail:\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)))

  (setq org-capture-templates-contexts
        '(("e" ((in-mode . "notmuch-search-mode")
                (in-mode . "notmuch-show-mode")
                (in-mode . "notmuch-tree-mode")))))

;;;; agenda
;;;;; Basic agenda setup
  (setq org-default-notes-file (thread-last org-directory (expand-file-name "notes.org")))
  (setq org-agenda-files `(,org-directory "~/Documents"))
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

  ;; NOTE 2021-12-07: In my `prot-org.el' (see further below), I add
  ;; `org-agenda-to-appt' to various relevant hooks.
  ;;
  ;; Create reminders for tasks with a due date when this file is read.
  (run-at-time (* 60 5) nil #'org-agenda-to-appt)

;;;;; General agenda view options
  ;; NOTE 2021-12-07: Check further below my `org-agenda-custom-commands'
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "-&gt;")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

;;;;; Agenda diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary nil)

;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time nil)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        (concat "Now " (make-string 70 ?-)))
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -100)

;;;;; Agenda entry
  ;; NOTE: I do not use this right now.  Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    &gt; ")

;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to.  Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-agenda-sort-notime-is-late t) ; Org 9.4
  (setq org-agenda-sort-noeffort-is-high t) ; Org 9.4

;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

;;;;; Agenda habits
  (require 'org-habit)
  (setq org-habit-graph-column 50)
  (setq org-habit-preceding-days 9)

;;;; code blocks
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)

;;;; export
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (require 'ox-texinfo)
  (require 'ox-md)
  ;; FIXME: how to remove everything else?
  (setq org-export-backends '(html texinfo md))

;;;; IDs
  (setq org-id-link-to-org-use-id
        'create-if-interactive-and-no-custom-id)

  (let ((map global-map))
    (define-key map (kbd "C-c a") #'org-agenda)
    (define-key map (kbd "C-c c") #'org-capture)
    (define-key map (kbd "C-c l") #'org-store-link))
  (let ((map org-mode-map))
    (define-key map (kbd "C-'") nil)
    (define-key map (kbd "C-,") nil)
    (define-key map (kbd "&lt;C-return&gt;") nil)
    (define-key map (kbd "&lt;C-S-return&gt;") nil)
    (define-key map (kbd "C-M-S-&lt;right&gt;") nil)
    (define-key map (kbd "C-M-S-&lt;left&gt;") nil)
    (define-key map (kbd "C-c S-l") #'org-toggle-link-display)
    (define-key map (kbd "C-c C-S-l") #'org-insert-last-stored-link)))

(prot-emacs-builtin-package 'prot-org
  (setq org-agenda-format-date #'prot-org-agenda-format-date-aligned)

  ;; Check the variable `prot-org-custom-daily-agenda' in prot-org.el
  (setq org-agenda-custom-commands
        `(("A" "Daily agenda and top priority tasks"
           ,prot-org-custom-daily-agenda
           ((org-agenda-fontify-priorities nil)
            (org-agenda-dim-blocked-tasks nil)))
          ("P" "Plain text daily agenda and top priorities"
           ,prot-org-custom-daily-agenda
           ((org-agenda-with-colors nil)
            (org-agenda-prefix-format "%t %s")
            (org-agenda-current-time-string ,(car (last org-agenda-time-grid)))
            (org-agenda-fontify-priorities nil)
            (org-agenda-remove-tags t))
           ("agenda.txt"))))

  ;; I bind `org-agenda' to C-c a, so this one puts me straight into my
  ;; custom block agenda.
  (define-key global-map (kbd "C-c A") (lambda () (interactive) (org-agenda nil "A")))

  (add-to-list 'org-capture-templates
               '("j" "Music suggestion (jukebox)" entry
                 (file+headline "tasks.org" "Music suggestions")
                 #'prot-org-capture-jukebox
                 :empty-lines-after 1
                 :immediate-finish t)))
</pre>
</div>

<p>
Here are my few extras for Org (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-org.el --- Tweaks for my org-mode configurations -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my tweaks for Org that are meant for use in my
;; Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)

(defgroup prot-org ()
  "Extensions for org.el."
  :group 'org)

;;;; Source blocks

(defvar modus-themes-org-blocks)
(defvar org-fontify-whole-block-delimiter-line)

(defun prot-org--modus-themes-fontify-block-delimiters ()
  "Match `org-fontify-whole-block-delimiter-line' to theme style.
Run this function at the post theme load phase, such as with the
hook `modus-themes-after-load-theme-hook'."
  (if (eq modus-themes-org-blocks 'gray-background)
      (setq org-fontify-whole-block-delimiter-line t)
    (setq org-fontify-whole-block-delimiter-line nil))
  (when (derived-mode-p 'org-mode)
    (font-lock-flush)))

(when (require 'modus-themes nil t)
  (add-hook 'modus-themes-after-load-theme-hook
            #'prot-org--modus-themes-fontify-block-delimiters))

;;;; org-capture

(declare-function prot-bongo-show "prot-bongo")

(defun prot-org-capture-jukebox ()
  "Capture template for current Bongo songo." ; NOTE 2021-10-06: Brilliant typo!
  (concat "* " (prot-bongo-show) " :jukebox:\n"
          ":PROPERTIES:\n"
          ":CAPTURED: %U\n"
          ":END:\n\n"))

(declare-function cl-letf "cl-lib")

;; Source: https://stackoverflow.com/a/54251825
(defun prot-org--capture-no-delete-windows (oldfun args)
  (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
    (apply oldfun args)))

;; Same source as above
(advice-add 'org-capture-place-template
            :around 'prot-org--capture-no-delete-windows)

;;;; org-agenda

(declare-function calendar-day-name "calendar")
(declare-function calendar-day-of-week "calendar")
(declare-function calendar-month-name "calendar")
(declare-function org-days-to-iso-week "org")
(declare-function calendar-absolute-from-gregorian "calendar")

(defvar org-agenda-format-date)

;;;###autoload
(defun prot-org-agenda-format-date-aligned (date)
  "Format a DATE string for display in the daily/weekly agenda.
This function makes sure that dates are aligned for easy reading.

Slightly tweaked version of `org-agenda-format-date-aligned' that
produces dates with a fixed length."
  (require 'cal-iso)
  (let* ((dayname (calendar-day-name date t))
         (day (cadr date))
         (day-of-week (calendar-day-of-week date))
         (month (car date))
         (monthname (calendar-month-name month t))
         (year (nth 2 date))
         (iso-week (org-days-to-iso-week
                    (calendar-absolute-from-gregorian date)))
         ;; (weekyear (cond ((and (= month 1) (&gt;= iso-week 52))
         ;;                  (1- year))
         ;;                 ((and (= month 12) (&lt;= iso-week 1))
         ;;                  (1+ year))
         ;;                 (t year)))
         (weekstring (if (= day-of-week 1)
                         (format " (W%02d)" iso-week)
                       "")))
    (format "%s %2d %s %4d%s"
            dayname day monthname year weekstring)))

(defvar org-priority-highest)

(defvar prot-org-custom-daily-agenda
  ;; NOTE 2021-12-08: Specifying a match like the following does not
  ;; work.
  ;;
  ;; tags-todo "+PRIORITY=\"A\""
  ;;
  ;; So we match everything and then skip entries with
  ;; `org-agenda-skip-function'.
  `((tags-todo "*"
               ((org-agenda-skip-function '(org-agenda-skip-if nil '(timestamp)))
                (org-agenda-skip-function
                 `(org-agenda-skip-entry-if
                   'notregexp ,(format "\\[#%s\\]" (char-to-string org-priority-highest))))
                (org-agenda-block-separator nil)
                (org-agenda-overriding-header "Important tasks without a date\n")))
    (agenda "" ((org-agenda-time-grid nil)
                (org-agenda-start-on-weekday nil)
                (org-agenda-span 1)
                (org-agenda-show-all-dates nil)
                (org-scheduled-past-days 365)
                ;; Excludes today's scheduled items
                (org-scheduled-delay-days 1)
                (org-agenda-block-separator nil)
                (org-agenda-entry-types '(:scheduled))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                (org-agenda-format-date "")
                (org-agenda-overriding-header "\nPending scheduled tasks")))
    (agenda "" ((org-agenda-span 1)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-scheduled-past-days 0)
                ;; We don't need the `org-agenda-date-today'
                ;; highlight because that only has a practical
                ;; utility in multi-day views.
                (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                (org-agenda-format-date "%A %-e %B %Y")
                (org-agenda-overriding-header "\nToday's agenda\n")))
    (agenda "" ((org-agenda-start-on-weekday nil)
                (org-agenda-start-day "+1d")
                (org-agenda-span 3)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-overriding-header "\nNext three days\n")))
    (agenda "" ((org-agenda-time-grid nil)
                (org-agenda-start-on-weekday nil)
                ;; We don't want to replicate the previous section's
                ;; three days, so we start counting from the day after.
                (org-agenda-start-day "+4d")
                (org-agenda-span 14)
                (org-agenda-show-all-dates nil)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-agenda-entry-types '(:deadline))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-overriding-header "\nUpcoming deadlines (+14d)\n"))))
  "Custom agenda for use in `org-agenda-custom-commands'.")

;;;;; agenda appointments

(defvar prot-org-agenda-after-edit-hook nil
  "Hook that runs after select Org commands.
To be used with `advice-add'.")

(defun prot-org--agenda-after-edit (&amp;rest _)
  "Run `prot-org-agenda-after-edit-hook'."
  (run-hooks 'prot-org-agenda-after-edit-hook))

(defvar prot-org-after-deadline-or-schedule-hook nil
  "Hook that runs after `org--deadline-or-schedule'.
To be used with `advice-add'.")

(defvar prot-org--appt-agenda-commands
  '( org-agenda-archive org-agenda-deadline org-agenda-schedule
     org-agenda-todo org-archive-subtree)
  "List of commands that run `prot-org-agenda-after-edit-hook'.")

(dolist (fn prot-org--appt-agenda-commands)
  (advice-add fn :after #'prot-org--agenda-after-edit))

(defun prot-org--after-deadline-or-schedule (&amp;rest _)
  "Run `prot-org-after-deadline-or-schedule-hook'."
  (run-hooks 'prot-org-after-deadline-or-schedule-hook))

(defun prot-org-org-agenda-to-appt ()
  "Make `org-agenda-to-appt' always refresh appointment list."
  (org-agenda-to-appt :refresh))

(dolist (hook '(org-capture-after-finalize-hook
                org-after-todo-state-change-hook
                org-agenda-after-show-hook
                prot-org-agenda-after-edit-hook))
  (add-hook hook #'prot-org-org-agenda-to-appt))

(declare-function org--deadline-or-schedule "org" (arg type time))

(advice-add #'org--deadline-or-schedule :after #'prot-org--after-deadline-or-schedule)

(add-hook 'prot-org-after-deadline-or-schedule-hook #'prot-org-org-agenda-to-appt)

;;;; org-export

(declare-function org-html-export-as-html "org")
(declare-function org-texinfo-export-to-info "org")

;;;###autoload
(defun prot-org-ox-html ()
  "Streamline HTML export."
  (interactive)
  (org-html-export-as-html nil nil nil t nil))

;;;###autoload
(defun prot-org-ox-texinfo ()
  "Streamline Info export."
  (interactive)
  (org-texinfo-export-to-info))

;;;; org-id

(declare-function org-id-add-location "org")
(declare-function org-with-point-at "org")
(declare-function org-entry-get "org")
(declare-function org-id-new "org")
(declare-function org-entry-put "org")

;; Copied from this article (with minor tweaks from my side):
;; &lt;https://writequit.org/articles/emacs-org-mode-generate-ids.html&gt;.
(defun prot-org--id-get (&amp;optional pom create prefix)
  "Get the CUSTOM_ID property of the entry at point-or-marker POM.

If POM is nil, refer to the entry at point.  If the entry does
not have an CUSTOM_ID, the function returns nil.  However, when
CREATE is non nil, create a CUSTOM_ID if none is present already.
PREFIX will be passed through to `org-id-new'.  In any case, the
CUSTOM_ID of the entry is returned."
  (org-with-point-at pom
    (let ((id (org-entry-get nil "CUSTOM_ID")))
      (cond
       ((and id (stringp id) (string-match "\\S-" id))
        id)
       (create
        (setq id (org-id-new (concat prefix "h")))
        (org-entry-put pom "CUSTOM_ID" id)
        (org-id-add-location id (format "%s" (buffer-file-name (buffer-base-buffer))))
        id)))))

(declare-function org-map-entries "calendar")

;;;###autoload
(defun prot-org-id-headlines ()
  "Add missing CUSTOM_ID to all headlines in current file."
  (interactive)
  (org-map-entries
   (lambda () (prot-org--id-get (point) t))))

(provide 'prot-org)
;;; prot-org.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:b4040bc0-7a2a-4f17-824d-42de621bd1b9" class="outline-3">
<h3 id="h:b4040bc0-7a2a-4f17-824d-42de621bd1b9"><span class="section-number-3">5.9.</span> Calendar and Diary (and prot-diary.el)</h3>
<div class="outline-text-3" id="text-h:b4040bc0-7a2a-4f17-824d-42de621bd1b9">
<p>
Relevant information for what you are about to read in this section
(the list will be updated accordingly):
</p>

<ul class="org-ul">
<li><a href="https://protesilaos.com/codelog/2021-04-14-emacs-diary-calendar/">Video of Emacs Diary and Calendar for tracking appointments</a> (2021-04-14).</li>
<li><a href="https://protesilaos.com/codelog/2021-04-15-emacs-diary-outline-minor-mode/">Make the Emacs Diary work as an Outline (outline-minor-mode)</a> (2021-04-15).</li>
<li><a href="https://www.youtube.com/watch?v=n8o66i08fzs">Video on using Hyperbole with the Emacs Diary</a> by the Emacs Elements
channel (Raoul Comninos) (2021-04-16).</li>
</ul>

<p>
Emacs provides a suite of tools for planning events or recording dates
of interest in your life.  These are part of the same workflow, but are
divided into several smaller libraries.  The two main ones are
<code>diary-lib.el</code> and <code>calendar.el</code>.  I extend them with <code>prot-diary.el</code>, which
is reproduced at the end of this section, after the package
configurations.
</p>

<p>
<code>diary-lib.el</code> defines everything that pertains to the <code>diary-file</code>
(defaults to <code>~/.emacs.d/diary</code>, which is what I want).  The Diary has a
two-fold purpose: (i) to store entries about calendar events, and (ii)
to display such events for the given day or range thereof.
</p>

<p>
In the first case, the Diary functions as a regular buffer that you may
edit freely.  This is where you can write one-off or recurring events
using various date and time formats expressed in natural language or as
Elisp forms (a sexp or "symbolic expression").
</p>

<p>
When it comes to single events for a given day, I prefer to input them
on a whole line using the ISO 8601 standard and a 24-hour clock, like
this: <code>2021-04-13 15:00 Description of event</code>.
</p>

<p>
For multiple events that are clustered on the same day, I write the date
on its own line and below it place a description of each event
optionally preceded by a timestamp.  Entries with no timestamp come
first, followed by those that are time sensitive.  This is just a matter
of personal style.
</p>

<p>
In this scenario of grouped events under a given date, each entry below
the date has to start with at least one empty space, otherwise the Diary
will try to interpret them as two distinct expressions (the exact number
of spaces is a matter of preference).  So the format looks like this
(use <code>C-x TAB</code> (<code>indent-rigidly</code>) to incrementally adjust the indentation of
the active region, or <code>C-u C-x TAB</code> to increase by four spaces):
</p>

<pre class="example" id="org9888205">
2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
</pre>

<p>
The following is also possible, but looks too busy for no good reason:
</p>

<pre class="example" id="org7881fc6">
2021-04-13 This event is not time sensitive
2021-04-13 06:30-09:00 Hiking
2021-04-13 10:00 Prepare sourdough bread
2021-04-13 11:00-13:00 Write stuff
</pre>

<p>
Though not required, you can separate events by an empty line.  Keeps
things easy to read.  Remember that lines that contain at least one
space are thought to belong to the closest date entry above them.  Which
means that for multiple events on a given day you can use something like
this, if you need to (here dots represent empty spaces):
</p>

<pre class="example" id="org0b17c2f">
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
....
    10:00 Prepare sourdough bread
....
    11:00-13:00 Write stuff
</pre>

<p>
Furthermore, it is possible to use nested levels of indentation or, in
my case, call <code>prot-simple-cite-region</code> and indent it accordingly (check
the source code: <a href="#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb">Common custom functions (prot-simple.el)</a>).  For
example:
</p>

<pre class="example" id="orgd259585">
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
    +----[ Sample text ]
    | This is some random text
    | It relates to the above event
    +----
....
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
</pre>

<p>
Remember that these are mere stylistic considerations.  I generally
prefer to keep things simple, though I appreciate the flexibility of
adapting the view of my evolving needs.
</p>

<p>
I prefer to defer all formatting related decisions until after I have
typed in all the information.  My <code>prot-diary-align-timestamped-entries</code>
lets me align the negative space between an entry's timestamp and its
description.  Consider the following block and suppose that the region
starts from the line below the date and ends at the end of the line with
the last entry (demarcated by the <code>|</code> characters).
</p>

<pre class="example" id="orgc148b79">
2021-04-13
|This event is not time sensitive
06:30-09:00 Hiking
10:00 Prepare sourdough bread
11:00-13:00 Write stuff|

...becomes...

2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00       Prepare sourdough bread
    11:00-13:00 Write stuff
</pre>

<p>
For anniversaries or cyclic events, I rely on Elisp.  It is better to
read the Emacs manual on the technicalities as there are lots of
examples that should help you get started.  Just bear in mind that the
exact order for the <code>YEAR</code>, <code>MONTH</code>, <code>DATE</code> arguments depends on the value
assigned to the variable <code>calendar-date-style</code>.  As I already noted, I
follow the ISO style (evaluate this: <code>(format-time-string "%F")</code>).
</p>

<p>
The second use case of the Diary, namely, of showing the events it holds
is controlled by the variable <code>diary-display-function</code>.  On my setup it
should present the information in a read-only buffer that is internally
referred to as the "fancy" style.  To bring up that interface, you can
either use the Calendar as a starting point (more on that later) or call
a command directly, such as <code>prot-diary-display-entries</code>.  The resulting
buffer is fairly straightforward: there is a date header (or many
depending on the prefix numeric argument) and below that one or more
entries related to it.  Those retain the indentation of the underlying
Diary file, as described above.  Hit <code>RET</code> over an entry to visit the
editable version of the Diary.
</p>

<p>
Apart from displaying that buffer on demand, it is possible to get its
information emailed to you.  The built-in command for that is
<code>diary-mail-days</code>, however it has the downside of sending a mail even when
there are no events for the day[s] specified.  I do not see the utility
of such behaviour: what is the purpose of drawing attention to my email
client, only to waste my time with some "nothing to see here" message?
Whereas <code>prot-diary-mail-entries</code> only sends a message when that is the
right thing to do, i.e. when there is something that requires our
attention (for N days or <code>diary-mail-days</code>).  It also has the benefit of
not popping up the Diary display in another window as a side effect of
sending the email (check <code>prot-diary--mail-fn</code> for the technicalities).  I
set it up to automatically try to send me an email briefing each morning
when I launch Emacs.
</p>

<p>
Email briefings just offer an overview of events in the immediate
future.  We still need a mechanism to alert us some minutes in advance
of a time sensitive appointment.  This is where the <code>appt.el</code> library
comes in handy.  It already knows how to scan the Diary in search for
time expressions and produce reminders for them: all it needs is to be
activated with <code>(appt-activate 1)</code>.  Unlike email, this is a more
persistent method of producing notifications inside of Emacs in the form
of a pop-up window and a complementary modeline indicator with a
countdown to the event.  The default notification time is specified in
the variable <code>appt-message-warning-time</code>, though individual Diary entries
can declare their own time (in minutes), by holding some extra text as
defined in <code>appt-warning-time-regexp</code>.  Put that in a comment
(<code>diary-comment-start</code>) to disambiguate it from the entry's description.
For example, this Diary entry will work as expected with my
configurations: <code>2021-04-13 18:00 Some task ;; appt 5</code>.  The <code>;; appt 5</code>
part will not be shown in the Diary display, but will still activate the
reminder.  Nice and simple!
</p>

<p>
To recapitulate, the Diary is flexible enough to accommodate a variety
of preferences on how to organise one's life events.  The key to get
started is to learn how to edit the actual file, which is fairly easy.
It then is trivial to either display that information on demand or be
notified about it.
</p>

<p>
Let us now cover the other major component of this suite of tools: the
Calendar.  The main point of entry is <code>M-x calendar</code>.  It displays a
horizontal three-month view centred on the current month.  Moving in the
calendar is consistent with regular Emacs motions: <code>C-f</code> and <code>C-b</code> move one
day forward/backward, <code>C-n</code> and <code>C-p</code> go down and up one week, <code>C-a</code> and <code>C-e</code>
place the point at the beginning or end of the week, respectively.  Then
we have the equivalent of paragraph and page motions: <code>M-{</code> and <code>M-}</code> which
travel forward/backward a full month, with <code>C-v</code> and <code>M-v</code> moving to the
next and previous three-month set.  To merely scroll the horizontal
calendar strip, use <code>&lt;</code> and <code>&gt;</code> to do so in the given direction.  As always,
do not forget to type <code>C-h m</code> (<code>describe-mode</code>) in any major-mode buffer you
are unfamiliar with to get help for it: you will learn about those
motions and some more of them (and always check the manual as well).
</p>

<p>
The Calendar offers an overview of your Diary entries, as noted above,
and, optionally, of all holidays that you have opted in to.  For the
latter, check the variable <code>calendar-holidays</code>.  I set it to only a small
set of records largely for experimental purposes, as I am not interested
in either religious or secular special days.  Consider this, if you
will, an attempt at introducing the illusion of eventfulness in my
calendar.  I really don't care about any of this.
</p>

<p>
To mark Diary entries in the Calendar, use <code>m</code> (<code>diary-mark-entries</code>).  That
accepts a prefix argument (<code>C-u</code>) in case you wish to redraw those marks.
Here we should clarify that "marks" are Emacs faces by default, unless
you explicitly override them with characters.  I prefer faces, which
leave a more pleasant, less noisy impression.  Similarly, use <code>x</code>
(<code>calendar-mark-holidays</code>) to mark holidays.  Both of those tasks can be
performed automatically upon accessing the Calendar, by setting the
variables <code>calendar-mark-diary-entries-flag</code>, <code>calendar-mark-holidays-flag</code>
to non-nil values (which is what I do).
</p>

<p>
Events that should not appear in the Calendar when Diary entries are
marked must be preceded with a special character, which is configurable
by means of <code>diary-nonmarking-symbol</code>.  I personally have no use for this,
because if something is not worth being marked, then it is not pointless
to keep track of it in my day-to-day planner.
</p>

<p>
While in the Calendar, you can move the point over a marked day and type
<code>d</code> (<code>diary-view-entries</code>) to show the read-only variant of the Diary, as
outlined above.  Or pass a number to it to encompass the Nth days
(e.g. typing <code>7 d</code> will show Diary entries for seven days starting from
the current one).  If the mark pertains to a holiday, type <code>h</code> to get a
message in the echo area about it (<code>calendar-cursor-holidays</code>).
</p>

<p>
If you opt to use my settings, the best way to learn how to disambiguate
the two marks is to access the Calendar and hit <code>u</code> (<code>calendar-unmark</code>).
Follow it up with <code>m</code> to mark Diary entries and <code>x</code> to render holiday marks.
</p>

<p>
Other than viewing what happens on a given day or date range, you can
use the Calendar to record new entries in the Diary.  I group those
under the <code>i</code> prefix key: so type, <code>i</code> and then <code>C-h</code> to get help about all
possible keys that complete that sequence and references to the commands
they call.  Note that to insert a block event you need to hit <code>C-SPC</code> on
the starting date and then move point to the ending day at which you
should do <code>i b</code> (<code>diary-insert-block-entry</code>).
</p>

<p>
It is possible to use more faces than the ones which are provided by
default.  To do so, you need to specify a face argument to the various
Elisp expressions that can be written to the Diary.  For example, my
<code>prot-diary.el</code> (reproduced further below) has a bespoke face for
"administrative tasks", which can be assigned to the given expression
like this (new line and indentation are optional, as mentioned above,
otherwise keep everything on one line):
</p>

<pre class="example" id="org5e2f163">
 %%(diary-date t t 13 'prot-diary-calendar-administrative-mark)
     Some administrative monthly task
 %%(diary-anniversary 1900 4 13 'prot-diary-calendar-anniversary-mark)
     Some anniversary is %d years
</pre>

<p>
The manual covers a lot of other potentially useful tasks you may
accomplish with those tools.  For example, it is possible to import an
iCalendar, convert from one calendar to another (e.g. Gregorian to
Chinese), get the phases of the moon, sunset and sunrise times in the
given geographic coordinates&#x2026;  Evaluate this expression to start
reading the relevant Info nodes: <code>(info "(emacs) Calendar/Diary")</code>.
</p>

<p>
For the integration with <code>outline-minor-mode</code> that <code>prot-diary.el</code> provides,
refer to the relevant section (in short: you get header folding like in
Org for every line that starts with <code>;;;</code>, given my <code>diary-comment-start</code> is
<code>;;</code>): <a href="#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1">Outline mode, outline minor mode (prot-outline.el)</a>.
</p>

<p>
Finally, note that I control the placement of those buffers in the
<code>display-buffer-alist</code> (read: <a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">Window rules and basic tweaks</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Calendar and Diary (and prot-diary.el)
(prot-emacs-builtin-package 'calendar
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-date-display-form calendar-iso-date-display-form)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 35.17         ; Not my actual coordinates
        calendar-longitude 33.36)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "+0200")
  (setq calendar-daylight-time-zone-name "+0300")

  (require 'diary-lib)
  (setq diary-mail-addr user-mail-address)
  (setq diary-date-forms diary-iso-date-forms)
  (setq diary-comment-start ";;")
  (setq diary-comment-end "")
  (setq diary-nonmarking-symbol "!")
  (setq diary-show-holidays-flag t)
  (setq diary-display-function #'diary-fancy-display) ; better than its alternative
  (setq diary-header-line-format nil)
  (setq diary-list-include-blanks nil)
  (setq diary-number-of-entries 2)
  (setq diary-mail-days 2)
  (setq diary-abbreviated-year-flag nil)

  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
  (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
  (add-hook 'diary-mode-hook #'goto-address-mode) ; buttonise plain text links

  ;; Those presuppose (setq diary-display-function #'diary-fancy-display)
  (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  ;; Prevent Org from interfering with my key bindings.
  (remove-hook 'calendar-mode-hook #'org--setup-calendar-bindings)

  (let ((map calendar-mode-map))
    (define-key map (kbd "s") #'calendar-sunrise-sunset)
    (define-key map (kbd "l") #'lunar-phases)
    (define-key map (kbd "i") nil) ; Org sets this, much to my chagrin (see `remove-hook' above)
    (define-key map (kbd "i a") #'diary-insert-anniversary-entry)
    (define-key map (kbd "i b") #'diary-insert-block-entry)
    (define-key map (kbd "i c") #'diary-insert-cyclic-entry)
    (define-key map (kbd "i d") #'diary-insert-entry) ; for current "day"
    (define-key map (kbd "i i") #'diary-insert-entry) ; most common action, easier to type
    (define-key map (kbd "i m") #'diary-insert-monthly-entry)
    (define-key map (kbd "i w") #'diary-insert-weekly-entry)
    (define-key map (kbd "i y") #'diary-insert-yearly-entry)
    (define-key map (kbd "M-n") #'calendar-forward-month)
    (define-key map (kbd "M-p") #'calendar-backward-month)))

(prot-emacs-builtin-package 'appt
  (setq appt-display-diary nil)
  (setq appt-disp-window-function #'appt-disp-window)
  (setq appt-display-mode-line t)
  (setq appt-display-interval 3)
  (setq appt-audible nil)
  (setq appt-warning-time-regexp "appt \\([0-9]+\\)")
  (setq appt-message-warning-time 6)

  (run-at-time 10 nil #'appt-activate 1))

(prot-emacs-builtin-package 'prot-diary
  ;; The idea is to get a reminder via email when I launch Emacs in the
  ;; morning and this file is evaluated.  Obviously this is not a super
  ;; sophisticated approach, though I do not need one.
  (let ((time (string-to-number (format-time-string "%H"))))
    (when (and (&gt; time 4) (&lt; time 9))
      (run-at-time (* 60 5) nil #'prot-diary-mail-entries)))

  (require 'holidays)
  (setq calendar-holidays (append holiday-solar-holidays prot-diary-local-holidays))

  (with-eval-after-load 'prot-outline
    (add-hook 'diary-mode-hook #'prot-outline-minor-mode-safe))

  (let ((map diary-mode-map))
    (define-key map (kbd "&lt;M-return&gt;") #'prot-diary-newline-indent)
    (define-key map (kbd "M-n") #'prot-diary-heading-next)
    (define-key map (kbd "M-p") #'prot-diary-heading-previous)
    (define-key map (kbd "C-c C-a") #'prot-diary-align-timestamped-entries))
  (let ((map global-map))
    (define-key map (kbd "C-c d c") #'calendar)
    (define-key map (kbd "C-c d d") #'prot-diary-display-entries)
    (define-key map (kbd "C-c d e") #'prot-diary-edit-diary)
    (define-key map (kbd "C-c d i") #'prot-diary-insert-entry)
    (define-key map (kbd "C-c d m") #'prot-diary-mail-entries)))
</pre>
</div>

<p>
These are the contents of the <code>prot-diary.el</code> library (find the source
code in <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (as with all my Elisp code)):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-diary.el --- Extensions for the diary and calendar -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for the diary and calendar, intended for my Emacs setup:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'calendar)
(require 'diary-lib)
(require 'prot-common)

(defgroup prot-diary ()
  "Tweaks for the calendar and diary."
  :group 'diary)

;;;; Commands and utilities

(defun prot-diary--list-entries (n inhibit)
  "Check for N days with diary entries.
When optional INHIBIT is non-nil, do not show thediary buffer."
  (let ((inhibit-message t)
        (hide (if inhibit t nil)))
    (diary-list-entries (calendar-current-date) n hide)))

(defvar prot-diary--current-window-configuration nil
  "Current window configuration.")

(defvar prot-diary--current-window-configuration-point nil
  "Point in current window configuration.")

(defun prot-diary--store-window-configuration ()
  "Store current window configuration and point."
  (setq prot-diary--current-window-configuration (current-window-configuration))
  (setq prot-diary--current-window-configuration-point (point)))

(defun prot-diary--restore-window-configuration ()
  "Restore `prot-diary--store-window-configuration'."
  (when prot-diary--current-window-configuration
    (set-window-configuration prot-diary--current-window-configuration))
  (when prot-diary--current-window-configuration-point
    (goto-char prot-diary--current-window-configuration-point)))

(autoload 'message-goto-body "message")

;;;###autoload
(defun prot-diary-mail-entries (&amp;optional ndays)
  "Email diary entries for NDAYS or `diary-mail-days'.

With optional DAYS as a positive integer, produce a list for N
days including the current one (so 2 is today and tomorrow).
Otherwise use `diary-mail-days'.

Alternative of `diary-mail-entries'.  Does not show the diary
buffer after sending the email and does not send a mail when no
entries are present (what is the point of first notifying me at
my inbox and then telling me 'Oh, nothing of interest here'?)."
  (interactive "p")
  (if (or (string-equal diary-mail-addr "")
          (null diary-mail-addr))
      (user-error "You must set `diary-mail-addr' to use this command")
    (let ((entries)
          (diary-display-function #'diary-fancy-display)
          (diary-mail-addr user-mail-address)
          (mail-user-agent 'message-user-agent)
          (n (or ndays diary-mail-days)))
      (prot-common-number-integer-positive-p n)
      (prot-diary--store-window-configuration)
      (diary-list-entries (calendar-current-date) (or n diary-mail-days))
      (if (prot-diary--list-entries n t)
          (progn
            (with-current-buffer (get-buffer diary-fancy-buffer)
              (setq entries (buffer-string))
              (kill-buffer) ; FIXME 2021-04-13: `bury-buffer' does not bury it...
              (prot-diary--restore-window-configuration))
            (compose-mail diary-mail-addr
                          (concat "Diary entries generated "
                                  (calendar-date-string (calendar-current-date)))
                          nil)
            (message-goto-body)
            (insert entries)
            (funcall (get mail-user-agent 'sendfunc)))
        (message "No diary entries; skipping email delivery")))))

;;;###autoload
(defun prot-diary-display-entries (&amp;optional days)
  "Display diary entries, if any.
With optional DAYS as a positive integer, produce a list for N
days including the current one (so 2 is today and tomorrow).
Otherwise use `diary-mail-days'."
  (interactive "p")
  (let ((n (or days diary-mail-days)))
    (prot-common-number-integer-positive-p n)
    (unless (prot-diary--list-entries n nil)
      (message "No diary entries; skipping display"))))

;;;###autoload
(defun prot-diary-edit-diary ()
  "Visit `diary-file'."
  (interactive)
  (let ((diary diary-file))
    (if (and (boundp 'diary-file)
             (file-regular-p diary))
        (find-file (expand-file-name diary))
      (error "No regular file `diary-file' is available"))))

;;;###autoload
(defun prot-diary-insert-entry (date)
  "Insert diary entry for DATE formatted as plain text."
  (interactive
   (list (read-string "Input date: " (format-time-string "%F"))))
  (diary-make-entry
   (concat (or date (format-time-string "%F")) "\s")))

(defvar align-default-spacing)

;;;###autoload
(defun prot-diary-align-timestamped-entries (beg end)
  "Align and indent region between BEG and END."
  (interactive "r")
  (let ((align-default-spacing 3))
    (align-regexp beg end (concat diary-time-regexp "\\( \\)") 2)
    (indent-rigidly beg end 4)))

;;;###autoload
(defun prot-diary-newline-indent ()
  "Insert newline and indent by four spaces."
  (interactive)
  (delete-horizontal-space)
  (newline)
  (insert (make-string 4 ?\s)))

;;;; Fontification extras

(defface prot-diary-calendar-anniversary-mark
  '((((class color) (min-colors 88) (background light))
     :background "#fff1f0" :foreground "#a60000")
    (((class color) (min-colors 88) (background dark))
     :background "#2c0614" :foreground "#ff8059")
    (t :foreground "red"))
  "Face to mark anniversaries in the calendar.")

(defface prot-diary-calendar-administrative-mark
  '((((class color) (min-colors 88) (background light))
     :background "#fff3da" :foreground "#813e00")
    (((class color) (min-colors 88) (background dark))
     :background "#221000" :foreground "#eecc00")
    (t :foreground "yellow"))
  "Face to mark administrative tasks in the calendar.")

(defface prot-diary-calendar-event-mark
  '((((class color) (min-colors 88) (background light))
     :background "#aceaac" :foreground "#004c00")
    (((class color) (min-colors 88) (background dark))
     :background "#00422a" :foreground "#9ff0cf")
    (t :foreground "green"))
  "Face to mark events in the calendar.")

(defface prot-diary-calendar-mundane-mark
  '((((class color) (min-colors 88) (background light))
     :background "#f0f0f0" :foreground "#505050")
    (((class color) (min-colors 88) (background dark))
     :background "#191a1b" :foreground "#a8a8a8")
    (t :inherit shadow))
  "Face to mark mundane tasks in the calendar.")

;; I might expand this further, depending on my usage patterns and the
;; conventions I establish over time.
(defconst prot-diary-font-lock-keywords
  `((,(format "^%s?\\(%s\\)" (regexp-quote diary-nonmarking-symbol)
             (regexp-quote diary-sexp-entry-symbol))
     (1 'font-lock-constant-face t))
    (diary-font-lock-sexps
     (0 'font-lock-function-name-face t))
    (,(format "^%s" (regexp-quote diary-nonmarking-symbol))
     (0 'font-lock-negation-char-face t))
    (,(format "%s.*" diary-comment-start)
     (0 'font-lock-comment-face)))
  "Rules for extra Diary fontification.")

(defvar outline-regexp)
(defvar outline-heading-end-regexp)

(defun prot-diary--outline-level ()
  "Determine Outline heading level.
To be assigned to the variable `outline-level'."
  (let ((regexp "\\(;;+\\{2,\\}\\) [^ \t\n]"))
    (looking-at regexp)
    (- (- (match-end 1) (match-beginning 1)) 2)))

(defun prot-diary--extras-setup ()
  "Additional setup for Diary mode buffers.
Applies `prot-diary-font-lock-keywords' and specifies what
constitutes a heading for the purposes of Outline minor mode."
  (when (derived-mode-p 'diary-mode)
    (font-lock-flush (point-min) (point-max))
    (font-lock-add-keywords nil prot-diary-font-lock-keywords t)
    (setq outline-regexp (format "%s+\\{2,\\} [^ \t\n]" diary-comment-start))
    (setq outline-level #'prot-diary--outline-level)
    (setq outline-heading-end-regexp (format "%s$" diary-comment-end))))

(add-hook 'diary-mode-hook #'prot-diary--extras-setup)

(defconst prot-diary-date-pattern
  "^!?\\(\\([0-9]+\\|\\*\\)[-/]\\([0-9]+\\|\\*\\)[-/]\\([0-9]+\\|\\*\\)\\|%%\\)"
  "Date pattern found in my diary (NOT ALL POSSIBLE PATTERNS).")

;;;###autoload
(defun prot-diary-heading-next (&amp;optional arg)
  "Move to next or optional ARGth Dired subdirectory heading.
For more on such headings, read `dired-maybe-insert-subdir'."
  (interactive "p")
  (let ((heading prot-diary-date-pattern))
    (goto-char (point-at-eol))
    (re-search-forward heading nil t (or arg nil))
    (goto-char (match-beginning 1))
    (goto-char (point-at-bol))))

;;;###autoload
(defun prot-diary-heading-previous (&amp;optional arg)
  "Move to previous or optional ARGth Dired subdirectory heading.
For more on such headings, read `dired-maybe-insert-subdir'."
  (interactive "p")
  (let ((heading prot-diary-date-pattern))
    (goto-char (point-at-bol))
    (re-search-backward heading nil t (or arg nil))
    (goto-char (point-at-bol))))

;;;; Holidays

(defvar prot-diary-local-holidays
  '((holiday-greek-orthodox-easter 0 "Easter")
    (holiday-greek-orthodox-easter -48 "Green Monday") ; REVIEW: is this correct?
    (holiday-fixed 5 9 "Day of Europe"))
  "I don't care about any of those---EXPERIMENTAL.")

(provide 'prot-diary)
;;; prot-diary.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:5ad80664-3163-4d9d-be65-462637d77903" class="outline-3">
<h3 id="h:5ad80664-3163-4d9d-be65-462637d77903"><span class="section-number-3">5.10.</span> Email settings</h3>
<div class="outline-text-3" id="text-h:5ad80664-3163-4d9d-be65-462637d77903">
<p>
Once you delve into the technical details, email is hard as it consists
of arcane specs and protocols.  Combined with Emacs' open-endedness as
well as the wealth of free software command-line programs on offer,
there are seemingly infinite ways to set things up.  The toolset for my
current setup consists of the following:
</p>

<ul class="org-ul">
<li>The external <code>mbsync</code> program to periodically synchronise my remote
email server and my local mail directories.  This allows me to keep a
copy of my correspondence, while it removes the burden of updating
mail sources from the client.  The latter benefit is particularly
important to avoid slowing down Emacs.</li>

<li>The Notmuch package which includes the CLI program and the Emacs
library that implements a Mail User Agent.  Notmuch is a mail indexer
that can search through the database using a strictly tags-only
workflow.  I was using Gnus in the past (between early 2020 and May
2021), but ultimately decided to upgrade my workflow by going with the
more flexible approach of Notmuch (I had also used Mu4e before, which
is closer in spirit to Notmuch and is a good choice overall&#x2014;in the
source code of my dotfiles, from where you can find this document,
there is the <code>prot-mu4e-deprecated-conf.el</code> file in case you need it;
same for <code>prot-gnus-deprecated-conf.org</code>).</li>

<li>The built-in capabilities to compose and send email.</li>

<li>Other extensions to integrate email composition with encryption tools,
Dired, Org, contact-completion (EBDB)&#x2026;</li>
</ul>

<p>
<b>This is a mega section that encompasses all of the aforementioned.</b>
Please study it carefully.
</p>
</div>

<div id="outline-container-h:a82766be-daab-4925-b23a-1c5ffd47e599" class="outline-4">
<h4 id="h:a82766be-daab-4925-b23a-1c5ffd47e599"><span class="section-number-4">5.10.1.</span> Client-agnostic email settings (and prot-mail.el)</h4>
<div class="outline-text-4" id="text-h:a82766be-daab-4925-b23a-1c5ffd47e599">
<p>
Before configuring any mail user agent, we need to establish the
absolute essentials: who we are, where our authentication credentials
are stored, and whether encryption is to be supported.  We must also
define how message composition should work.  This is what the following
configurations are about.
</p>

<ul class="org-ul">
<li>The <code>mail-user-agent</code> and <code>message-mail-user-agent</code> concern the default
email composition buffer, called with <code>C-x m</code> or any other facility that
falls back to the <code>compose-mail</code> function.  The default is <code>message-mode</code>.

<ul class="org-ul">
<li>When notmuch is in use, it will insert a special "Fcc" header whose
task is to copy the outgoing message to the appropriate maildir path
(this part is done in <a href="#h:a196812e-1644-4536-84ba-687366867def">the Notmuch section</a>).</li>
</ul></li>

<li>The value of <code>message-citation-line-format</code> is expanded into something
like <i>"On 2020-02-19, 13:54 +0200, NAME &lt;EMAIL&gt; wrote:"</i>.  To learn
about all the date-related specifiers, it is better to read the
documentation with <code>M-x describe-variable RET format-time-string RET</code>.</li>

<li>The <code>mm-encode</code> and <code>mml-sec</code> are meant to come into effect when
encrypting and signing an outgoing message, such as with <code>C-c C-m C-e</code>
(<code>mml-secure-message-sign-encrypt</code>).  The optional guided key selection
will ask for confirmation on who to encrypt to.  It presents a list
with the available keys.  Items are marked with <code>m</code> and then the mail
can be sent with the standard commands (e.g. <code>C-c C-c</code>).  I used that
setup for a while, but ultimately decided that the extra steps did not
make any difference to my workflow, as I always double-check before
sending out an email.</li>

<li>The <code>gnus-dired</code> library can be used independently of Gnus (and should
thus be refactored as "message-dired.el" or something).  It provides
glue code that integrates Dired buffers with message composition, so
that one can attach either the file at point or the marked ones with
<code>C-c C-m C-a</code> (<code>gnus-dired-attach</code>).</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Client-agnostic email settings (and prot-mail.el)
(prot-emacs-builtin-package 'auth-source
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Protesilaos Stavrou")
  (setq user-mail-address "public@protesilaos.com"))

(prot-emacs-builtin-package 'mm-encode
  (setq mm-encrypt-option nil) ; use 'guided if you need more control
  (setq mm-sign-option nil))   ; same

(prot-emacs-builtin-package 'mml-sec
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(prot-emacs-builtin-package 'message
  (setq mail-user-agent 'message-user-agent)
  (setq mail-header-separator (purecopy "*****"))
  (setq message-elide-ellipsis "&gt;\n&gt; [... %l lines elided]\n&gt;\n&gt;") ; NOTE 2021-07-13: experimental
  (setq compose-mail-user-agent-warnings nil)
  (setq message-mail-user-agent t)      ; use `mail-user-agent'
  (setq mail-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-citation-line-format "On %Y-%m-%d, %R %z, %f wrote:\n")
  (setq message-citation-line-function
        'message-insert-formatted-citation-line)
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  (setq message-wide-reply-confirm-recipients t)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

  (add-hook 'message-setup-hook #'message-sort-headers))

(prot-emacs-builtin-package 'gnus-dired ; does not require `gnus'
  (add-hook 'dired-mode-hook #'gnus-dired-mode))

(prot-emacs-builtin-package 'prot-mail
  ;; NOTE 2021-05-14: This is a generic indicator for new mail in the
  ;; maildir.  As I now use notmuch (see relevant section in this
  ;; document) I have an alternative approach in prot-notmuch.el.
  (setq prot-mail-maildir-path-regexp "~/.mail/*/Inbox/new/") ; shell regexp
  (setq prot-mail-mode-line-indicator-commands
        '(notmuch-refresh-this-buffer))
  ;; mode line indicator with the number of new mails
  (prot-mail-mail-indicator -1))
</pre>
</div>

<p>
And here is <code>prot-mail.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-mail.el --- Mail tweaks for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my email tweaks, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)

(defgroup prot-mail ()
  "Extensions for mail."
  :group 'mail)

(defcustom prot-mail-maildir-path-regexp "~/.mail/*/Inbox/new/"
  "Path passed to 'find' for checking new mail in maildir.
As this is passed to a shell command, one can use glob patterns.

The user must ensure that this path or regexp matches the one
specified in the mail syncing program (e.g. mbsync)."
  :type 'string
  :group 'prot-mail)

(defcustom prot-mail-mode-line-indicator-commands '(notmuch-refresh-this-buffer)
  "List of commands that will be advised to update the mode line.
The advice is designed to run a hook which is used internally by
the function `prot-mail-mail-indicator'."
  :type 'list
  :group 'prot-mail)

;;;; Helper functions

(autoload 'auth-source-search "auth-source")

;;;###autoload
(defun prot-mail-auth-get-field (host prop)
  "Find PROP in `auth-sources' for HOST entry."
  (when-let ((source (auth-source-search :host host)))
    (if (eq prop :secret)
       (funcall (plist-get (car source) prop))
      (plist-get (flatten-list source) prop))))

(defvar ebdb-db-list)
(autoload 'ebdb-load "ebdb")

(when (require 'ebdb nil t)
  (defun prot-mail-ebdb-message-setup ()
    "Load EBDB if not done already.
Meant to be assigned to a hook, such as `message-setup-hook'."
    (unless ebdb-db-list
      (ebdb-load))))

;;;; Mode line indicator

;; NOTE 2021-05-14: The following is a more generic approach that uses
;; find to search for new mail.  In my prot-notmuch.el I define an
;; alternative that checks for the "unread" tag, which works better for
;; my particular setup (refer to my prot-emacs.org for the relevant
;; commentary).

(defface prot-mail-mail-count
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#61284f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#fbd6f4")
    (t :foreground "magenta"))
  "Face for mode line indicator that shows a new mail count.")

(defvar prot-mail-new-mail-string nil
  "New maildir count number for the mode line.")

(defun prot-mail--new-mail ()
  "Search for new mail in personal maildir paths."
  (with-temp-buffer
    (shell-command
     (format "find %s -type f | wc -l" prot-mail-maildir-path-regexp) t)
    (buffer-substring-no-properties (point-min) (1- (point-max)))))

(defun prot-mail--mode-string (count)
  "Add properties to COUNT string."
  (when (not (string= count "0"))
    (propertize (format "@%s " count)
                'face 'prot-mail-mail-count
                'help-echo "Number of new items in maildirs")))

(defvar prot-mail--mode-line-mail-indicator nil
  "Internal variable used to store the state of new mails.")

(defun prot-mail--mode-line-mail-indicator ()
  "Prepare new mail count mode line indicator."
  (let* ((count (prot-mail--new-mail))
         (indicator (prot-mail--mode-string count))
         (old-indicator prot-mail--mode-line-mail-indicator))
    (when old-indicator
      (setq global-mode-string (delete old-indicator global-mode-string)))
    (cond
     ((&gt;= (string-to-number count) 1)
      (setq global-mode-string (push indicator global-mode-string))
      (setq prot-mail--mode-line-mail-indicator indicator))
     (t
      (setq prot-mail--mode-line-mail-indicator nil)))))

(defvar prot-mail--mode-line-mail-sync-hook nil
  "Hook to refresh the mode line for the mail indicator.")

(defun prot-mail--add-hook (&amp;rest _)
  "Run `prot-mail--mode-line-mail-sync-hook'.
Meant to be used as advice after specified commands that should
update the mode line indicator with the new mail count."
  (run-hooks 'prot-mail--mode-line-mail-sync-hook))

;;;###autoload
(define-minor-mode prot-mail-mail-indicator
  "Enable mode line indicator with counter for new mail."
  :init-value nil
  :global t
  (if prot-mail-mail-indicator
      (progn
        (run-at-time t 60 #'prot-mail--mode-line-mail-indicator)
        (when prot-mail-mode-line-indicator-commands
          (dolist (fn prot-mail-mode-line-indicator-commands)
            (advice-add fn :after #'prot-mail--add-hook)))
        (add-hook 'prot-mail--mode-line-mail-sync-hook #'prot-mail--mode-line-mail-indicator)
        (force-mode-line-update t))
    (cancel-function-timers #'prot-mail--mode-line-mail-indicator)
    (setq global-mode-string (delete prot-mail--mode-line-mail-indicator global-mode-string))
    (remove-hook 'prot-mail--mode-line-mail-sync-hook #'prot-mail--mode-line-mail-indicator)
    (when prot-mail-mode-line-indicator-commands
      (dolist (fn prot-mail-mode-line-indicator-commands)
        (advice-remove fn #'prot-mail--add-hook)))
    (force-mode-line-update t)))

(provide 'prot-mail)
;;; prot-mail.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:8d0bd754-8a31-431b-b112-f541cc0144ac" class="outline-5">
<h5 id="h:8d0bd754-8a31-431b-b112-f541cc0144ac"><span class="section-number-5">5.10.1.1.</span> Sample of authinfo.gpg</h5>
<div class="outline-text-5" id="text-h:8d0bd754-8a31-431b-b112-f541cc0144ac">
<p>
Below is a sample with the contents of my <code>authinfo.gpg</code>.  This is read,
inter alia, by <code>notmuch</code> and <code>smtpmail</code> to be able to both fetch and send
messages from the given account.  By default, one can use a generic
<code>authinfo</code> file though I consider that reckless: I strongly encourage you
to <b>encrypt this file</b> if you add your login credentials there.  Do it
from inside <code>dired</code> with <code>: e</code> while the point is over the file.  Emacs can
decrypt all encrypted files automatically.
</p>

<pre class="example" id="org752306c">
machine prv port 993 login MAIL password SECRET
machine inf port 993 login MAIL password SECRET
machine pub port 993 login MAIL password SECRET

machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
</pre>

<p>
Refer to your email provider's documentation in order to determine the
port number and server address you need to use for sending and receiving
messages.  The <code>MAIL</code> is either your email address or some username for
logging into the account.
</p>

<p>
Note that the terms I use above for <code>prv</code>, <code>inf</code>, and <code>pub</code> are just arbitrary
names for the given <code>MAIL</code> and <code>SECRET</code> combination.  This allows me to
reference each name in the various package configurations in this
document, and share them publicly without worrying about leaking
sensitive data.
</p>

<p>
Which brings us to the point of actually retrieving those values.  The
<code>prot-mail-auth-get-field</code> is designed to return a field from the authinfo
file (this function is defined in my <code>prot-mail.el</code>, which is reproduced
at the end of <a href="#h:a82766be-daab-4925-b23a-1c5ffd47e599">Client-agnostic email settings (and prot-mail.el)</a>).  You
will find this function used elsewhere in this document.  For example,
to get the username and password for host <code>inf</code> we do:
</p>

<pre class="example" id="orgfbdf540">
(prot-mail-auth-get-field "inf" :user)   ; login name
(prot-mail-auth-get-field "inf" :secret) ; password
</pre>
</div>
</div>

<div id="outline-container-h:88a605b8-d5b5-486f-87c9-0c80b423ae36" class="outline-5">
<h5 id="h:88a605b8-d5b5-486f-87c9-0c80b423ae36"><span class="section-number-5">5.10.1.2.</span> .mbsyncrc</h5>
<div class="outline-text-5" id="text-h:88a605b8-d5b5-486f-87c9-0c80b423ae36">
<p>
I already noted in the introduction to <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">Email settings</a> that my emails are
synced locally using the <code>mbsync</code> executable.  This program is part of a
package that, depending on your operating system, is called "isync".
Read the <a href="https://wiki.archlinux.org/index.php/Isync">Arch Wiki entry on mbsync</a>.
</p>

<p>
My <code>~/.mbsyncrc</code> is furnished below.  Note that the <code>awk</code> call reads from
the <code>~/.authinfo.gpg</code> (see <a href="#h:8d0bd754-8a31-431b-b112-f541cc0144ac">Sample of authinfo.gpg</a>).
</p>

<div class="org-src-container">
<pre class="src src-conf">IMAPAccount pub
Host mail.gandi.net
UserCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/pub/ { print $(NF-2); exit; }'"
PassCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/pub/ { print $NF; exit; }'"
SSLType IMAPS

IMAPStore pub-remote
Account pub

MaildirStore pub-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/pub/
Inbox ~/.mail/pub/Inbox

Channel pub
Far :pub-remote:
Near :pub-local:
# Include everything
Patterns *
Create Both
# Expunge Both
SyncState *

##########

IMAPAccount inf
Host mail.gandi.net
UserCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/inf/ { print $(NF-2); exit; }'"
PassCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/inf/ { print $NF; exit; }'"
SSLType IMAPS

IMAPStore inf-remote
Account inf

MaildirStore inf-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/inf/
Inbox ~/.mail/inf/Inbox

Channel inf
Far :inf-remote:
Near :inf-local:
# Include everything
Patterns *
Create Both
# Expunge Both
SyncState *

##########

IMAPAccount prv
Host mail.gandi.net
UserCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/prv/ { print $(NF-2); exit; }'"
PassCmd "gpg2 -q --for-your-eyes-only -d ~/.authinfo.gpg | awk -F ' ' '/prv/ { print $NF; exit; }'"
SSLType IMAPS

IMAPStore prv-remote
Account prv

MaildirStore prv-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/prv/
Inbox ~/.mail/prv/Inbox

Channel prv
Far :prv-remote:
Near :prv-local:
# Include everything
Patterns *
Create Both
# Expunge Both
SyncState *
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:a196812e-1644-4536-84ba-687366867def" class="outline-4">
<h4 id="h:a196812e-1644-4536-84ba-687366867def"><span class="section-number-4">5.10.2.</span> Notmuch (mail indexer and mail user agent (MUA))</h4>
<div class="outline-text-4" id="text-h:a196812e-1644-4536-84ba-687366867def">
<p>
Also watch the video of what you are about to read in the following
paragraphs: <a href="https://protesilaos.com/codelog/2021-05-15-emacs-notmuch/">Demo of the Emacs front-end to Notmuch</a> (2021-05-15).
</p>


<p>
At its core, Notmuch is a command-line program that maintains an index
of a maildir directory structure and is capable to search through it
using a tag-based method.  Notmuch is both minimalist and powerful:
</p>

<ol class="org-ol">
<li>its clearly delimited role as a mail indexer allows it to be used in
a variety of setups that involve different tools on how to handle
email traffic;</li>

<li>while its tag-centric design lifts the inherent restrictions of
complex filesystem paths on where a file must be stored, as messages
can be grouped together dynamically depending on the search criteria.</li>
</ol>

<p>
In terms of overall setup, I use Notmuch together with <code>mbsync</code> to
synchronise my maildir with the IMAP server (consult my <a href="#h:88a605b8-d5b5-486f-87c9-0c80b423ae36">.mbsyncrc</a>).
While I send messages with Emacs' own facility which relies on the
<code>sendmail</code> program (refer to <a href="#h:2d793cf8-83f5-4830-b73d-78385d9b96dd">Sending email (SMTP)</a>).  The latter may change
in the future, as I weigh the pros and cons of programs like <code>msmtp</code>,
though this is low on my list of priorities.  As for the actual
composition of emails, it is done by Emacs' <code>message.el</code> library
(<a href="#h:a82766be-daab-4925-b23a-1c5ffd47e599">Client-agnostic email settings (and prot-mail.el)</a>).
</p>

<p>
Tagging is integral to the Notmuch experience, because it allows you to
cope with evolving circumstances.  It is best to consider this by means
of an example.  Suppose that you are working on some project: (1) there
is an email in your private account from a close friend that contains
valuable information but which is part of an otherwise long thread that
is not pertinent in its entirety to the task at hand, (2) there is
another message from a mailing list you do not actively participate in
and this message lives in your "throwaway" account that you use only for
mailing lists and the like, and (3) there is yet another mail from some
client or employer that is specific to the project and which is kept in
your designated "professional" inbox.  Lets say that those correspond to
"private@example.tld", "lists@example.tld", "work@example.tld".  In a
folder-based approach, it is hard to combine those otherwise unrelated
files.  Whereas with tags, say, <code>+project</code>, we can get everything into
focus with a simple search for <code>tag:project</code>.
</p>

<p>
While we will be using the Emacs interface to Notmuch, it is important
to spend some time reading the man pages for the CLI tools.  Some
examples for searching:
</p>

<pre class="example" id="orgb79fb26">
$ notmuch search from:prot*
$ notmuch search from:protesilaos tag:todo
$ notmuch search from:protesilaos or from:socrates
$ notmuch search 'from:"/(info|public)@protesilaos.com/"'
$ notmuch search 'from:"/(info|public)@protesilaos.com/"' date:yesterday..today
$ notmuch search '(from:"*@protesilaos.com*" not to:"*@protesilaos.com*")' date:today
$ notmuch search from:"*@protesilaos.com*" date:today..08:00
$ notmuch search body:recrudescence
$ notmuch search path:inf/Inbox/** date:2021-05
</pre>

<p>
There is no need to develop expertise in that syntax at the outset.
Just learn the basics and let the rest grow organically through regular
usage.  Though do read the man pages as they include important
information such as what "stemming" is and how it affects your search
results.
</p>

<p>
Now let's focus on the Emacs side of things, starting with the
"notmuch-hello" buffer (it runs <code>notmuch-hello-mode</code>).  What exactly shows
up here depends on <code>notmuch-hello-sections</code>.  I like to keep it clean.  At
any rate, from here we can switch to results from saved searches or
tags, or perform a new search:
</p>

<ul class="org-ul">
<li>Type <code>j</code> to invoke <code>notmuch-jump-search</code>: it will produce a prompt for a
key binding that corresponds to one of your saved searches (controlled
by the variable <code>notmuch-saved-searches</code>).</li>

<li>With <code>t</code> for <code>notmuch-search-by-tag</code> you get minibuffer completion against
all known tags.</li>

<li>Hit <code>s</code> to call <code>notmuch-search</code> which lets you type a query such as one
of the aforementioned examples.  In the "notmuch-hello" buffer I keep
a list of recent searches, which can be helpful to re-use at a later
point, though we can always benefit from minibuffer history
navigation, such as <code>M-n</code> and <code>M-p</code> while at the <code>notmuch-search</code> prompt.</li>

<li>Same principle for <code>z</code> (<code>notmuch-tree</code>) only it differs from the above
search in the overall presentation where it visualises each thread
using indentation and arrows to show what belongs where.  It also
reduces the subject line to the first entry in each thread, making it
easier to follow the results.</li>
</ul>

<p>
All of those will put you in a buffer that runs <code>notmuch-search-mode</code>.  As
always, you should use <code>C-h m</code> (<code>describe-mode</code>) to learn about everything
related to the current major mode (as well as all active minor modes).
</p>

<p>
To further limit the results to an arbitrary list of search criteria,
use <code>l</code> (<code>notmuch-search-filter</code>) and then supply whatever terms are needed.
Or use <code>t</code>, which is here bound to <code>notmuch-search-filter-by-tag</code> to filter
directly by tag using completion.  For example, I can start from the
"notmuch-hello" buffer with <code>notmuch-search-by-tag</code>, select "todo", and
then use <code>l</code> or <code>t</code> to further narrow to, say, a "replied" tag or
<code>date:today</code>.
</p>

<p>
Filtering of search results is the best way to narrow the list to
relevant matches.  You can try supplying just a search term without any
keywords and you are likely to get what you are looking for.  For
example, I was in a search that included results from the emacs-devel
and bug-gnu-emacs mailing lists and had several unread threads, though I
only wanted to read about "group-function".  So I just hit <code>l</code>
(<code>notmuch-search-filter</code>) and then typed in that query.  Same principle if
you wish to exclude something, such as with <code>not tag:flag</code>.
</p>

<p>
The Notmuch presentation is compact when it comes to longer threads as
it reduces them to a single line.  We can still get a sense of context
by viewing the total count of messages in the thread: this is controlled
by the variable <code>notmuch-search-result-format</code>.  While I like this as a
default, there are cases where we need to visualise the email exchanges:
<code>notmuch-tree-from-unthreaded-current-query</code> can do just that and is bound
to <code>Z</code> in <code>notmuch-search-mode-map</code>.  A similar variant is <code>U</code> for
<code>notmuch-unthreaded-from-search-current-query</code>, as it expands the view
without adding the tree indicators and without de-duplicating subject
lines across the threads.  Go back to the standard search view with <code>S</code>
(<code>notmuch-search-from-tree-current-query</code>).
</p>

<p>
All those changes in presentation happen in new buffers: you do not lose
anything, unless you explicitly kill those buffers.  For the sake of
convenience, Notmuch provides the <code>notmuch-bury-or-kill-this-buffer</code>
command, bound to <code>q</code> in all those views.  Read its doc string to know
when it kills and when it buries the buffer.  Of course, you may always
use commands like <code>previous-buffer</code> as well as minibuffer completion and
<code>M-x ibuffer</code> or whatever else you normally use.  The point is that you
can easily switch views to get the job done.
</p>

<p>
Speaking of multiple buffers, Notmuch provides two commands to refresh
those: (i) <code>notmuch-refresh-this-buffer</code>, which is bound by default to the
usual <code>g</code> key as well as <code>=</code>, and (ii) <code>notmuch-refresh-all-buffers</code> which is
assigned to <code>M-g</code>.  My <code>prot-notmuch-refresh-buffer</code> is a wrapper of those
two and is mapped to <code>g</code>: when called with a <code>C-u</code> prefix argument, it
refreshes all buffers, else it operates on the current one.  There is
also <code>G</code> (<code>notmuch-poll-and-refresh-this-buffer</code>) which runs <code>notmuch new</code>
externally and then refreshes the buffer&#x2014;personally I don't need this
as mbsync automatically does that every few minutes.
</p>

<p>
To read a thread, hit <code>RET</code> (<code>notmuch-search-show-thread</code>) with point over
it in any those search/tree views.  That puts you in <code>notmuch-show-mode</code>
(did I tell you about <code>C-h m</code>?).  Notmuch organises all messages in the
thread as headings, where the first line with the summary of the message
uses a special face (a background colour, though that depends on the
theme).  With point over the heading's line <code>RET</code> expands or contracts the
body of the message.  The <code>n</code> and <code>p</code> keys move between expanded messages in
the thread, while <code>N</code> and <code>P</code> always go to the next and previous items,
respectively.  An Imenu index is also available, so you can jump to any
heading using minibuffer completion (with <code>M-x imenu</code> or some third-party
extension like the <code>consult-imenu</code> that I use).
</p>

<p>
When you compose an email, such as by replying with <code>r</code> or <code>R</code>, you are
taken to a buffer that leverages functionality provided by the built-in
<code>message.el</code>.  As always, run <code>C-h m</code> to get a sense of how things work and
what commands you may call: <code>C-c C-c</code> dispatches the email, <code>C-c C-a</code>
prompts for an attachment, <code>C-c C-m C-e</code> encrypts and signs, <code>C-c C-m C-a</code>
from a Dired buffer attaches the file at point or any marked ones (refer
to <a href="#h:a82766be-daab-4925-b23a-1c5ffd47e599">Client-agnostic email settings (and prot-mail.el)</a>).
</p>

<p>
For searching to be productive, we must apply tags in accordance with a
defined method of organising our workflow (more about my approach
further below).  Too many over-specialised or poorly considered tags
will likely make things more difficult, while too few will probably
prevent you from finding what you need.  How you go about it is up to
you.  Notmuch is just a tool: don't believe in the hype of magical
exominds or second brains that do the work on your behalf&#x2014;maximise the
potential of the one mind you have and the rest will follow from there.
</p>

<p>
Tag addition or removal is denoted by a plus or minus prefix to the name
of the tag.  The <code>k</code> binding exists in all relevant mode maps: it offers a
shortcut to the "keys" (tags) that can be used to mark a give entry.
That command will prompt for a choice among <code>notmuch-tagging-keys</code>.  For
example <code>k d</code> will do <code>+del -inbox</code>, based on what I currently have.  Invert
the meaning of those terms by prefixing the command with a <code>C-u</code> argument.
</p>

<p>
To freely tag all items in the current view (search, tree, show) use <code>*</code>.
That gives you a completion prompt where multiple terms can be supplied,
each delimited by a space (internally this is <code>completing-read-multiple</code>
and the space is governed by a let-bound <code>crm-separator</code>).  Combine that
with the aforementioned methods for limiting the view to a given subset
for maximum effect.
</p>

<p>
Other ways to perform tagging operations involve the <code>+</code> and <code>-</code> keys.  They
also use <code>completing-read-multiple</code>.  What those commands offer, beside
the minibuffer interface, is the ability to operate on the entries
encompassed by the active region, where point and mark delimit the lines
to be affected.  There are cases where marking a region is faster than
narrowing the view with new search criteria, so use whatever makes sense
at the moment.
</p>

<p>
Remember the governing principle of Notmuch: it does not touch your
mail.  All those tags are specific to the Notmuch database (with the
exception of some basic tags that are understood by the IMAP server and
can be optionally affected by Notmuch (<a href="#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5">.notmuch-config</a> has the
<code>synchronize_flags=true</code> directive).
</p>

<p>
As Notmuch is not a traditional mail client, it has neither opinions nor
capabilities on how one handles their maildir.  It does not move files
around nor does it have its own deletion and anti-spam mechanisms.  It
is up to the user to provide those.  While this may seem needlessly
limited at first, it is consistent with the precise function that
Notmuch performs in the broader email toolkit.  To actually delete mail,
we can tag it accordingly (e.g. "del") and then run this command either
manually or from a script with some cron job or systemd timer:
</p>

<pre class="example" id="orgcf78d38">
notmuch search --output=files --format=text0 tag:del | xargs -r0 rm
</pre>

<p>
I actually prefer the manual method: mark items with <code>+del</code> and perform
their removal from the disk whenever it is expedient.  This has the
upside of offering me the chance to review the messages, in case I have
mislabelled some item: I have deleted legitimate mail before, so it is
not a bad idea to be extra careful.
</p>

<p>
I have no pressing need to define commands for moving my mail files
between different directories: I did not do that even while I was using
Gnus.  Though I might eventually do it just for the sake of
completeness.  As such, consider the following package configurations a
work-in-progress, though they already offer all I need to get things
done.
</p>

<p>
With regard to the use of tags for day-to-day usage, I like to employ
the <code>tag:inbox and tag:unread</code> search as well as <code>tag:inbox</code> for practically
everything that is unsorted or of general interest.  Then I have
specialised tags like "list" for mailing lists which should not belong
in the inbox and "todo" for messages that require some further action
(those can always be complemented by other tags for greater precision
such as <code>+list +emacs</code>).  To keep things in check, a "post-new" script
outside the Emacs setup performs initial tagging on new mail.  For
example, my sent messages are marked as <code>-unread</code> while new mailing list
traffic goes to its right place with tags like <code>-inbox +list</code> (refer to
the sections on <a href="#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5">.notmuch-config</a> and <a href="#h:70d60d41-cb63-4950-bbd9-9157c4d186dc">notmuch post-new rules</a>).  Those that
I manually mark as <code>+todo</code> can optionally be combined with <code>org-capture</code> to
record a task that may appear in the Org agenda: call the <code>org-capture</code>
command while viewing such a message and Org will create a direct link
back to it: the glue code is found in <a href="#h:a7580136-cf32-44e8-81f6-590dbdd7f8f9">the section on ol-notmuch.el</a> while
my <code>org-capture-templates</code> and their <code>org-capture-templates-contexts</code> are
defined in <a href="#h:4e8347de-415e-4804-b383-d61499e05ca1">Org-mode (personal information manager)</a>).
</p>

<p>
Unlike most Emacs packages, I install <code>notmuch</code> from my distro's repos.
This is because (i) the CLI program is independent of Emacs, and (ii)
<code>notmuch.el</code> is bundled up together with the command-line tool because the
two are developed by the same group of people.  All good!  There is also
this note in <code>M-x find-library RET notmuch RET</code>:
</p>

<blockquote>
<p>
Note for MELPA users (and others tracking the development version
of notmuch-emacs):
</p>

<p>
This emacs package needs a fairly closely matched version of the
notmuch program. If you use the MELPA version of notmuch.el (as
opposed to MELPA stable), you should be prepared to track the
master development branch (i.e. build from git) for the notmuch
program as well. Upgrading notmuch-emacs too far beyond the notmuch
program can CAUSE YOUR EMAIL TO STOP WORKING.
</p>

<p>
TL;DR: notmuch-emacs from MELPA and notmuch from distro packages is
NOT SUPPORTED.
</p>
</blockquote>

<p>
Finally, my <code>prot-notmuch.el</code> contains various commands and some minor
stylistic extras including a mode line indicator that shows a count of
all items matching the search terms <code>tag:unread and tag:inbox</code> (can be
configured by the variable <code>prot-notmuch-mode-line-search-args</code>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Notmuch (mail indexer and mail user agent (MUA))
;; I install notmuch from the distro's repos because the CLI program is
;; not dependent on Emacs.  Though the package also includes notmuch.el
;; which is what we use here (they are maintained by the same people).
(add-to-list 'load-path "/usr/share/emacs/site-lisp/")
(prot-emacs-builtin-package 'notmuch

;;; Account settings
  (setq notmuch-identities
        (let ((identities))
          (dolist (m `(,(prot-mail-auth-get-field "prv" :user)
                       ,(prot-mail-auth-get-field "inf" :user)
                       ,(prot-mail-auth-get-field "pub" :user)))
            (push (format "%s &lt;%s&gt;" user-full-name m) identities))
          identities))
  (setq notmuch-fcc-dirs
        `((,(prot-mail-auth-get-field "prv" :user) . "prv/Sent")
          (,(prot-mail-auth-get-field "inf" :user) . "inf/Sent")
          (,(prot-mail-auth-get-field "pub" :user) . "pub/Sent")))

;;; General UI
  (setq notmuch-show-logo nil)
  (setq notmuch-column-control t)
  (setq notmuch-hello-auto-refresh t)
  (setq notmuch-hello-recent-searches-max 20)
  (setq notmuch-hello-thousands-separator "")
  ;; ;; See my variant of it in `prot-notmuch' below.
  ;; (setq notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (setq notmuch-show-all-tags-list nil)

;;; Search
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-search-result-format
        '(("date" . "%12s  ")
          ("count" . "%-7s  ")
          ("authors" . "%-20s  ")
          ("subject" . "%-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-tree-result-format
        '(("date" . "%12s  ")
          ("authors" . "%-20s  ")
          ((("tree" . "%s")
            ("subject" . "%s"))
           . " %-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . notmuch-search-flagged-face)))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-saved-searches
        `(( :name "inbox"
            :query "tag:inbox"
            :sort-order newest-first
            :key ,(kbd "i"))
          ( :name "unread (inbox)"
            :query "tag:unread and tag:inbox"
            :sort-order newest-first
            :key ,(kbd "u"))
          ( :name "unread all"
            :query "tag:unread not tag:archived"
            :sort-order newest-first
            :key ,(kbd "U"))
          ( :name "references"
            :query "tag:ref not tag:archived"
            :sort-order newest-first
            :key ,(kbd "r"))
          ( :name "todo"
            :query "tag:todo not tag:archived"
            :sort-order newest-first
            :key ,(kbd "t"))
          ( :name "mailing lists"
            :query "tag:list not tag:archived"
            :sort-order newest-first
            :key ,(kbd "m"))
          ;; Emacs
          ( :name "emacs-devel"
            :query "(from:emacs-devel@gnu.org or to:emacs-devel@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e d"))
          ( :name "emacs-orgmode"
            :query "(from:emacs-orgmode@gnu.org or to:emacs-orgmode@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e o"))
          ( :name "emacs-bugs"
            :query "'to:\"/*@debbugs.gnu.org*/\"' not tag:archived"
            :sort-order newest-first :key ,(kbd "e b"))
          ( :name "emacs-humanities"
            :query "(from:emacs-humanities@gnu.org or to:emacs-humanities@gnu.org) not tag:archived"
            :sort-order newest-first :key ,(kbd "e h"))
          ( :name "emacs-elpher"
            :query "(from:~michel-slm/elpher@lists.sr.ht or to:~michel-slm/elpher@lists.sr.ht) not tag:archived"
            :sort-order newest-first :key ,(kbd "e e"))
          ;; CLI tools
          ( :name "notmuch"
            :query "(from:notmuch@notmuchmail.org or to:notmuch@notmuchmail.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "cn"))))

;;; Tags
  (setq notmuch-archive-tags '("-inbox" "+archived"))
  (setq notmuch-message-replied-tags '("+replied"))
  (setq notmuch-message-forwarded-tags '("+forwarded"))
  (setq notmuch-show-mark-read-tags '("-unread"))
  (setq notmuch-draft-tags '("+draft"))
  (setq notmuch-draft-folder "drafts")
  (setq notmuch-draft-save-plaintext 'ask)
  ;; ;; NOTE 2021-06-18: See an updated version in the `prot-notmuch'
  ;; ;; section below.
  ;; (setq notmuch-tagging-keys
  ;;       `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
  ;;         (,(kbd "c") ("+archived" "-inbox" "-list" "-todo" "-ref" "-unread") "Complete and archive")
  ;;         (,(kbd "d") ("+del" "-inbox" "-archived" "-unread") "Mark for deletion")
  ;;         (,(kbd "f") ("+flag" "-unread") "Flag as important")
  ;;         ;; (,(kbd "r") notmuch-show-mark-read-tags "Mark as read")
  ;;         (,(kbd "r") ("+ref" "-unread") "Reference for the future")
  ;;         (,(kbd "s") ("+spam" "+del" "-inbox" "-unread") "Mark as spam")
  ;;         (,(kbd "t") ("+todo" "-unread") "To-do")
  ;;         (,(kbd "u") ("+unread") "Mark as unread")))
  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged))))
  (setq notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag `notmuch-tag-deleted))
          (".*" (notmuch-apply-face tag `notmuch-tag-deleted))))

;;; Email composition
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil) ; TODO 2021-05-12: Review hidden headers
  (setq notmuch-address-command nil)    ; FIXME 2021-05-13: Make it work with EBDB
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function #'notmuch-mua-user-agent-full)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\|"
                "pi[èe]ce\s+jointe?\\|"
                "συνημμ[εέ]νο\\|επισυν[αά]πτω\\)\\b"))

;;; Reading messages
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-save-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-citation-lines-prefix 6)
  (setq notmuch-wash-citation-lines-suffix 6)
  (setq notmuch-wash-wrap-lines-length 100)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t)

;;; Hooks and key bindings
  (add-hook 'notmuch-mua-send-hook #'notmuch-mua-attachment-check)
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (add-hook 'notmuch-show-hook (lambda () (setq-local header-line-format nil)))

  (let ((map global-map))
    (define-key map (kbd "C-c m") #'notmuch)
    (define-key map (kbd "C-x m") #'notmuch-mua-new-mail)) ; override `compose-mail'
  (define-key notmuch-search-mode-map (kbd "/") #'notmuch-search-filter) ; alias for l
  (define-key notmuch-hello-mode-map (kbd "C-&lt;tab&gt;") nil))

(prot-emacs-builtin-package 'prot-notmuch
  ;; Those are for the actions that are available after pressing 'k'
  ;; (`notmuch-tag-jump').  For direct actions, refer to the key
  ;; bindings below.
  (setq notmuch-tagging-keys
        `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
          (,(kbd "c") prot-notmuch-mark-complete-tags "Complete and archive")
          (,(kbd "d") prot-notmuch-mark-delete-tags "Mark for deletion")
          (,(kbd "f") prot-notmuch-mark-flag-tags "Flag as important")
          (,(kbd "s") prot-notmuch-mark-spam-tags "Mark as spam")
          (,(kbd "t") prot-notmuch-mark-todo-tags "To-do")
          (,(kbd "x") prot-notmuch-mark-reference-tags "Reference for the future")
          (,(kbd "r") ("-unread") "Mark as read")
          (,(kbd "u") ("+unread") "Mark as unread")))

  (setq prot-notmuch-search-field-width 100)
  (setq notmuch-hello-sections '(prot-notmuch-hello-insert-saved-searches
                                 ;; prot-notmuch-hello-insert-recent-searches
                                 ))

  (add-to-list 'notmuch-tag-formats
               '("encrypted" (propertize tag 'face 'prot-notmuch-encrypted-tag)))
  (add-to-list 'notmuch-tag-formats
               '("sent" (propertize tag 'face 'prot-notmuch-sent-tag)))
  (add-to-list 'notmuch-tag-formats
               '("ref" (propertize tag 'face 'prot-notmuch-ref-tag)))
  (add-to-list 'notmuch-tag-formats
               '("todo" (propertize tag 'face 'prot-notmuch-todo-tag)))
  (add-to-list 'notmuch-tag-formats
               '("spam" (propertize tag 'face 'prot-notmuch-spam-tag)))

  ;; NOTE 2021-05-14: I have an alternative method of finding new mail
  ;; in a maildir tree by using the find command.  It is somewhat
  ;; simplistic, though it worked just fine: see prot-mail.el.  I prefer
  ;; this implementation instead, as it leverages notmuch and so I can
  ;; pass arbitrary search terms to it.
  (setq prot-notmuch-mode-line-count-args "tag:unread and tag:inbox")
  (setq prot-notmuch-mode-line-indicator-commands
        '(notmuch notmuch-refresh-this-buffer))
  ;; Mode line indicator with the number of new mails.
  (prot-notmuch-mail-indicator 1)

  (add-hook 'notmuch-hello-mode-hook #'prot-notmuch-widget-field-face-remap)

  (let ((map notmuch-search-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-search-archive-thread)
    (define-key map (kbd "D") #'prot-notmuch-search-delete-thread)
    (define-key map (kbd "T") #'prot-notmuch-search-todo-thread)
    (define-key map (kbd "X") #'prot-notmuch-search-reference-thread)
    (define-key map (kbd "C") #'prot-notmuch-search-complete-thread)
    (define-key map (kbd "S") #'prot-notmuch-search-spam-thread)
    (define-key map (kbd "g") #'prot-notmuch-refresh-buffer))
  (let ((map notmuch-show-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-show-archive-message-then-next-or-next-thread)
    (define-key map (kbd "D") #'prot-notmuch-show-delete-message)
    (define-key map (kbd "T") #'prot-notmuch-show-todo-message)
    (define-key map (kbd "X") #'prot-notmuch-show-reference-message)
    (define-key map (kbd "C") #'prot-notmuch-show-complete-message)
    (define-key map (kbd "S") #'prot-notmuch-show-spam-message)))
</pre>
</div>

<p>
And here is <code>prot-notmuch.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-notmuch.el --- Tweaks for my notmuch.el configurations -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my tweaks for notmuch.el that are meant for use in my
;; Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)

(defgroup prot-notmuch ()
  "Extensions for notmuch.el."
  :group 'notmuch)

(defcustom prot-notmuch-search-field-width 100 ; Or use something like (/ (frame-width) 2)
  "Number of characters for the width of search files.
Those fields appear in the Notmuch hello buffer.  See
`prot-notmuch-hello-insert-recent-searches'."
  :type 'integer
  :group 'prot-notmuch)

(defcustom prot-notmuch-delete-tag "del"
  "Single tag that applies to mail marked for deletion.
This is used by `prot-notmuch-delete-mail'."
  :type 'string
  :group 'prot-notmuch)

(defcustom prot-notmuch-mark-complete-tags '("+archived" "-inbox" "-list" "-todo" "-ref" "-unread")
  "List of tags to mark as completed."
  :type '(repeat string)
  :group 'prot-notmuch)

(defcustom prot-notmuch-mark-delete-tags '("+del" "-inbox" "-archived" "-unread")
  "List of tags to mark for deletion.
To actually delete email, refer to `prot-notmuch-delete-mail'."
  :type '(repeat string)
  :group 'prot-notmuch)

(defcustom prot-notmuch-mark-flag-tags '("+flag" "-unread")
  "List of tags to mark as important (flagged).
This gets the `notmuch-tag-flagged' face, if that is specified in
`notmuch-tag-formats'."
  :type '(repeat string)
  :group 'prot-notmuch)

(defcustom prot-notmuch-mark-spam-tags '("+spam" "+del" "-inbox" "-unread")
  "List of tags to mark as spam."
  :type '(repeat string)
  :group 'prot-notmuch)

(defcustom prot-notmuch-mark-todo-tags '("+todo" "-unread")
  "List of tags to mark as a to-do item."
  :type '(repeat string)
  :group 'prot-notmuch)

(defcustom prot-notmuch-mark-reference-tags '("+ref" "-unread")
  "List of tags to mark as a reference."
  :type '(repeat string)
  :group 'prot-notmuch)

;;;; Utilities

(defface prot-notmuch-encrypted-tag
  '((default :inherit italic)
    (((class color) (min-colors 88) (background light))
     :foreground "#5d3026")
    (((class color) (min-colors 88) (background dark))
     :foreground "#f8dec0"))
  "Face for the 'encrypted' tag or related in Notmuch.
Refer to the variable `notmuch-tag-formats' for how to assign
those.")

(defface prot-notmuch-sent-tag
  '((default :inherit italic)
    (((class color) (min-colors 88) (background light))
     :foreground "#005e00")
    (((class color) (min-colors 88) (background dark))
     :foreground "#44bc44"))
  "Face for the 'sent' tag or related in Notmuch.
Refer to the variable `notmuch-tag-formats' for how to assign
those.")

(defface prot-notmuch-spam-tag
  '((default :inherit italic)
    (((class color) (min-colors 88) (background light))
     :foreground "#70480f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#c4d030"))
  "Face for the 'spam' tag or related in Notmuch.
Refer to the variable `notmuch-tag-formats' for how to assign
those.")

(defface prot-notmuch-ref-tag
  '((default :inherit italic)
    (((class color) (min-colors 88) (background light))
     :foreground "#005a5f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#6ae4b9"))
  "Face for the 'ref' tag or related in Notmuch.
Refer to the variable `notmuch-tag-formats' for how to assign
those.")

(defface prot-notmuch-todo-tag
  '((default :inherit italic)
    (((class color) (min-colors 88) (background light))
     :foreground "#a60000")
    (((class color) (min-colors 88) (background dark))
     :foreground "#ff8059"))
  "Face for the 'todo' tag or related in Notmuch.
Refer to the variable `notmuch-tag-formats' for how to assign
those.")

(defface prot-notmuch-widget-field
  '((((class color) (min-colors 88) (background light))
     :underline "#d7d7d7")
    (((class color) (min-colors 88) (background dark))
     :underline "#323232")
    (t :underline t))
  "Face for search fields in the Notmuch hello buffer.")

(declare-function message-fetch-field "message")
(declare-function message-remove-header "message")
(declare-function message-add-header "message")
(declare-function message-sort-headers "message")
(declare-function notmuch-fcc-header-setup "notmuch")

;; NOTE 2021-05-18: I used to have something like this when I was using
;; Gnus and thought it would be useful here, but it ultimately isn't.  I
;; just use `notmuch-mua-new-mail'.

;; ;;;###autoload
;; (defun prot-notmuch-message-headers ()
;;   "While `notmuch' is running, configure From header.
;; Add this function to `message-header-setup-hook'."
;;   (when (and (eq mail-user-agent 'notmuch-user-agent)
;;              (eq last-command 'compose-mail))
;;     (when (message-fetch-field "From")
;;       (message-remove-header "From"))
;;     (message-add-header (format "From: %s &lt;%s&gt;" user-full-name user-mail-address))
;;     (notmuch-fcc-header-setup)
;;     (message-sort-headers)))

(defun prot-notmuch-widget-field-face-remap ()
  "Set up extra highlighting for widget fields in Notmuch hello.
Add this to `notmuch-hello-mode-hook'."
  (when (derived-mode-p 'notmuch-hello-mode)
    (face-remap-add-relative 'widget-field 'prot-notmuch-widget-field)))

(defvar notmuch-saved-searches)
(defvar notmuch-show-empty-saved-searches)
(defvar notmuch-search-oldest-first)
(defvar notmuch-saved-search-sort-function)

(declare-function notmuch-hello-query-counts "notmuch")
(declare-function notmuch-saved-search-sort-function "notmuch")
(declare-function notmuch-hello-nice-number "notmuch")
(declare-function notmuch-hello-reflect "notmuch")
(declare-function notmuch-hello-widget-search "notmuch")

;; Simplified variant of what is available in `notmuch-hello.el'.
(defun prot-notmuch-hello-insert-saved-searches ()
  "Single column saved search buttons for Notmuch hello.
Add this to `notmuch-hello-sections'."
  (let ((searches (notmuch-hello-query-counts
		           (if notmuch-saved-search-sort-function
		               (funcall notmuch-saved-search-sort-function
				                notmuch-saved-searches)
		             notmuch-saved-searches)
		           :show-empty-searches notmuch-show-empty-saved-searches))
        (count 0))
    (mapc (lambda (elem)
	        (when elem
	          (let* ((name (plist-get elem :name))
		             (query (plist-get elem :query))
		             (oldest-first (cl-case (plist-get elem :sort-order)
				                     (newest-first nil)
				                     (oldest-first t)
				                     (otherwise notmuch-search-oldest-first)))
		             (search-type (plist-get elem :search-type))
		             (msg-count (plist-get elem :count)))
		        (widget-insert (format "\n%8s "
				                       (notmuch-hello-nice-number msg-count)))
		        (widget-create 'push-button
			                   :notify #'notmuch-hello-widget-search
			                   :notmuch-search-terms query
			                   :notmuch-search-oldest-first oldest-first
			                   :notmuch-search-type search-type
			                   name)))
	        (cl-incf count))
	      (notmuch-hello-reflect searches 1))))
                                               
(defvar notmuch-hello-indent)
(defvar notmuch-search-history)
(defvar notmuch-hello-recent-searches-max)
(declare-function notmuch-hello-search "notmuch")

;; Adapted from `notmuch-hello.el'.
(define-widget 'prot-notmuch-search-item 'item
  "A widget that shows recent search queries."
  :format "%v\n"
  :value-create 'prot-notmuch-search-item-value-create)

;; Adapted from `notmuch-hello.el'.
(defun prot-notmuch-search-item-value-create (widget)
  "Specify value of search WIDGET."
  (let ((value (widget-get widget :value)))
    (widget-insert (make-string notmuch-hello-indent ?\s))
    (widget-create 'editable-field
		   :size (widget-get widget :size)
		   :parent widget
		   :action #'notmuch-hello-search
		   value)))

(defun prot-notmuch--search-width ()
  "Confirm `prot-notmuch-search-field-width' is positive integer."
  (let ((width prot-notmuch-search-field-width))
    (if (prot-common-number-integer-positive-p width)
        width
      (error "Search field width must be a positive integer"))))

;; Adapted from `notmuch-hello.el'.
(defun prot-notmuch-hello-insert-recent-searches ()
  "Insert widget with recent search terms.
Add this to `notmuch-hello-sections'."
  (when notmuch-search-history
    (widget-insert "\n\n")
    (widget-insert "Recent searches: ")
    (widget-insert "\n\n")
    (let ((width (prot-notmuch--search-width)))
      (dolist (search (seq-take notmuch-search-history
				notmuch-hello-recent-searches-max))
	(widget-create 'prot-notmuch-search-item :value search :size width)))))

;;;; Commands

(autoload 'notmuch-interactive-region "notmuch")
(autoload 'notmuch-tag-change-list "notmuch")
(autoload 'notmuch-search-next-thread "notmuch")
(autoload 'notmuch-search-tag "notmuch")

(defmacro prot-notmuch-search-tag-thread (name tags)
  "Produce NAME function parsing TAGS."
  (declare (indent defun))
  `(defun ,name (&amp;optional untag beg end)
     ,(format
       "Mark with `%s' the currently selected thread.

Operate on each message in the currently selected thread.  With
optional BEG and END as points delimiting a region that
encompasses multiple threads, operate on all those messages
instead.

With optional prefix argument (\\[universal-argument]) as UNTAG,
reverse the application of the tags.

This function advances to the next thread when finished."
       tags)
     (interactive (cons current-prefix-arg (notmuch-interactive-region)))
     (when ,tags
       (notmuch-search-tag
        (notmuch-tag-change-list ,tags untag) beg end))
     (when (eq beg end)
       (notmuch-search-next-thread))))

(prot-notmuch-search-tag-thread
  prot-notmuch-search-complete-thread
  prot-notmuch-mark-complete-tags)

(prot-notmuch-search-tag-thread
  prot-notmuch-search-delete-thread
  prot-notmuch-mark-delete-tags)

(prot-notmuch-search-tag-thread
  prot-notmuch-search-flag-thread
  prot-notmuch-mark-flag-tags)

(prot-notmuch-search-tag-thread
  prot-notmuch-search-spam-thread
  prot-notmuch-mark-spam-tags)

(prot-notmuch-search-tag-thread
  prot-notmuch-search-todo-thread
  prot-notmuch-mark-todo-tags)

(prot-notmuch-search-tag-thread
  prot-notmuch-search-reference-thread
  prot-notmuch-mark-reference-tags)

(defmacro prot-notmuch-show-tag-message (name tags)
  "Produce NAME function parsing TAGS."
  (declare (indent defun))
  `(defun ,name (&amp;optional untag)
     ,(format
       "Apply `%s' to message.

With optional prefix argument (\\[universal-argument]) as UNTAG,
reverse the application of the tags."
       tags)
     (interactive "P")
     (when ,tags
       (apply 'notmuch-show-tag-message
	          (notmuch-tag-change-list ,tags untag)))))

(prot-notmuch-show-tag-message
  prot-notmuch-show-complete-message
  prot-notmuch-mark-complete-tags)

(prot-notmuch-show-tag-message
  prot-notmuch-show-delete-message
  prot-notmuch-mark-delete-tags)

(prot-notmuch-show-tag-message
  prot-notmuch-show-flag-message
  prot-notmuch-mark-flag-tags)

(prot-notmuch-show-tag-message
  prot-notmuch-show-spam-message
  prot-notmuch-mark-spam-tags)

(prot-notmuch-show-tag-message
  prot-notmuch-show-todo-message
  prot-notmuch-mark-todo-tags)

(prot-notmuch-show-tag-message
  prot-notmuch-show-reference-message
  prot-notmuch-mark-reference-tags)

(autoload 'notmuch-refresh-this-buffer "notmuch")
(autoload 'notmuch-refresh-all-buffers "notmuch")

(defun prot-notmuch-refresh-buffer (&amp;optional arg)
  "Run `notmuch-refresh-this-buffer'.
With optional prefix ARG (\\[universal-argument]) call
`notmuch-refresh-all-buffers'."
  (interactive "P")
  (if arg
      (notmuch-refresh-all-buffers)
    (notmuch-refresh-this-buffer)))

;;;###autoload
(defun prot-notmuch-delete-mail ()
  "Permanently delete mail marked as `prot-notmuch-delete-mail'.
Prompt for confirmation before carrying out the operation.

Do not attempt to refresh the index.  This will be done upon the
next invocation of 'notmuch new'."
  (interactive)
  (let* ((del-tag prot-notmuch-delete-tag)
         (count
          (string-to-number
           (with-temp-buffer
             (shell-command
              (format "notmuch count tag:%s" prot-notmuch-delete-tag) t)
             (buffer-substring-no-properties (point-min) (1- (point-max))))))
         (mail (if (&gt; count 1) "mails" "mail")))
    (unless (&gt; count 0)
      (user-error "No mail marked as `%s'" del-tag))
    (when (yes-or-no-p
           (format "Delete %d %s marked as `%s'?" count mail del-tag))
      (shell-command
       (format "notmuch search --output=files --format=text0 tag:%s | xargs -r0 rm" del-tag)
       t))))

;;;; Mode line unread indicator

;; NOTE 2021-05-14: I have an alternative to this in prot-mail.el which
;; does not rely on notmuch as it uses find instead.  The following
;; approach is specific to my setup and is what I prefer now.

(defcustom prot-notmuch-mode-line-count-args "tag:unread and tag:inbox"
  "Arguments to pass to 'notmuch count' for counting new mail."
  :type 'string
  :group 'prot-notmuch)

(defcustom prot-notmuch-mode-line-indicator-commands '(notmuch-refresh-this-buffer)
  "List of commands that will be advised to update the mode line.
The advice is designed to run a hook which is used internally by
the function `prot-notmuch-mail-indicator'."
  :type 'list
  :group 'prot-notmuch)

(defface prot-notmuch-mail-count
  '((default :inherit bold)
    (((class color) (min-colors 88) (background light))
     :foreground "#61284f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#fbd6f4")
    (t :foreground "magenta"))
  "Face for mode line indicator that shows a new mail count.")

(defvar prot-notmuch-new-mail-string nil
  "New maildir count number for the mode line.")

(defun prot-notmuch--new-mail ()
  "Search for new mail in personal maildir paths."
  (with-temp-buffer
    (shell-command
     (format "notmuch count %s" prot-notmuch-mode-line-count-args) t)
    (buffer-substring-no-properties (point-min) (1- (point-max)))))

(defun prot-notmuch--mode-string (count)
  "Add properties to COUNT string."
  (when (not (string= count "0"))
    (propertize (format "@%s " count)
                'face 'prot-notmuch-mail-count
                'help-echo "New mails matching `prot-notmuch-mode-line-count-args'")))

(defvar prot-notmuch--mode-line-mail-indicator nil
  "Internal variable used to store the state of new mails.")

(defun prot-notmuch--mode-line-mail-indicator ()
  "Prepare new mail count mode line indicator."
  (let* ((count (prot-notmuch--new-mail))
         (indicator (prot-notmuch--mode-string count))
         (old-indicator prot-notmuch--mode-line-mail-indicator))
    (when old-indicator
      (setq global-mode-string (delete old-indicator global-mode-string)))
    (cond
     ((&gt;= (string-to-number count) 1)
      (setq global-mode-string (push indicator global-mode-string))
      (setq prot-notmuch--mode-line-mail-indicator indicator))
     (t
      (setq prot-notmuch--mode-line-mail-indicator nil)))))

(defvar prot-notmuch--mode-line-mail-sync-hook nil
  "Hook to refresh the mode line for the mail indicator.")

(defun prot-notmuch--add-hook (&amp;rest _)
  "Run `prot-notmuch--mode-line-mail-sync-hook'.
Meant to be used as advice after specified commands that should
update the mode line indicator with the new mail count."
  (run-hooks 'prot-notmuch--mode-line-mail-sync-hook))

;;;###autoload
(define-minor-mode prot-notmuch-mail-indicator
  "Enable mode line indicator with counter for new mail."
  :init-value nil
  :global t
  (if prot-notmuch-mail-indicator
      (progn
        (run-at-time t 60 #'prot-notmuch--mode-line-mail-indicator)
        (when prot-notmuch-mode-line-indicator-commands
          (dolist (fn prot-notmuch-mode-line-indicator-commands)
            (advice-add fn :after #'prot-notmuch--add-hook)))
        (add-hook 'prot-notmuch--mode-line-mail-sync-hook #'prot-notmuch--mode-line-mail-indicator)
        (force-mode-line-update t))
    (cancel-function-timers #'prot-notmuch--mode-line-mail-indicator)
    (setq global-mode-string (delete prot-notmuch--mode-line-mail-indicator global-mode-string))
    (remove-hook 'prot-notmuch--mode-line-mail-sync-hook #'prot-notmuch--mode-line-mail-indicator)
    (when prot-notmuch-mode-line-indicator-commands
      (dolist (fn prot-notmuch-mode-line-indicator-commands)
        (advice-remove fn #'prot-notmuch--add-hook)))
    (force-mode-line-update t)))

(provide 'prot-notmuch)
;;; prot-notmuch.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:79803e19-1150-49a6-a3df-1cffe3d0cbc5" class="outline-5">
<h5 id="h:79803e19-1150-49a6-a3df-1cffe3d0cbc5"><span class="section-number-5">5.10.2.1.</span> .notmuch-config</h5>
<div class="outline-text-5" id="text-h:79803e19-1150-49a6-a3df-1cffe3d0cbc5">
<p>
What follows is my <code>~/.notmuch-config</code>.  The <code>tags=new</code> configuration is
what enables the use of initial tagging, as explained in the upstream
documentation (basically you want to tag some mail right after a
<code>notmuch new</code> such as, for example, to remove mailist list messages from
the inbox&#x2014;see <a href="#h:70d60d41-cb63-4950-bbd9-9157c4d186dc">notmuch post-new rules</a>).
</p>

<p>
The Emacs configs: <a href="#h:a196812e-1644-4536-84ba-687366867def">Notmuch (mail indexer and mail user agent (MUA))</a>.
</p>

<div class="org-src-container">
<pre class="src src-conf"># .notmuch-config - Configuration file for the notmuch mail system
#
# For more information about notmuch, see https://notmuchmail.org

# Database configuration
#
# The only value supported here is 'path' which should be the top-level
# directory where your mail currently exists and to where mail will be
# delivered in the future. Files should be individual email messages.
# Notmuch will store its database within a sub-directory of the path
# configured here named ".notmuch".
#

[database]
path=/home/prot/.mail

# User configuration
#
# Here is where you can let notmuch know how you would like to be
# addressed. Valid settings are
#
#	name		Your full name.
#	primary_email	Your primary email address.
#	other_email	A list (separated by ';') of other email addresses
#			at which you receive email.
#
# Notmuch will use the various email addresses configured here when
# formatting replies. It will avoid including your own addresses in the
# recipient list of replies, and will set the From address based on the
# address to which the original email was addressed.
#

[user]
name=Protesilaos Stavrou
primary_email=public@protesilaos.com
other_email=info@protesilaos.com

# Configuration for "notmuch new"
#
# The following options are supported here:
#
#	tags	A list (separated by ';') of the tags that will be
#		added to all messages incorporated by "notmuch new".
#
#	ignore	A list (separated by ';') of file and directory names
#		that will not be searched for messages by "notmuch new".
#
#		NOTE: *Every* file/directory that goes by one of those
#		names will be ignored, independent of its depth/location
#		in the mail store.
#

[new]
tags=new
ignore=

# Search configuration
#
# The following option is supported here:
#
#	exclude_tags
#		A ;-separated list of tags that will be excluded from
#		search results by default.  Using an excluded tag in a
#		query will override that exclusion.
#

[search]
exclude_tags=del;spam;

# Maildir compatibility configuration
#
# The following option is supported here:
#
#	synchronize_flags      Valid values are true and false.
#
#	If true, then the following maildir flags (in message filenames)
#	will be synchronized with the corresponding notmuch tags:
#
#		Flag	Tag
#		----	-------
#		D	draft
#		F	flagged
#		P	passed
#		R	replied
#		S	unread (added when 'S' flag is not present)
#
#	The "notmuch new" command will notice flag changes in filenames
#	and update tags, while the "notmuch tag" and "notmuch restore"
#	commands will notice tag changes and update flags in filenames
#

[maildir]
synchronize_flags=true
</pre>
</div>
</div>
</div>

<div id="outline-container-h:70d60d41-cb63-4950-bbd9-9157c4d186dc" class="outline-5">
<h5 id="h:70d60d41-cb63-4950-bbd9-9157c4d186dc"><span class="section-number-5">5.10.2.2.</span> notmuch post-new rules</h5>
<div class="outline-text-5" id="text-h:70d60d41-cb63-4950-bbd9-9157c4d186dc">
<p>
And here are the rules that apply after running <code>notmuch new</code>.  Its file
system path is <code>$maildir/.notmuch/hooks/post-new</code> where <code>$maildir</code> is the
database path specified in <code>.notmuch-config</code> (see <a href="#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5">.notmuch-config</a>).
Remember that this file needs to be an executable.
</p>

<p>
The Emacs configs: <a href="#h:a196812e-1644-4536-84ba-687366867def">Notmuch (mail indexer and mail user agent (MUA))</a>.
</p>

<div class="org-src-container">
<pre class="src src-conf">#!/bin/sh

# post-new --- Notmuch rules that run after notmuch new
#
# Copyright (c) 2021  Protesilaos Stavrou &lt;info@protesilaos.com&gt;
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
## Commentary:
#
# The order of those commands matters.  Maybe I will write something
# more sophisticated in the future.
#
# Part of my dotfiles: &lt;https://gitlab.com/protesilaos/dotfiles&gt;.


# remove "unread" from "replied"
notmuch tag -unread -new -- tag:replied

# tag all "new" messages "inbox" and "unread"
notmuch tag +inbox +unread -new -- tag:new

# tag my replies as "sent"
notmuch tag -new -unread +inbox +sent -- '(from:"*@protesilaos.com*" not to:"*@protesilaos.com*" not tag:list)'

# mailing lists
## emacs
notmuch tag -inbox +list +emacs -- from:emacs-devel@gnu.org or to:emacs-devel@gnu.org
notmuch tag -inbox +list +emacs -- from:emacs-orgmode@gnu.org or to:emacs-orgmode@gnu.org
notmuch tag -inbox +list +emacs -- 'to:"/*@debbugs.gnu.org*/"'
notmuch tag -inbox +list +emacs -- from:emacs-humanities@gnu.org or to:emacs-humanities@gnu.org not to:emacs-humanities-owner@gnu.org
notmuch tag -inbox +list +emacs -- 'to:"/*~michel-slm/elpher@lists.sr.ht*/"'

## unix (CLI tools)
notmuch tag -inbox +list +cli -- from:notmuch@notmuchmail.org or to:notmuch@notmuchmail.org

# include mailing lists sent to me into the "inbox"
notmuch tag +inbox -- '(to:"*@protesilaos.com*" tag:list)'
</pre>
</div>
</div>
</div>

<div id="outline-container-h:a7580136-cf32-44e8-81f6-590dbdd7f8f9" class="outline-5">
<h5 id="h:a7580136-cf32-44e8-81f6-590dbdd7f8f9"><span class="section-number-5">5.10.2.3.</span> Org+Notmuch integration (ol-notmuch.el)</h5>
<div class="outline-text-5" id="text-h:a7580136-cf32-44e8-81f6-590dbdd7f8f9">
<p>
The <code>ol-notmuch.el</code> is part of the <code>org-contrib</code> package which can be found
in the NonGNU ELPA (that archive is configured out-of-the-box for
Emacs28, same as with GNU ELPA).  However, that package contains
approximately one zillion things I do not need, so I prefer to copy the
file here and handle it on its own.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; ol-notmuch.el --- Links to notmuch messages

;; Copyright (C) 2010-2014  Matthieu Lemerre

;; Author: Matthieu Lemerre &lt;racin@free.fr&gt;
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: https://orgmode.org

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:

;; This file implements links to notmuch messages and "searches". A
;; search is a query to be performed by notmuch; it is the equivalent
;; to folders in other mail clients. Similarly, mails are referred to
;; by a query, so both a link can refer to several mails.

;; Links have one the following form
;; notmuch:&lt;search terms&gt;
;; notmuch-search:&lt;search terms&gt;.

;; The first form open the queries in notmuch-show mode, whereas the
;; second link open it in notmuch-search mode. Note that queries are
;; performed at the time the link is opened, and the result may be
;; different from when the link was stored.

;;; Code:

(require 'ol)

;; customisable notmuch open functions
(defcustom org-notmuch-open-function
  'org-notmuch-follow-link
  "Function used to follow notmuch links.

Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(defcustom org-notmuch-search-open-function
  'org-notmuch-search-follow-link
  "Function used to follow notmuch-search links.
Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(make-obsolete-variable 'org-notmuch-search-open-function nil "9.3")



;; Install the link type
(org-link-set-parameters "notmuch"
			 :follow #'org-notmuch-open
			 :store #'org-notmuch-store-link)

(defun org-notmuch-store-link ()
  "Store a link to a notmuch search or message."
  (when (memq major-mode '(notmuch-show-mode notmuch-tree-mode))
    (let* ((message-id (notmuch-show-get-message-id t))
	   (subject (notmuch-show-get-subject))
	   (to (notmuch-show-get-to))
	   (from (notmuch-show-get-from))
	   (date (org-trim (notmuch-show-get-date)))
	   desc link)
      (org-link-store-props :type "notmuch" :from from :to to :date date
       			    :subject subject :message-id message-id)
      (setq desc (org-link-email-description))
      (setq link (concat "notmuch:id:" message-id))
      (org-link-add-props :link link :description desc)
      link)))

(defun org-notmuch-open (path _)
  "Follow a notmuch message link specified by PATH."
  (funcall org-notmuch-open-function path))

(defun org-notmuch-follow-link (search)
  "Follow a notmuch link to SEARCH.

Can link to more than one message, if so all matching messages are shown."
  (require 'notmuch)
  (notmuch-show search))



(org-link-set-parameters "notmuch-search"
			 :follow #'org-notmuch-search-open
			 :store #'org-notmuch-search-store-link)

(defun org-notmuch-search-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-search-mode)
    (let ((link (concat "notmuch-search:" notmuch-search-query-string))
	  (desc (concat "Notmuch search: " notmuch-search-query-string)))
      (org-link-store-props :type "notmuch-search"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-search-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-search-follow-link path))

(defun org-notmuch-search-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-search mode."
  (require 'notmuch)
  (notmuch-search search))



(org-link-set-parameters "notmuch-tree"
			 :follow #'org-notmuch-tree-open
			 :store #'org-notmuch-tree-store-link)

(defun org-notmuch-tree-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-tree-mode)
    (let ((link (concat "notmuch-tree:" (notmuch-tree-get-query)))
	  (desc (concat "Notmuch tree: " (notmuch-tree-get-query))))
      (org-link-store-props :type "notmuch-tree"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-tree-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-tree-follow-link path))

(defun org-notmuch-tree-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-tree mode."
  (require 'notmuch)
  (notmuch-tree search))

(provide 'ol-notmuch)

;;; ol-notmuch.el ends here
</pre>
</div>

<p>
And now make the thing work:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(require 'ol-notmuch)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:2d793cf8-83f5-4830-b73d-78385d9b96dd" class="outline-4">
<h4 id="h:2d793cf8-83f5-4830-b73d-78385d9b96dd"><span class="section-number-4">5.10.3.</span> Sending email (SMTP)</h4>
<div class="outline-text-4" id="text-h:2d793cf8-83f5-4830-b73d-78385d9b96dd">
<p>
These are the base settings for the SMTP functionality.  Passwords and
other critical information are stored in <code>~/.authinfo.gpg</code>, as
demonstrated in <a href="#h:a82766be-daab-4925-b23a-1c5ffd47e599">the base email settings</a>.  What follows is just a
mirroring of the contents of that file.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Sending email (SMTP)
(prot-emacs-builtin-package 'smtpmail
  (setq smtpmail-default-smtp-server "mail.gandi.net")
  (setq smtpmail-smtp-server "mail.gandi.net")
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil))

(prot-emacs-builtin-package 'sendmail
  (setq send-mail-function 'smtpmail-send-it))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:d386e14b-dcf7-46a2-851f-867cd84c6cae" class="outline-4">
<h4 id="h:d386e14b-dcf7-46a2-851f-867cd84c6cae"><span class="section-number-4">5.10.4.</span> EBDB (mail contacts)</h4>
<div class="outline-text-4" id="text-h:d386e14b-dcf7-46a2-851f-867cd84c6cae">
<p>
EBDB is a contacts' manager by Eric Abrahamsen that integrates with Mail
User Agents inside of Emacs.  I used to use it as part of my Gnus setup
but as of 2021-05-13 my plan is to make it work with Notmuch as I have
switched to it (<a href="#h:a196812e-1644-4536-84ba-687366867def">Notmuch (mail indexer and mail user agent (MUA))</a>).
</p>

<p>
What I need from it is to perform the task of storing every address that
I exchange messages with.  When I send someone a message, their email
should be saved automatically.  While if I merely read an item, say, on
the emacs-devel mailing list, I prefer to only update existing records
else do nothing.
</p>

<p>
One could set everything to automatically update in all contexts, though
I find that such an approach will either create too many false positives
that will distract you from the immediate task of handling your
correspondence, or they will simply contribute to the creation of a
database that contains a lot of largely useless information.  Save only
what matters&#x2014;ignore the rest.
</p>

<p>
While "ignore the rest" can mean to simply pass it over in silence, EBBD
actually provides a mechanism to permanently exclude individual
addresses or domain names from ever being recorded.  Those are stored in
the file specified by the variable <code>ebdb-permanent-ignores-file</code>: you can
edit it manually, adding one address per line with no attached name or
angled brackets, or a domain name that starts with the <code>@</code> sign.  No
regexp notation is accepted.  For example:
</p>

<pre class="example" id="org4997f4e">
@debbugs.gnu.org
help-debbugs@gnu.org
@reply.github.com
</pre>

<p>
EBDB binds some common commands to the semicolon (<code>;</code>) prefix key inside
Gnus' summary and article buffers.  For example, <code>; :</code> will update all
records that are found in the message at point, while <code>; s</code> will scan
(called "snarf") the body of the message for names and email addresses
in an attempt to create records of any findings.  As always, append <code>C-h</code>
to the prefix key to get help about all key bindings that complete the
sequence and what commands they call.
</p>

<p>
The <code>ebdb-mua-pop-up</code> controls whether a window with relevant contact
information should be displayed automatically.  Perhaps it is good to
have some extra feedback on what we know or what has been collected thus
far, though I prefer not to see anything by default (it can still be
displayed with the various commands under the <code>;</code> prefix key).  Its
informative nature aside, this window can be used to further edit
entries.  With point over a field, type <code>e</code> to edit it or <code>C-k</code> to remove it
(I bind <code>D</code> to delete).  The latter command behaves differently when the
point is before the record's main field, typically the name, where it
will prompt to delete the whole entry altogether.  For more about that
specific major mode and its associated buffers, use <code>C-h m</code> (which invokes
<code>describe-mode</code>).
</p>

<p>
To view all of your contacts, or just those matching a pattern (or
string), use <code>M-x ebdb</code>, which will prompt for a search.  Input an empty
query if you prefer to view everything in the database.  While in the
<code>*EBDB*</code> buffer, you gain access to commands for operating on the records.
Same principle as with the aforementioned <code>ebdb-mua-pop-up</code>: <code>c</code> to create a
new entry, <code>e</code> to edit the field at point, <code>i</code> to insert a new datum to the
current record, <code>C-k</code> (or my preferred <code>D</code>) to delete&#x2026;  Again, <code>C-h m</code> is
your friend.
</p>

<p>
Apart from gathering data and operating on it, EBDB can auto-complete
email addresses in the message composition buffer: hit TAB in a "To:",
"Cc:" or equivalent header and then use the completion framework's
interaction model to retrieve what you want.
</p>

<p>
Finally, note that this package is fairly comprehensive as it defines
lots of options and commands: make sure to read its official manual.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; EBDB (mail contacts)
(prot-emacs-elpa-package 'ebdb
  (require 'ebdb-message)
  (require 'ebdb-notmuch) ; FIXME 2021-05-13: does not activate the corfu-mode UI
  (setq ebdb-sources (locate-user-emacs-file "ebdb"))
  (setq ebdb-permanent-ignores-file (locate-user-emacs-file "ebdb-permanent-ignores"))

  (setq ebdb-mua-pop-up nil)
  (setq ebdb-default-window-size 0.25)
  (setq ebdb-mua-default-formatter ebdb-default-multiline-formatter)

  (setq ebdb-mua-auto-update-p 'existing)
  (setq ebdb-mua-reader-update-p 'existing)
  (setq ebdb-mua-sender-update-p 'create)
  (setq ebdb-message-auto-update-p 'create)

  (setq ebdb-message-try-all-headers t)
  (setq ebdb-message-headers
        '((sender "From" "Resent-From" "Reply-To" "Sender")
          (recipients "Resent-To" "Resent-Cc" "Resent-CC" "To" "Cc" "CC" "Bcc" "BCC")))
  (setq ebdb-message-all-addresses t)

  (setq ebdb-complete-mail 'capf)
  (setq ebdb-mail-avoid-redundancy t)
  (setq ebdb-completion-display-record nil)
  (setq ebdb-complete-mail-allow-cycling nil)

  (setq ebdb-record-self "ace719a4-61f8-4bee-a1ca-2f07e2292305")
  (setq ebdb-user-name-address-re 'self) ; match the above
  (setq ebdb-save-on-exit t)

  (with-eval-after-load 'prot-mail ; check my `prot-mail.el'
    (add-hook 'message-setup-hook #'prot-mail-ebdb-message-setup))

  (let ((map ebdb-mode-map))
    (define-key map (kbd "D") #'ebdb-delete-field-or-record)
    (define-key map (kbd "M") #'ebdb-mail) ; disables `ebdb-mail-each'
    (define-key map (kbd "m") #'ebdb-toggle-record-mark)
    (define-key map (kbd "t") #'ebdb-toggle-all-record-marks)
    (define-key map (kbd "T") #'ebdb-toggle-records-format) ; disables `ebdb-toggle-all-records-format'
    (define-key map (kbd "U") #'ebdb-unmark-all-records)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:4d2f596a-6fc5-4179-a361-c29f77a5ba11" class="outline-3">
<h3 id="h:4d2f596a-6fc5-4179-a361-c29f77a5ba11"><span class="section-number-3">5.11.</span> Rcirc (IRC client)</h3>
<div class="outline-text-3" id="text-h:4d2f596a-6fc5-4179-a361-c29f77a5ba11">
<p>
The first time I used IRC in earnest was at EmacsConf 2021.  The event
lasted two days (I also delivered <a href="https://emacsconf.org/2021/talks/freedom">a presentation</a>).  For the first day I
tried the <code>erc</code> package that is built into Emacs, while for the second I
opted for <code>rcirc</code>, another built-in option.
</p>

<p>
Overall, Rcirc feels more straightforward to me as a regular user.
Whereas ERC seems to have too many options and a larger code base for
technicalities I do not need to know about for the purposes of my casual
usage of IRC.
</p>

<p>
To get started, run <code>M-x irc</code> and confirm your choice at the prompts.  The
defaults for the server and the connection port should be fine.  In my
case, those steps are skipped because of the values specified in the
<code>rcirc-server-alist</code>.  Note the presence of <code>prot-mail-auth-get-field</code>.
This is a function that queries my <code>~/.authinfo.gpg</code> file to retrieve
encrypted information stored there (see <a href="#h:8d0bd754-8a31-431b-b112-f541cc0144ac">Sample of authinfo.gpg</a>).  I use
this method to (i) automate the process of logging in while (ii) not
divulging sensitive data (also see the mega-section on <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">Email settings</a>).
</p>

<p>
IRC is fairly easy to use: you just type your message at the command
prompt and everyone in the channel can see it.  Some things I learnt:
</p>

<ul class="org-ul">
<li>Join a channel like <code>#emacs</code> by typing at the prompt <code>/join #emacs</code>.</li>
<li>Leave a channel with <code>/leave #vim</code> 😉.</li>
<li>To quit IRC do <code>/quit</code>, or optionally <code>/quit Going for a brisk walk</code>.</li>
<li>You can mention another user in the channel just by including their
nick in your message, like <code>Hello protesilaos</code>.  When replying to
someone, do it like this <code>protesilaos: My reply here</code>.</li>
<li>Start a private channel with, say, <code>protesilaos</code> by running the command
<code>/msg protesilaos My message here</code>.  Then use the channel like any
other.</li>
</ul>

<p>
There probably are more commands and other tricks we can employ.  I
expect to familiarise myself with them over time.
</p>

<p>
The following configuration is straightforward and the doc string of
every variable is clear on what it is supposed to do.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(prot-emacs-builtin-package 'rcirc
  (setq rcirc-server-alist
        `(("irc.libera.chat"
           :channels ("#emacs" "#org-mode" "#rcirc")
           :port 6697 :encryption tls
           :password ,(prot-mail-auth-get-field "libera" :secret))))

  (setq rcirc-prompt "%t&gt; ") ; Read the docs or use (customize-set-variable 'rcirc-prompt "%t&gt; ")

  (setq rcirc-default-nick "protesilaos"
        rcirc-default-user-name rcirc-default-nick
        rcirc-default-full-name "Protesilaos Stavrou")

  ;; ;; NOTE 2021-11-28: demo from the days of EmacsConf 2021.  I don't
  ;; ;; actually need this.
  ;; (setq rcirc-bright-nicks '("bandali" "sachac" "zaeph"))

  ;; NOTE 2021-11-28: Is there a canonical way to disable this?
  (setq rcirc-timeout-seconds most-positive-fixnum)

  (rcirc-track-minor-mode 1)

  (define-key global-map (kbd "C-c i") #'irc))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:758afe0d-bc7c-4afc-9c6b-b5e569901591" class="outline-3">
<h3 id="h:758afe0d-bc7c-4afc-9c6b-b5e569901591"><span class="section-number-3">5.12.</span> Bongo music or media manager (and prot-bongo.el)</h3>
<div class="outline-text-3" id="text-h:758afe0d-bc7c-4afc-9c6b-b5e569901591">
<p>
Bongo is a buffer oriented media manager.  It provides an interface to
external players, such as VLC or MPV.  Those are known as "back-ends"
(<code>prot-bongo-enabled-backends</code> sets up my preferred ones).  A "library"
buffer contains the media collection, which consists of music or video
files, or even links to online streams.  While a "playlist" buffer holds
the items that wait in the queue to be played by the back-end program.
We normally use the Library to browse our multimedia collection and to
pick the items we wish to add to the playlist.  In my case, the Library
is just a Dired buffer, so I also benefit from everything this powerful
tool provides (for configurations and commentary, check <a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">Dired (directory
editor, file manager)</a>).
</p>

<p>
I mostly use Bongo for my local Music collection, but also as an
interface to the various video or audio streams I access via their RSS
feed (the latter is done through the integration with Elfeed&#x2014;as such,
consult <a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el</a>).
</p>

<p>
My music directories inside <code>~/Music</code> are, in principle, organised in file
system paths that follow the pattern <code>Artist/Album/Tracks</code>.  Each track
inside of them is named in the style of <code>Artist - Album - Title</code>.  As part
of this collection comes from physical discs, I never bothered writing
metadata for all them and, consequently, do not rely on it to either
play back or organise my files.  The directory structure and its
concomitant naming conventions are sufficient and, in my opinion, more
precise and easier to predict.  My methodology aside, Bongo will read
the media's file name and interpret each hyphen as a field delimiter
that it can then use to better present the information in the playlist
queue.
</p>

<p>
I prefer this manual approach to organising my music collection over all
metadata-centric alternatives.  Reading metadata requires more than just
looking at a plain text name: it is opaque or at least not immediately
obvious.  Besides, how many times have you bought an album that has one
track with a guest author and that one track gets auto-filtered in some
random place because of its unique meta datum for the "artist" field?
So you need to supply a track "artist", then an "album artist" to avoid
the pains of unpredictability&#x2026;  This is the kind of busy work I want
to eschew by organising my files in a way that I understand intuitively.
As for whether Bongo can handle metadata, I do not know.
</p>

<p>
My way of listening to music is straightforward: load up a directory or
directory tree, randomise the playback order, and let it play in the
background.  To ease this workflow, I make my <code>~/Music</code> directory a valid
Bongo library.  As already noted in the introduction, this practically
means that I can access it with <code>dired</code>, while still benefiting from the
Bongo-specific extensions (the technical implementation is handled by my
comprehensive <code>prot-bongo.el</code> library, which is produced after the
following package configurations).
</p>

<p>
Two main uses of the Dired+Bongo combination:
</p>

<dl class="org-dl">
<dt>Enqueue items for immediate playback</dt><dd>Mark some directories or files
the way you always do with Dired, and hit a key to insert them to the
Bongo playlist (the command is <code>prot-bongo-dired-insert</code>).  This will do
a number of things, specifically, (i) enqueue those Dired marks to the
playlist buffer, (ii) perform playback randomisation where
appropriate, (iii) mark this inserted group by bespoke section
delimiters for easier future retrieval, and (iv) start playing an item
unless one is already playing.  When there are no marked items in the
Dired buffer, the file/directory at point will be used instead.</dd>

<dt>Add items to plain playlist files</dt><dd>Add the absolute filesystem path
of marked items (typically directories) to either an existing <i>playlist
file</i> or a new one that is created on demand.  This is done using
minibuffer completion (check <code>prot-bongo-dired-make-playlist-file</code>).
Those files can at any time be inserted in a Bongo <i>playlist buffer</i> to
start playing their contents, following the same conditional patterns
of behaviour described in the previous point (see, in particular,
<code>prot-bongo-playlist-insert-playlist-file</code>).  Put simply, you have a
"rock" <i>playlist file</i> that includes file paths to "~/Music/Scorpions"
and "~/Music/Queen", so inserting that file plays all songs that are
found in those two directories (files are found recursively, so don't
worry if you have multiple albums inside each directory).</dd>
</dl>

<p>
Now a few words about my custom delimiters that the likes of
<code>prot-bongo-dired-insert</code> will add to the Bongo playlist buffer:
</p>

<ul class="org-ul">
<li>The "section delimiters" (<code>prot-bongo-playlist-section-delimiter</code>)
demarcate sets of inserted media.  For example, if you mark three
items in Dired and proceed to enqueue them, then the section delimiter
goes after those three.  Such delimiters provide visual feedback, but
can also be used to either navigate between them and/or remove all of
their contents in one go (with <code>prot-bongo-playlist-kill-section</code>).</li>

<li>Then there is my concept of "headings" that complements those section
delimiters (<code>prot-bongo-playlist-heading-delimiter</code>).  Headings are
comments in the Bongo playlist buffer that contain the name of the
directory or file that includes the tracks directly below them.  Other
than being informative, they function as anchors for navigation
(e.g. with <code>prot-bongo-playlist-heading-next</code>), while they double as
pointers in an <code>M-x imenu</code> index (by virtue of <code>prot-bongo-imenu-setup</code>).
So we can use key bindings to go to the next or previous heading or
employ minibuffer completion to jump directly to the heading of
interest.  The beauty of this is that we can then use the built-in
Imenu, or some of its third-party extensions, to navigate to a heading
using minibuffer completion.  For more on the latter, refer to the
mega-section on <a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>.  It covers everything
about the minibuffer, Consult, Embark, and more.</li>
</ul>

<p>
For the video demo of some of the aforementioned, you may want to watch
the recording on <a href="https://protesilaos.com/codelog/2020-08-06-emacs-bongo-extras/">Bongo media manager and my extras</a> (2020-08-06).  Though
note that it showcases code that is considerably older than what I
currently have with <code>prot-bongo.el</code> (as of 2021-01-18).
</p>

<p>
By default, all the Bongo buffers have a prominent header that provides
some basic information about the program.  As I have no use for that, I
run the function <code>prot-bongo-remove-headers</code>: it takes care of clearing
the buffers while setting them up.  The idea for this is derived from
the <a href="https://github.com/Koekelas/dotfiles/blob/master/emacs.org">Emacs configuration file of Nicolas De Jaeghere</a>.
</p>

<p>
Finally, note that I combine Bongo with Elfeed to keep track of video or
audio streams that I follow.  The code, shared as <code>prot-elfeed-bongo.el</code>,
is included in the section on <a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">Elfeed (RSS/Atom feed reader)</a>.  Thanks to
Madhavan Krishnan who helped me flesh out this project by sharing code
and ideas in a private exchange (disclosed with permission).
</p>

<p>
Also watch: <a href="https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/">Manage podcasts in Emacs with Elfeed and Bongo</a> (2020-09-11),
though please bear in my that my current code is not exactly what was
demonstrated back then (as of 2021-01-18).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Bongo music or media manager (and prot-bongo.el)
(prot-emacs-elpa-package 'bongo
  (setq bongo-default-directory "~/Music/")
  (setq bongo-prefer-library-buffers nil)
  (setq bongo-insert-whole-directory-trees t)
  (setq bongo-logo nil)
  (setq bongo-display-track-icons nil)
  (setq bongo-display-track-lengths nil)
  (setq bongo-display-header-icons nil)
  (setq bongo-display-playback-mode-indicator t)
  (setq bongo-display-inline-playback-progress nil) ; t slows down the playlist buffer
  (setq bongo-join-inserted-tracks nil)
  (setq bongo-field-separator (propertize " · " 'face 'shadow))
  (setq bongo-mark-played-tracks t)
  (setq bongo-vlc-program-name "cvlc")
  (bongo-mode-line-indicator-mode -1)
  (bongo-header-line-mode -1)
  (let ((map global-map))
    (define-key map (kbd "C-c b") #'bongo)
    (define-key map (kbd "&lt;C-XF86AudioPlay&gt;") #'bongo-pause/resume)
    (define-key map (kbd "&lt;C-XF86AudioNext&gt;") #'bongo-next)
    (define-key map (kbd "&lt;C-XF86AudioPrev&gt;") #'bongo-previous)
    (define-key map (kbd "&lt;C-M-XF86AudioPlay&gt;") #'bongo-play-random)
    (define-key map (kbd "&lt;M-XF86AudioPlay&gt;") #'bongo-show)
    (define-key map (kbd "&lt;S-XF86AudioNext&gt;") #'bongo-seek-forward-10)
    (define-key map (kbd "&lt;S-XF86AudioPrev&gt;") #'bongo-seek-backward-10)
    ;; Same as above for the pgtk build of Emacs 29.
    (define-key map (kbd "C-&lt;269025044&gt;") #'bongo-pause/resume)
    (define-key map (kbd "C-&lt;269025047&gt;") #'bongo-next)
    (define-key map (kbd "C-&lt;269025046&gt;") #'bongo-previous)
    (define-key map (kbd "C-M-&lt;269025044&gt;") #'bongo-play-random)
    (define-key map (kbd "M-&lt;269025044&gt;") #'bongo-show)
    (define-key map (kbd "S-&lt;269025047&gt;") #'bongo-seek-forward-10)
    (define-key map (kbd "S-&lt;269025046&gt;") #'bongo-seek-backward-10))
  (let ((map bongo-playlist-mode-map))
    (define-key map (kbd "n") #'bongo-next-object)
    (define-key map (kbd "p") #'bongo-previous-object)
    (define-key map (kbd "R") #'bongo-rename-line)
    (define-key map (kbd "j") #'bongo-dired-line)       ; Jump to dir of file at point
    (define-key map (kbd "J") #'dired-jump)             ; Jump to library buffer
    (define-key map (kbd "I") #'bongo-insert-special)))

(with-eval-after-load 'bongo
  (prot-emacs-builtin-package 'prot-bongo
    (setq prot-bongo-enabled-backends '(mpv vlc))
    (setq prot-bongo-playlist-section-delimiter (make-string 30 ?*))
    (setq prot-bongo-playlist-heading-delimiter "§")
    (setq prot-bongo-playlist-directory
          (concat
           (file-name-as-directory bongo-default-directory)
           (file-name-as-directory "playlists")))
    ;; Those set up a few extras: read each function's doc string.  Pass
    ;; an argument to undo their effects.
    (prot-bongo-enabled-backends)
    (prot-bongo-remove-headers)
    (prot-bongo-imenu-setup)
    (add-hook 'dired-mode-hook #'prot-bongo-dired-library-enable)
    (add-hook 'wdired-mode-hook #'prot-bongo-dired-library-disable)
    (add-hook 'prot-bongo-playlist-change-track-hook #'prot-bongo-playlist-recenter)
    (let ((map bongo-playlist-mode-map))
      (define-key map (kbd "C-c C-n") #'prot-bongo-playlist-heading-next)
      (define-key map (kbd "C-c C-p") #'prot-bongo-playlist-heading-previous)
      (define-key map (kbd "M-n") #'prot-bongo-playlist-section-next)
      (define-key map (kbd "M-p") #'prot-bongo-playlist-section-previous)
      (define-key map (kbd "M-h") #'prot-bongo-playlist-mark-section)
      (define-key map (kbd "M-d") #'prot-bongo-playlist-kill-section)
      (define-key map (kbd "g") #'prot-bongo-playlist-reset)
      (define-key map (kbd "D") #'prot-bongo-playlist-terminate)
      (define-key map (kbd "r") #'prot-bongo-playlist-random-toggle)
      (define-key map (kbd "i") #'prot-bongo-playlist-insert-playlist-file))
    (let ((map bongo-dired-library-mode-map))
      (define-key map (kbd "&lt;C-return&gt;") #'prot-bongo-dired-insert)
      (define-key map (kbd "C-c SPC") #'prot-bongo-dired-insert)
      (define-key map (kbd "C-c +") #'prot-bongo-dired-make-playlist-file))))
</pre>
</div>

<p>
Here is my <code>prot-bongo.el</code> library (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-bongo.el --- Bongo extensions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for Bongo, intended for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

;; XXX Written on 2021-01-18.  Remains to be reviewed.

(eval-when-compile (require 'subr-x))
(eval-when-compile (require 'cl-lib))
(require 'bongo nil t)
(require 'prot-common)

(defgroup prot-bongo ()
  "Personal extensions for Bongo."
  :group 'bongo)

(defcustom prot-bongo-enabled-backends '(mpv vlc)
  "List of enabled backends.
See `bongo-backends' for a list of available backends."
  :type 'list
  :group 'prot-bongo)

(defcustom prot-bongo-playlist-section-delimiter (make-string 30 ?*)
  "Delimiter for inserted groups in Bongo playlist buffers.
It is recommended to set this to a few character length, as it
should be placed on its own line to demacrate groups of enqueued
media."
  :type 'string
  :group 'prot-bongo)

(defcustom prot-bongo-playlist-heading-delimiter "§"
  "Delimiter for custom headings in Bongo playlist buffers.
It is recommended to set this to a single character, as it will
be complemented with the name of the enqueued item."
  :type 'string
  :group 'prot-bongo)

(defvar bongo-default-directory)

(defcustom prot-bongo-playlist-directory
  (concat
   (file-name-as-directory bongo-default-directory)
   (file-name-as-directory "playlists"))
  "Path to playlist files.
Such files are plain text documents that contain a filesystem
path on each line which points to a multimedia item (e.g. a
directory with music files).

Make sure this is a valid path, as we will not make any attempt
at creating it or running any other kind of check."
  :type 'string
  :group 'prot-bongo)

(defcustom prot-bongo-last-inserted-file
  (locate-user-emacs-file "prot-bongo-last-inserted")
  "File to save the last insertion from Dired into the playlist."
  :type 'file
  :group 'prot-bongo)

;;;; Basic setup

(defvar bongo-enabled-backends)

;;;###autoload
(defun prot-bongo-enabled-backends (&amp;optional negation)
  "Assign variable `prot-bongo-enabled-backends' to Bongo.
With optional NEGATION, undo this assignment."
  (if negation
      (progn
        (setq bongo-enabled-backends nil)
        (remove-hook 'bongo-mode-hook #'prot-bongo-enabled-backends))
    (setq bongo-enabled-backends prot-bongo-enabled-backends)
    (add-hook 'bongo-mode-hook #'prot-bongo-enabled-backends)))

;; The original idea for the advice setup to hide the Bongo comment
;; headers comes from the Emacs configuration of Nicolas De Jaeghere:
;; &lt;https://github.com/Koekelas/dotfiles/blob/master/emacs.org&gt;.

(defvar bongo-default-playlist-buffer-name)
(defvar bongo-default-library-buffer-name)
(declare-function bongo-playlist-mode "bongo")
(declare-function bongo-library-mode "bongo")

(defun prot-bongo-playlist-buffer-no-banner ()
  "Set up a Bongo playlist buffer without its header commentary.
To be advised as override for `bongo-default-playlist-buffer'.

To actually enable this, evaluate `prot-bongo-remove-headers'."
  (with-current-buffer (get-buffer-create bongo-default-playlist-buffer-name)
    (unless (derived-mode-p 'bongo-playlist-mode)
      (bongo-playlist-mode))
    (current-buffer)))

(defun prot-bongo-library-buffer-no-banner ()
  "Set up a Bongo library buffer without its header commentary.
To be advised as override for `bongo-default-library-buffer'.

To actually enable this, evaluate `prot-bongo-remove-headers'."
  (with-current-buffer (get-buffer-create bongo-default-library-buffer-name)
    (unless (derived-mode-p 'bongo-library-mode)
      (bongo-library-mode))
    (current-buffer)))

;;;###autoload
(defun prot-bongo-remove-headers (&amp;optional negation)
  "Remove comment headers from Bongo buffers.
With optional NEGATION undo the changes."
  (if negation
      (progn
        (advice-remove 'bongo-default-playlist-buffer #'prot-bongo-playlist-buffer-no-banner)
        (advice-remove 'bongo-default-library-buffer #'prot-bongo-library-buffer-no-banner))
    (advice-add 'bongo-default-playlist-buffer :override #'prot-bongo-playlist-buffer-no-banner)
    (advice-add 'bongo-default-library-buffer :override #'prot-bongo-library-buffer-no-banner)))

;;;; Custom delimiters for headings and sections

(declare-function bongo-insert-comment-text "bongo")

(defun prot-bongo-playlist-heading (title &amp;optional description)
  "Insert `bongo' comment with TITLE and DESCRIPTION.
Use this to add a custom heading for the enqueued media items."
  (bongo-insert-comment-text
   (format "%s %s%s\n"
           prot-bongo-playlist-heading-delimiter
           title
           (if description (concat " " description) ""))))

(defun prot-bongo-playlist-section ()
  "Make `prot-bongo-playlist-section-delimiter' comment."
  (bongo-insert-comment-text
   (format "\n%s\n\n" prot-bongo-playlist-section-delimiter)))

;;;; Motions and actions for custom sections

;; REVIEW: there probably is a better way to parametrise move-buf and
;; move-point so that one key checks for appropriate forward or backward
;; motions, but this is okay right now.
(defmacro prot-bongo-playlist-motion (fn desc rx move-buf move-point)
  "Produce interactive commands to navigate custom bongo delimiters.

FN is the resulting interactive function's name.  DESC is its doc
string.  RX is the regular expression that matches the custom
bongo playlist delimiter (see `prot-bongo-playlist-delimiter' and
`prot-bongo-playlist-heading').

MOVE-BUF is a motion across an arbitrary number of lines.
Currently it assumes (though does test) either
`re-search-forward' or `re-search-backward'.  Likewise,
MOVE-POINT expects `point-at-eol' or `point-at-bol'.  These
motions should go in pairs, in the order they are presented here."
  (declare (indent defun))
  `(defun ,fn ()
     ,desc
     (interactive)
     (let ((section ,rx))
       (when (save-excursion (funcall ,move-buf section nil t))
         (goto-char (funcall ,move-point))
         (funcall ,move-buf section nil t)))))

(prot-bongo-playlist-motion
  prot-bongo-playlist-heading-next
  "Move to next `bongo' playlist custom heading."
  (format "^.*%s.*$" prot-bongo-playlist-heading-delimiter)
  're-search-forward
  'point-at-eol)

(prot-bongo-playlist-motion
  prot-bongo-playlist-heading-previous
  "Move to previous `bongo' playlist custom heading."
  (format "^.*%s.*$" prot-bongo-playlist-heading-delimiter)
  're-search-backward
  'point-at-bol)

(defun prot-bongo--section-delimiter-string ()
  "Format regexp for `prot-bongo-playlist-section-delimiter'."
  (let* ((string prot-bongo-playlist-section-delimiter)
         (char (regexp-quote (substring string 0 1))))
    (format "^%s+$" char)))

(prot-bongo-playlist-motion
  prot-bongo-playlist-section-next
  "Move to next `bongo' playlist custom section delimiter."
  (prot-bongo--section-delimiter-string)
  're-search-forward
  'point-at-eol)

(prot-bongo-playlist-motion
  prot-bongo-playlist-section-previous
  "Move to previous `bongo' playlist custom section delimiter."
  (prot-bongo--section-delimiter-string)
  're-search-backward
  'point-at-bol)

;;;###autoload
(defun prot-bongo-playlist-mark-section ()
  "Mark `bongo' playlist section, delimited by custom markers.
The marker is `prot-bongo-playlist-delimiter'."
  (interactive)
  (let ((section (prot-bongo--section-delimiter-string)))
    (search-forward-regexp section nil t)
    (push-mark nil t)
    (forward-line -1)
    ;; REVIEW any predicate to replace this `save-excursion'?
    (if (save-excursion (re-search-backward section nil t))
        (progn
          (search-backward-regexp section nil t)
          (forward-line 1))
      (goto-char (point-min)))
    (activate-mark)))

(declare-function bongo-kill "bongo")

;;;###autoload
(defun prot-bongo-playlist-kill-section ()
  "Kill `bongo' playlist-section at point.
This operates on a custom delimited section of the buffer.  See
`prot-bongo-playlist-kill-section'."
  (interactive)
  (prot-bongo-playlist-mark-section)
  (bongo-kill))

;;;; Imenu setup for custom sections

(defvar prot-bongo-playlist-setup-hook nil
  "Hook that runs after inserting items to the Bongo playlist.
See, for example, `prot/bongo-playlist-insert-playlist-file' or
`prot/bongo-dired-insert-files'.")

(defun prot-bongo--playlist-imenu-heading ()
  "Return the text of the custom `bongo' playlist heading."
  (let* ((string prot-bongo-playlist-heading-delimiter)
         (char (substring string 0 1)))
    (nth 1
         (split-string
          (buffer-substring-no-properties (point-at-bol) (point-at-eol))
          (concat char " ")))))

;;;###autoload
(defun prot-bongo-imenu-setup (&amp;optional negation)
  "Set up `imenu' bindings for the Bongo playlist buffer.
With optional NEGATION, remove them."
  (if negation
      (progn
        (dolist (local '(imenu-prev-index-position-function
                         imenu-extract-index-name-function))
          (kill-local-variable local))
        (remove-hook 'prot-bongo-playlist-setup-hook #'prot-bongo-imenu-setup))
    (add-hook 'prot-bongo-playlist-setup-hook #'prot-bongo-imenu-setup)
    (setq-local imenu-prev-index-position-function
                'prot-bongo-playlist-heading-previous)
    (setq-local imenu-extract-index-name-function
                'prot-bongo--playlist-imenu-heading)))

;;;; Commands

(defvar bongo-player)
(declare-function with-bongo-playlist-buffer "bongo" (body))
(declare-function bongo-format-infoset "bongo" (infoset))
(declare-function bongo-player-infoset "bongo" (player))

;;;###autoload
(defun prot-bongo-show ()
  "Echo Bongo track without elapsed time format.
This is a simplified variant of `bongo-show'."
  (interactive)
  (let* ((player (with-bongo-playlist-buffer
                   (or bongo-player
                       (error "No currently playing track"))))
         (string (bongo-format-infoset
                  (bongo-player-infoset player))))
      (message "%s" string)))

(declare-function bongo-erase-buffer "bongo")
(declare-function bongo-library-buffer-p "bongo")
(declare-function bongo-play-random "bongo")
(declare-function bongo-playing-p "bongo")
(declare-function bongo-playlist-buffer "bongo")
(declare-function bongo-playlist-buffer-p "bongo")
(declare-function bongo-progressive-playback-mode "bongo")
(declare-function bongo-random-playback-mode "bongo")
(declare-function bongo-recenter "bongo")
(declare-function bongo-reset-playlist "bongo")
(declare-function bongo-stop "bongo")

;;;###autoload
(defun prot-bongo-playlist-play-random ()
  "Play random `bongo' track and determine further conditions."
  (interactive)
  (unless (bongo-playlist-buffer)
    (bongo-playlist-buffer))
  (when (or (bongo-playlist-buffer-p)
            (bongo-library-buffer-p))
    (unless (bongo-playing-p)
      (with-current-buffer (bongo-playlist-buffer)
        (bongo-play-random)
        (bongo-random-playback-mode)
        (bongo-recenter)))))

(defvar bongo-next-action)

;;;###autoload
(defun prot-bongo-playlist-random-toggle ()
  "Toggle `bongo-random-playback-mode' in playlist buffers."
  (interactive)
  (if (eq bongo-next-action 'bongo-play-random-or-stop)
      (bongo-progressive-playback-mode)
    (bongo-random-playback-mode)))

;;;###autoload
(defun prot-bongo-playlist-reset ()
  "Stop playback and reset Bongo playlist.
To reset the playlist is to undo the marks produced by non-nil
`bongo-mark-played-tracks'."
  (interactive)
  (when (bongo-playlist-buffer-p)
    (bongo-stop)
    (bongo-reset-playlist)))

;;;###autoload
(defun prot-bongo-playlist-terminate ()
  "Stop playback and clear the entire `bongo' playlist buffer.
Contrary to the standard `bongo-erase-buffer', this also removes
the currently playing track."
  (interactive)
  (when (bongo-playlist-buffer-p)
    (bongo-stop)
    (bongo-erase-buffer)))

(defvar prot-bongo--playlist-history '()
  "Input history of `prot-bongo-playlist-insert-playlist-file'.")

(defun prot-bongo--playlist-prompt ()
  "Prompt for a file in `prot-bongo-playlist-directory'.
Helper function for `prot-bongo-playlist-insert-playlist-file'."
  (let* ((path prot-bongo-playlist-directory)
         (dotless directory-files-no-dot-files-regexp)
         (playlists (mapc
                     #'abbreviate-file-name
                     (directory-files path nil dotless))))
    (completing-read-multiple
     "Add playlist: " playlists
     #'prot-common-crm-exclude-selected-p
     t nil 'prot-bongo--playlist-history)))

(declare-function bongo-insert-playlist-contents "bongo")

;;;###autoload
(defun prot-bongo-playlist-insert-playlist-file ()
  "Insert contents of playlist file to a `bongo' playlist.
Upon insertion, playback starts immediately, in accordance with
`prot-bongo-play-random'.

The available options at the completion prompt are pre-configured
files that contain absolute filesystem paths of directories or
media items one per line.  Think of them as meta-directories that
mix manually selected media items (yes, I never liked 'smart'
playlists).

To insert multiple playlists complete the first, then type a
character that matches `crm-separator' to complete the second,
and so on.

Also see `prot-bongo-dired-make-playlist-file'."
  (interactive)
  (let ((path prot-bongo-playlist-directory))
    (unless (file-directory-p path)
      (error "'%s' is not an existing directory" path))
    (let ((choice
           (if (bongo-playlist-buffer-p (current-buffer))
               (prot-bongo--playlist-prompt)
             (user-error "Not in a `bongo' playlist buffer"))))
      (mapc (lambda (x)
              (save-excursion
                (goto-char (point-max))
                (prot-bongo-playlist-heading x "playlist file")
                (bongo-insert-playlist-contents
                 (format "%s%s" path x))
                (prot-bongo-playlist-section)))
            choice)
      (prot-bongo-playlist-play-random)
      (run-hooks 'prot-bongo-playlist-setup-hook))))

;;;; Setup for track changing

(defvar prot-bongo-playlist-change-track-hook nil
  "Hook that runs after `bongo' switches to a new track.")

(defun prot-bongo-playlist-run-hook-change-track (&amp;rest _)
  "Run `prot-bongo-playlist-run-hook-change-track'.
This is meant to be loaded after the relevant `bongo' functions
that change tracks, such as `bongo-play-next-or-stop' and
`bongo-play-random-or-stop'."
  (run-hooks 'prot-bongo-playlist-change-track-hook))

(dolist (fn '(bongo-play-next-or-stop bongo-play-random-or-stop))
  (advice-add fn :after #'prot-bongo-playlist-run-hook-change-track))

;;;###autoload
(defun prot-bongo-playlist-recenter ()
  "Recenter `bongo' playlist buffer while in a live window.
Add to `prot-bongo-playlist-change-track-hook'."
  (with-current-buffer (bongo-playlist-buffer)
    (bongo-recenter)))

;;;; Bongo + Dired (bongo library buffer)

(declare-function bongo-dired-library-mode "bongo")
(declare-function bongo-insert-directory-tree "bongo")
(declare-function bongo-insert-file "bongo")
(declare-function bongo-library-buffer "bongo")
(autoload 'dired-get-marked-files "bongo")
(autoload 'dired-next-line "bongo")

(defmacro prot-bongo-dired-library (name doc val)
  "Create Bongo library function NAME with DOC and VAL."
  (declare (indent defun))
  `(defun ,name ()
     ,doc
     (when (string-match-p (file-truename bongo-default-directory)
                           (file-truename default-directory))
       (bongo-dired-library-mode ,val))))

(prot-bongo-dired-library
  prot-bongo-dired-library-enable
  "Set `bongo-dired-library-mode' when accessing ~/Music.

Add this to `dired-mode-hook'.  Upon activation, the directory
and all its sub-directories become a valid library buffer for
Bongo, from where we can, among others, add tracks to playlists.
The added benefit is that Dired will continue to behave as
normal, making this a superior alternative to a purpose-specific
library buffer.

Note, though, that this will interfere with `wdired-mode'.  See
`prot-bongo-dired-library-disable'."
  1)

(prot-bongo-dired-library
  prot-bongo-dired-library-disable
  "Disable `bongo-dired-library-mode' when accessing ~/Music.
This should be added to `wdired-mode-hook'.  For more, refer to
`prot-bongo-dired-library-enable'."
  -1)

(advice-add 'wdired-finish-edit :after #'prot-bongo-dired-library-enable)

(autoload 'dired-x-guess-file-name-at-point "dired-x")

(defvar prot-bongo--dired-last-inserted nil
  "Last input of `prot-bongo-dired-insert'.")

;; FIXME 2021-08-27: Fails when file does not exist.
(defun prot-bongo--save-last-inserted-file ()
  "Save `prot-bongo--dired-last-inserted' to a file.
The file is specified by `prot-bongo-last-inserted-file'."
  (let ((state (delete-dups prot-bongo--dired-last-inserted))
        (file prot-bongo-last-inserted-file))
    (cond
     ((unless state
        (setq prot-bongo--dired-last-inserted
              (delete-dups (prot-common-read-data file)))))
     (t (when file
          (with-temp-file file
            (insert (concat ";; Auto-generated file;"
                            " don't edit -*- mode: lisp-data -*-\n"))
            (pp state (current-buffer))))))))

(defun prot-bongo--dired-insert-files (&amp;optional last-inserted crm)
  "Add files in a `dired' buffer to the `bongo' playlist.
With optional LAST-INSERTED try to add the last list of files or
directories.

With optional CRM use `completing-read-multiple' to select paths
from the history of inserted entries."
  (prot-bongo--save-last-inserted-file)
  (let* ((data prot-bongo--dired-last-inserted)
         (media (cond
                 (crm
                  (completing-read-multiple
                   "Select from recent picks: "
                   (flatten-tree prot-bongo--dired-last-inserted)
                   nil t))
                 ((if (and data last-inserted)
                      (car data)
                    (dired-get-marked-files))))))
    (cl-pushnew media prot-bongo--dired-last-inserted)
    (with-current-buffer (bongo-playlist-buffer)
      (goto-char (point-max))
      (mapc (lambda (x)
              (if (file-directory-p x)
                  (progn
                    (prot-bongo-playlist-heading (file-name-base x))
                    (bongo-insert-directory-tree x))
                (bongo-insert-file x)))
            media)
      (prot-bongo-playlist-section)
      (run-hooks 'prot-bongo-playlist-setup-hook))
    (with-current-buffer (bongo-library-buffer)
      (dired-next-line 1)))
  (prot-bongo--save-last-inserted-file))

;;;###autoload
(defun prot-bongo-dired-insert (&amp;optional arg)
  "Add `dired' item at point or marked ones to Bongo playlist.

The playlist buffer is created, if necessary, while some other
tweaks are introduced.  See `prot-bongo--dired-insert-files' as
well as `prot-bongo-playlist-play-random'.

Meant to work while inside a `dired' buffer that doubles as a
library buffer (see `prot-bongo-dired-library-enable').

With optional prefix ARG (\\[universal-argument]) ignore the file
at point or any marked items and just try to insert what was last
added using this command (see `prot-bongo--dired-last-inserted').
If no record exists for the last choice of this sort, then either
the marked items or the file at point will be selected instead."
  (interactive "P")
  (when (bongo-library-buffer-p)
    (unless (bongo-playlist-buffer-p)
      (bongo-playlist-buffer))
    (pcase (prefix-numeric-value arg)
      (16 (prot-bongo--dired-insert-files t t))
      (4 (prot-bongo--dired-insert-files t))
      (_ (prot-bongo--dired-insert-files)))
    (prot-bongo-playlist-play-random)))

;;;###autoload
(defun prot-bongo-dired-make-playlist-file ()
  "Add `dired' marked items to playlist file using completion.

Files are stored in `prot-bongo-playlist-directory'.  These are
meant to reference filesystem paths: one path per line.  They
ease the task of playing media from closely related directory
trees, without having to interfere with the user's directory
structure (e.g. a playlist file 'rock' can include the paths of
~/Music/Scorpions and ~/Music/Queen).

This works by appending the absolute filesystem path of each item
to the selected playlist file.  If no Dired marked items are
available, the item at point will be used instead.

Selecting a non-existent file at the prompt will create a new
entry whose name matches the minibuffer input.

Also see `prot-bongo-playlist-insert-playlist-file'."
  (interactive)
  (let* ((dotless directory-files-no-dot-files-regexp)
         (pldir prot-bongo-playlist-directory)
         (playlists (mapcar
                     'abbreviate-file-name
                     (directory-files pldir nil dotless)))
         (plname (completing-read "Select playlist: " playlists nil))
         (plfile (concat pldir plname))
         (media-paths
          (if (derived-mode-p 'dired-mode)
              ;; TODO more efficient way to do ensure newline ending?
              ;;
              ;; The issue is that we need to have a newline at the
              ;; end of the file, so that when we append again we
              ;; start on an empty line.
              (concat
               (mapconcat #'identity
                          (dired-get-marked-files)
                          "\n")
               "\n")
            (user-error "Not in a `dired' buffer"))))
    ;; The following `when' just checks for an empty string.  If we
    ;; wanted to make this more robust we should also check for names
    ;; that contain only spaces and/or invalid characters…  This is
    ;; good enough for me.
    (when (string-empty-p plname)
      (user-error "No playlist file has been specified"))
    (unless (file-directory-p pldir)
      (make-directory pldir))
    (unless (and (file-exists-p plfile)
                 (file-readable-p plfile)
                 (not (file-directory-p plfile)))
      (make-empty-file plfile))
    (append-to-file media-paths nil plfile)
    (with-current-buffer (find-file-noselect plfile)
      (delete-duplicate-lines (point-min) (point-max))
      (sort-lines nil (point-min) (point-max))
      (save-buffer)
      (kill-buffer))))

(provide 'prot-bongo)
;;; prot-bongo.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:0cd8ddab-55d1-40df-b3db-1234850792ba" class="outline-3">
<h3 id="h:0cd8ddab-55d1-40df-b3db-1234850792ba"><span class="section-number-3">5.13.</span> Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el</h3>
<div class="outline-text-3" id="text-h:0cd8ddab-55d1-40df-b3db-1234850792ba">
<p>
This is a standalone feed reader by Christopher Wellons that comes with
good defaults and is very well designed overall.  It treats the stream
of updates as a flat list that can be narrowed incrementally using an
efficient tagging system.
</p>

<p>
In terms of feed format specifications, i.e. Atom vs RSS, things should
just work without any kind of configuration from your side (a huge plus
compared to, say, Gnus' <code>nnrss</code> backend that only supports the latter).
</p>

<p>
Elfeed stores feed sources in a single list that associates a valid URL
to one or more tags.  These are then written to a database.  The Elisp
part users should care about looks like this:
</p>

<pre class="example" id="org55ccae3">
(setq elfeed-feeds
      '(("https://www.archlinux.org/feeds/news/" linux distro)
        ("https://planet.emacslife.com/atom.xml" emacs community)
        ("https://www.ecb.europa.eu/rss/press.html" economics eu)
        ("http://feed.pippa.io/public/shows/teamhuman" podcast culture)
        ("https://www.youtube.com/feeds/videos.xml?channel_id=UC0uTPqBCFIpZxlz_Lv1tk_g" personal video)
        ("https://protesilaos.com/codelog.xml" personal)))
</pre>

<p>
I keep the actual list in a GPG-encrypted file (defined in the variable
<code>prot-elfeed-feeds-file</code> which is part of my <code>prot-elfeed.el</code> library that
is reproduced after the following package configurations).  Emacs can
transparently decrypt and read gpg-protected files, making it a great
way to safely store sensitive data while still keeping everything
perfectly functional.
</p>

<p>
A good tagging system for your feeds will offer a strong foundation for
catching up with the news.  I generally use 2-3 tags per feed, while I
make sure that conceptually similar items will share at least one tag.
My tags are not particularly sophisticated, though they are not random
either: for example, I have a particular "EU" entry for all
institutions, bodies, agencies, etc. of the European Union and then I
have other more general ones, such as "politics" and "economics".  So,
in this case, the European Central Bank gets tagged with <code>eu</code>, <code>economics</code>,
while the European Parliament is <code>eu</code>, <code>politics</code>.
</p>

<p>
The user interface consists of two distinct types of buffers:
</p>

<ol class="org-ol">
<li>The <code>*elfeed-search*</code> buffer that holds the list with all the news
items.</li>
<li>The individual item entries.</li>
</ol>

<p>
By default, hitting <code>s</code> (<code>elfeed-search-live-filter</code>) in the search buffer
will place the point inside the minibuffer, where you can then edit the
applicable filters.  The <a href="https://github.com/skeeto/elfeed">Elfeed README</a> offers a detailed explanation of
how to apply such filters.  The ones I use the most:
</p>

<ul class="org-ul">
<li>Prepend a <code>+</code> to the name of a tag to only show items that include that
tag.  With <code>-</code> show items that do not include it.</li>
<li>Type in a regular string with the equals sign in front of it, say
"=TITLE", to show feeds whose name contains it.</li>
</ul>

<p>
Other common cases are regular expressions and date ranges, though I
have found that I never use those.  Probably because the tagging system
is sufficiently powerful for my particular needs.
</p>

<p>
My only inconvenience with <code>elfeed-search-live-filter</code> is that it does not
support completion out-of-the-box.  Instead it expects full user input,
which ins understandable given the types of searches it can conduct.
Since I only need this facility to filter by tag, I rebind <code>s</code> to my
<code>prot-elfeed-search-tag-filter</code>.  While <code>S-s</code> (shift and s) can still be
used to access the original command, whenever we need more precise
control over the search filters.
</p>

<p>
The MPV-related functions require the external <code>mpv</code> program.  They will
play a video in a new app window at a resolution that matches the
current setup's display width or, in the case of an enclosure
(presumably a podcast), play just the audio file without popping up a
new app window.  The process runs in a dedicated buffer, so it can be
terminated by killing the buffer.  In the future I might make this
cleaner, so that it understands input from, e.g., <code>playerctl</code>, though it
is not a priority as the current simplistic design is "good enough" for
my case.
</p>

<p>
For an older, albeit still relevant, demonstration of what I have here,
watch <a href="https://protesilaos.com/codelog/2020-06-09-emacs-elfeed-demo/">my Elfeed video</a> (2020-06-09).
</p>

<p>
As I also am a user of Bongo, and because Emacs lets one handle things
with precision, there are a few functions here that are meant to make
the Elfeed search buffer a bongo-aware media library, from where we can
enqueue online multimedia sources (video links, or podcast enclosures).
The key is to not interfere with the primary Bongo playlist and library
tandem, which is dedicated to my local music collection, but to maintain
a separate playlist which can be controlled independently.  The entirety
of my <code>prot-elfeed-bongo.el</code> is shared after <code>prot-elfeed.el</code> below the
following package configurations (for my other extensions, refer to
<a href="#h:758afe0d-bc7c-4afc-9c6b-b5e569901591">Bongo music or media manager (and prot-bongo.el)</a>).
</p>

<p>
The placement of my custom buffers for Elfeed's multimedia output is
controlled by <code>display-buffer-alist</code> (see <a href="#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957">Window rules and basic tweaks</a>).
</p>

<p>
I benefited in this particular Elfeed+Bongo workflow from an email
exchange I had with Madhavan Krishnan: we shared code and ideas that
helped establish the modalities of interaction between Elfeed and Bongo
(this information is made public with permission).  Video demo with
older code: <a href="https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/">Manage podcasts in Emacs with Elfeed and Bongo</a> (2020-09-11).
</p>

<p>
Also see: <a href="#h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f">Sample configuration for MPV (Elfeed+Bongo extension)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el
(prot-emacs-elpa-package 'elfeed
  (setq elfeed-use-curl t)
  (setq elfeed-curl-max-connections 10)
  (setq elfeed-db-directory (concat user-emacs-directory "elfeed/"))
  (setq elfeed-enclosure-default-dir "~/Downloads/")
  (setq elfeed-search-filter "@4-months-ago +unread")
  (setq elfeed-sort-order 'descending)
  (setq elfeed-search-clipboard-type 'CLIPBOARD)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-title-min-width 30)
  (setq elfeed-search-trailing-width 25)
  (setq elfeed-show-truncate-long-urls t)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-search-date-format '("%F %R" 16 :left))

  ;; Make sure to also check the section on shr and eww for how I handle
  ;; `shr-width' there.
  (add-hook 'elfeed-show-mode-hook
            (lambda () (setq-local shr-width (current-fill-column))))

  (prot-emacs-builtin-package 'prot-elfeed-bongo)

  (define-key global-map (kbd "C-c e") #'elfeed)
  (let ((map elfeed-search-mode-map))
    (define-key map (kbd "w") #'elfeed-search-yank)
    (define-key map (kbd "g") #'elfeed-update)
    (define-key map (kbd "G") #'elfeed-search-update--force)
    (define-key map (kbd "b") #'prot-elfeed-bongo-insert-item)
    (define-key map (kbd "h") #'prot-elfeed-bongo-switch-to-playlist)) ; "hop" mnemonic
  (let ((map elfeed-show-mode-map))
    (define-key map (kbd "w") #'elfeed-show-yank)
    (define-key map (kbd "b") #'prot-elfeed-bongo-insert-item)))

(with-eval-after-load 'elfeed
  (prot-emacs-builtin-package 'prot-elfeed
    (setq prot-elfeed-tag-faces t)
    (prot-elfeed-fontify-tags)
    (add-hook 'elfeed-search-mode-hook #'prot-elfeed-load-feeds)

    (let ((map elfeed-search-mode-map))
      (define-key map (kbd "s") #'prot-elfeed-search-tag-filter)
      (define-key map (kbd "o") #'prot-elfeed-search-open-other-window)
      (define-key map (kbd "q") #'prot-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "v") #'prot-elfeed-mpv-dwim)
      (define-key map (kbd "+") #'prot-elfeed-toggle-tag))
    (let ((map elfeed-show-mode-map))
      (define-key map (kbd "a") #'prot-elfeed-show-archive-entry)
      (define-key map (kbd "e") #'prot-elfeed-show-eww)
      (define-key map (kbd "q") #'prot-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "v") #'prot-elfeed-mpv-dwim)
      (define-key map (kbd "+") #'prot-elfeed-toggle-tag))))
</pre>
</div>

<p>
This is <code>prot-elfeed.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-elfeed.el --- Elfeed extensions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for Elfeed, intended for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile (require 'subr-x))
(require 'elfeed nil t)
(require 'url-util)
(require 'prot-common)

(defgroup prot-elfeed ()
  "Personal extensions for Elfeed."
  :group 'elfeed)

(defcustom prot-elfeed-feeds-file (concat user-emacs-directory "feeds.el.gpg")
  "Path to file with `elfeed-feeds'."
  :type 'string
  :group 'prot-elfeed)

(defcustom prot-elfeed-archives-directory "~/Documents/feeds/"
  "Path to directory for storing Elfeed entries."
  :type 'string
  :group 'prot-elfeed)

(defcustom prot-elfeed-tag-faces nil
  "Add faces for certain tags.
The tags are: critical, important, personal."
  :type 'boolean
  :group 'prot-elfeed)

(defcustom prot-elfeed-laptop-resolution-breakpoint 1366
  "Determine video resolution based on this display width.
This is used to check whether I am on the laptop or whether an
external display is attached to it.  In the latter case, a
`prot-elfeed-video-resolution-large' video resolution will be
used, else `prot-elfeed-video-resolution-small'."
  :type 'integer
  :group 'prot-elfeed)

(defcustom prot-elfeed-video-resolution-small 720
  "Set video resolution width for smaller displays."
  :type 'integer
  :group 'prot-elfeed)

(defcustom prot-elfeed-video-resolution-large 1080
  "Set video resolution width for larger displays."
  :type 'integer
  :group 'prot-elfeed)

(defcustom prot-elfeed-search-tags '(critical important personal)
  "List of user-defined tags.
Used by `prot-elfeed-toggle-tag'."
  :type 'list
  :group 'prot-elfeed)

(defface prot-elfeed-entry-critical
  '((((class color) (min-colors 88) (background light))
     :inherit elfeed-search-title-face :foreground "#a60000")
    (((class color) (min-colors 88) (background dark))
     :inherit elfeed-search-title-face :foreground "#ff8059")
    (t :foreground "red"))
  "Face for Elfeed entries tagged with 'critical'.")

(defface prot-elfeed-entry-important
  '((((class color) (min-colors 88) (background light))
     :inherit elfeed-search-title-face :foreground "#813e00")
    (((class color) (min-colors 88) (background dark))
     :inherit elfeed-search-title-face :foreground "#f0ce43")
    (t :foreground "yellow"))
  "Face for Elfeed entries tagged with 'important'.")

(defface prot-elfeed-entry-personal
    '((((class color) (min-colors 88) (background light))
     :inherit elfeed-search-title-face :foreground "#0031a9")
    (((class color) (min-colors 88) (background dark))
     :inherit elfeed-search-title-face :foreground "#2fafff")
    (t :foreground "blue"))
  "Face for Elfeed entries tagged with 'personal'.")

;;;; Utilities

;;;###autoload
(defun prot-elfeed-load-feeds ()
  "Load file containing the `elfeed-feeds' list.
Add this to `elfeed-search-mode-hook'."
  (let ((feeds prot-elfeed-feeds-file))
    (if (file-exists-p feeds)
        (load-file feeds)
      (user-error "Missing feeds' file"))))

(defvar elfeed-search-face-alist)

;;;###autoload
(defun prot-elfeed-fontify-tags ()
  "Expand Elfeed faces if `prot-elfeed-tag-faces' is non-nil."
  (if prot-elfeed-tag-faces
      (setq elfeed-search-face-alist
            '((critical prot-elfeed-entry-critical)
              (important prot-elfeed-entry-important)
              (personal prot-elfeed-entry-personal)
              (unread elfeed-search-unread-title-face)))
    (setq elfeed-search-face-alist
          '((unread elfeed-search-unread-title-face)))))

(defvar prot-elfeed--tag-hist '()
  "History of inputs for `prot-elfeed-toggle-tag'.")

(defun prot-elfeed--character-prompt (tags)
  "Helper of `prot-elfeed-toggle-tag' to read TAGS."
  (let ((def (car prot-elfeed--tag-hist)))
    (completing-read
     (format "Toggle tag [%s]: " def)
     tags nil t nil 'prot-elfeed--tag-hist def)))

(defvar elfeed-show-entry)
(declare-function elfeed-tagged-p "elfeed")
(declare-function elfeed-search-toggle-all "elfeed")
(declare-function elfeed-show-tag "elfeed")
(declare-function elfeed-show-untag "elfeed")

;;;###autoload
(defun prot-elfeed-toggle-tag (tag)
  "Toggle TAG for the current item.

When the region is active in the `elfeed-search-mode' buffer, all
entries encompassed by it are affected.  Otherwise the item at
point is the target.  For `elfeed-show-mode', the current entry
is always the target.

The list of tags is provided by `prot-elfeed-search-tags'."
  (interactive
   (list
    (intern
     (prot-elfeed--character-prompt prot-elfeed-search-tags))))
  (if (derived-mode-p 'elfeed-show-mode)
      (if (elfeed-tagged-p tag elfeed-show-entry)
          (elfeed-show-untag tag)
        (elfeed-show-tag tag))
    (elfeed-search-toggle-all tag)))

(defvar elfeed-show-truncate-long-urls)
(declare-function elfeed-entry-title "elfeed")
(declare-function elfeed-show-refresh "elfeed")

;;;###autoload
(defun prot-elfeed-show-archive-entry ()
  "Store a plain text copy of the current `elfeed' entry.

The destination is defined in `prot-elfeed-archives-directory'
and will be created if it does not exist."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (title (replace-regexp-in-string " " "-" (elfeed-entry-title entry)))
         (elfeed-show-truncate-long-urls nil)
         (archives (file-name-as-directory prot-elfeed-archives-directory))
         (file (format "%s%s.txt" archives title)))
    (unless (file-exists-p archives)
      (make-directory archives t))
    (when (derived-mode-p 'elfeed-show-mode)
      ;; Refresh to expand truncated URLs
      (elfeed-show-refresh)
      (write-file file t)
      (message "Saved buffer at %s" file))))

;;;; General commands

;; NOTE 2021-10-15: This is a prototype of a "privay redirect" feature.
;; It should eventually find its way into prot-eww.el.
(defvar elfeed-show-entry)
(declare-function elfeed-search-selected "elfeed")
(declare-function elfeed-entry-link "elfeed")

(defcustom prot-elfeed-privacy-redirect-alist
  '(("www.reddit.com" . "libredd.it")
    ("www.youtube.com" . "yewtu.be")
    ;; Some sites block the proxy sites (e.g., Instagram) if they make
    ;; too many requests. In those cases a user may want to specify
    ;; something like this:
    ("www.instagram.com" . (lambda ()
                             (let ((sequence '("bibliogram.snopyta.org"
                                               "bibliogram.org"
                                               "insta.trom.tf")))
                               (seq-elt sequence (random (length sequence)))))))
  "Alist of sites and their privacy-respecting alternatives.
Alist KEY must be string.  VALUE can either be a string or a
thunk (function with no arguments) that returns a string."
  :type 'alist
  :group 'prot-elfeed)

;;;###autoload
(defun prot-elfeed-show-eww (&amp;optional link)
  "Browse current entry's link or optional LINK in `eww'.
Only show the readable part once the website loads.  This can
fail on poorly-designed websites."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (or link (elfeed-entry-link entry)))
         (parsed-url (url-generic-parse-url link))
         (replacement (alist-get (url-host parsed-url)
                                 prot-elfeed-privacy-redirect-alist
                                 nil
                                 nil
                                 #'equal)))
    (if replacement
        (progn
          (setq replacement (if (functionp replacement)
                                (funcall replacement)
                              replacement))
          (setf (url-host parsed-url) replacement)
          (eww (url-recreate-url parsed-url)))
      (eww link))
    (add-hook 'eww-after-render-hook 'eww-readable nil t)))

(declare-function elfeed-search-untag-all-unread "elfeed")
(declare-function elfeed-search-show-entry "elfeed")

;;;###autoload
(defun prot-elfeed-search-open-other-window (&amp;optional arg)
  "Browse `elfeed' entry in the other window.
With optional prefix ARG (\\[universal-argument]) browse the
entry in `eww' using the `prot-elfeed-show-eww' wrapper."
  (interactive "P")
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (elfeed-entry-link entry))
         (win (selected-window)))
    (with-current-buffer (get-buffer "*elfeed-search*")
      (unless (one-window-p)              ; experimental
        (delete-other-windows win))
      (split-window win (/ (frame-height) 5) 'below)
      (other-window 1)
      (if arg
          (progn
            (when (eq major-mode 'elfeed-search-mode)
              (elfeed-search-untag-all-unread))
            (prot-elfeed-show-eww link))
        (elfeed-search-show-entry entry)))))

(declare-function elfeed-kill-buffer "elfeed")
(declare-function elfeed-search-quit-window "elfeed")

;;;###autoload
(defun prot-elfeed-kill-buffer-close-window-dwim ()
  "Do-what-I-mean way to handle `elfeed' windows and buffers.

When in an entry buffer, kill the buffer and return to the Elfeed
Search view.  If the entry is in its own window, delete it as
well.

When in the search view, close all other windows.  Else just kill
the buffer."
  (interactive)
  (let ((win (selected-window)))
    (cond ((eq major-mode 'elfeed-show-mode)
           (elfeed-kill-buffer)
           (unless (one-window-p) (delete-window win))
           (switch-to-buffer "*elfeed-search*"))
          ((eq major-mode 'elfeed-search-mode)
           (if (one-window-p)
               (elfeed-search-quit-window)
             (delete-other-windows win))))))

(defvar elfeed-search-filter-active)
(defvar elfeed-search-filter)
(declare-function elfeed-db-get-all-tags "elfeed")
(declare-function elfeed-search-update "elfeed")
(declare-function elfeed-search-clear-filter "elfeed")

;;;###autoload
(defun prot-elfeed-search-tag-filter ()
  "Filter Elfeed search buffer by tags using completion.

Completion accepts multiple inputs, delimited by `crm-separator'.
Arbitrary input is also possible, but you may have to exit the
minibuffer with something like `exit-minibuffer'."
  (interactive)
  (unwind-protect
      (elfeed-search-clear-filter)
    (let* ((elfeed-search-filter-active :live)
           (db-tags (elfeed-db-get-all-tags))
           (plus-tags (mapcar (lambda (tag)
                                (format "+%s" tag))
                              db-tags))
           (minus-tags (mapcar (lambda (tag)
                                 (format "-%s" tag))
                               db-tags))
           (all-tags (delete-dups (append plus-tags minus-tags)))
           (tags (completing-read-multiple
                  "Apply one or more tags: "
                  all-tags #'prot-common-crm-exclude-selected-p t))
           (input (string-join `(,elfeed-search-filter ,@tags) " ")))
      (setq elfeed-search-filter input))
    (elfeed-search-update :force)))

;;;; Elfeed multimedia extras

(defvar prot-elfeed-mpv-buffer-name "*prot-elfeed-mpv-output*"
  "Name of buffer holding Elfeed MPV output.")

(defun prot-elfeed--video-resolution ()
  "Determine display resolution.
This checks `prot-elfeed-laptop-resolution-breakpoint'."
  (if (&lt;= (display-pixel-width) prot-elfeed-laptop-resolution-breakpoint)
      prot-elfeed-video-resolution-small
    prot-elfeed-video-resolution-large))

(defun prot-elfeed--get-mpv-buffer ()
  "Prepare `prot-elfeed-mpv-buffer-name' buffer."
  (let ((buf (get-buffer prot-elfeed-mpv-buffer-name))
        (inhibit-read-only t))
    (with-current-buffer buf
      (erase-buffer))))

(declare-function elfeed-entry-enclosures "elfeed")

;;;###autoload
(defun prot-elfeed-mpv-dwim ()
  "Play entry link with the external MPV program.
When there is an audio enclosure (assumed to be a podcast), play
just the audio.  Else spawn a video player at a resolution that
accounts for the current monitor's width."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (elfeed-entry-link entry))
         (enclosure (elt (car (elfeed-entry-enclosures entry)) 0)) ; fragile?
         (audio "--no-video")
         ;; Here the display width checks if I am on the laptop
         (height (prot-elfeed--video-resolution))
         (video                       ; this assumes mpv+youtube-dl
          (format "--ytdl-format=bestvideo[height\\&lt;=?%s]+bestaudio/best" height))
         (buf (pop-to-buffer prot-elfeed-mpv-buffer-name)))
    (prot-elfeed--get-mpv-buffer)
    (if enclosure
        (progn
          (async-shell-command (format "mpv %s %s" audio enclosure) buf)
          (message "Launching MPV for %s" enclosure))
      (async-shell-command (format "mpv %s %s" video link) buf)
      (message "Launching MPV for %s" link))))

(provide 'prot-elfeed)
;;; prot-elfeed.el ends here
</pre>
</div>

<p>
And here is <code>prot-elfeed-bongo.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-elfeed-bongo.el --- Bongo+Elfeed integration for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for integrating Elfeed with Bongo, intended for use in my
;; Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

;; XXX Written on 2021-01-18.  Remains to be reviewed.

(eval-when-compile (require 'subr-x))
(require 'bongo nil t)
(require 'elfeed nil t)

(defgroup prot-elfeed-bongo ()
  "Personal extensions for Bongo."
  :group 'bongo)

(defcustom prot-elfeed-bongo-playlist "*prot-elfeed-bongo-queue*"
  "Name of the Elfeed+Bongo multimedia playlist."
  :type 'string
  :group 'prot-elfeed-bongo)

(autoload 'bongo-insert-comment-text "bongo")
(autoload 'bongo-insert-uri "bongo")
(autoload 'bongo-playlist-buffer "bongo")
(autoload 'bongo-playlist-buffer-p "bongo")
(autoload 'bongo-playlist-mode "bongo")
(autoload 'bongo-progressive-playback-mode "bongo")
(autoload 'bongo-recenter "bongo")
(autoload 'elfeed-entry-enclosures "elfeed")
(autoload 'elfeed-entry-link "elfeed")
(autoload 'elfeed-entry-title "elfeed")
(autoload 'elfeed-search-selected "elfeed")
(defvar elfeed-show-entry)

;;;###autoload
(defun prot-elfeed-bongo-insert-item ()
  "Insert `elfeed' multimedia links in `bongo' playlist buffer.

The playlist buffer has a unique name so that it will never
interfere with the default variable `bongo-playlist-buffer'."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (elfeed-entry-link entry))
         (enclosure (elt (car (elfeed-entry-enclosures entry)) 0))
         (url (or enclosure link))
         (title (elfeed-entry-title entry))
         (bongo-pl prot-elfeed-bongo-playlist)
         (buffer (get-buffer-create bongo-pl)))
    (unless (bongo-playlist-buffer)
      (bongo-playlist-buffer))
    (display-buffer buffer)
    (with-current-buffer buffer
 	  (when (not (bongo-playlist-buffer-p))
 	    (bongo-playlist-mode)
        (setq-local bongo-library-buffer (get-buffer "*elfeed-search*"))
        (setq-local bongo-enabled-backends '(vlc mpv))
        (bongo-progressive-playback-mode))
 	  (goto-char (point-max))
      (bongo-insert-uri url title)
      (bongo-insert-comment-text (format "     ==&gt; %s\n" url))
      (let ((inhibit-read-only t))
        (delete-duplicate-lines (point-min) (point-max)))
      (bongo-recenter))
    (message "Enqueued %s “%s” in %s"
             (if enclosure "podcast" "video")
             (propertize title 'face 'italic)
             (propertize bongo-pl 'face 'bold))))

(defun prot-elfeed-bongo-switch-to-playlist ()
  "Switch to `prot-elfeed-bongo-playlist'."
  (interactive)
  (let* ((bongo-pl prot-elfeed-bongo-playlist)
         (buffer (get-buffer bongo-pl)))
    (if buffer
        (switch-to-buffer buffer)
      (message "No `bongo' playlist is associated with `elfeed'."))))

(provide 'prot-elfeed-bongo)
;;; prot-elfeed-bongo.el ends here
</pre>
</div>
</div>

<div id="outline-container-h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f" class="outline-4">
<h4 id="h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f"><span class="section-number-4">5.13.1.</span> Sample configuration for MPV (Elfeed+Bongo extension)</h4>
<div class="outline-text-4" id="text-h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f">
<p>
In the previous section I configure Elfeed to integrate with the Bongo
media manager.  The external <code>mpv</code> executable is used to play back audio
and video links.  Instead of passing command-line arguments to control
the settings of the player, I just add the following to my local
configuration files, specifically <code>~/.config/mpv/mpv.conf</code>:
</p>

<pre class="example" id="orgc636e1b">
hwdec=auto-safe
ytdl-format="bestvideo[height&lt;=?1080]+bestaudio/best"
</pre>
</div>
</div>
</div>

<div id="outline-container-h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325" class="outline-3">
<h3 id="h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325"><span class="section-number-3">5.14.</span> Proced (process monitor, similar to `top')</h3>
<div class="outline-text-3" id="text-h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325">
<p>
This is a built-in tool that allows you to monitor running processes
and act on them accordingly.  These are the basic settings I have
right now: it works fine.
</p>

<p>
My <code>prot-proced.el</code> (reproduced after the package configurations) simply
adds some extra colours to the otherwise plain buffer.  Makes it easier
to keep track of the information on display.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Proced (process monitor, similar to `top')
(prot-emacs-builtin-package 'proced
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 5)
  (setq proced-descend t)
  (setq proced-filter 'user))

(prot-emacs-builtin-package 'prot-proced
  (prot-proced-extra-keywords 1))
</pre>
</div>

<p>
Here is <code>prot-proced.el</code> (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-proced.el --- Extras for proced -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extras for `proced', intended for use in my Emacs setup:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-proced ()
  "Proced extras for my dotemacs."
  :group 'proced)

;;;; Extend `proced' faces

(defface prot-proced-user '((t :inherit shadow))
  "Face for user indicator in `proced'.")

(defface prot-proced-pid
  '((((class color) (min-colors 88) (background light))
     :foreground "#5317ac")
    (((class color) (min-colors 88) (background dark))
     :foreground "#b6a0ff"))
  "Face for PID indicator in `proced'.")

(defface prot-proced-cpu
  '((((class color) (min-colors 88) (background light))
     :foreground "#8f0075")
    (((class color) (min-colors 88) (background dark))
     :foreground "#f78fe7"))
  "Face for memory indicator in `proced'.")

(defface prot-proced-mem
  '((((class color) (min-colors 88) (background light))
     :foreground "#0031a9")
    (((class color) (min-colors 88) (background dark))
     :foreground "#2fafff"))
  "Face for CPU indicator in `proced'.")

(defface prot-proced-time-start
  '((((class color) (min-colors 88) (background light))
     :foreground "#30517f")
    (((class color) (min-colors 88) (background dark))
     :foreground "#a0bfdf"))
  "Face for start time indicator in `proced'.")

(defface prot-proced-time-duration
  '((((class color) (min-colors 88) (background light))
     :foreground "#00538b")
    (((class color) (min-colors 88) (background dark))
     :foreground "#00cdc8"))
  "Face for time indicator in `proced'.")

(defface prot-proced-process nil
  "Face for process indicator in `proced'.")

(defconst prot-proced-keywords
  `((,(concat "^\s+\\(.*?\\)\s+\\(.*?\\)\s+\\(.*?\\)\s+\\(.*?\\)\s+"
             "\\(.*?\\)\s+\\(.*?\\)\s+\\(.*\\)")
     (1 'prot-proced-user)
     (2 'prot-proced-pid)
     (3 'prot-proced-cpu)
     (4 'prot-proced-mem)
     (5 'prot-proced-time-start)
     (6 'prot-proced-time-duration)
     (7 'prot-proced-process)))
  "Extra font-lock patterns for the `proced' menu.")

;;;###autoload
(define-minor-mode prot-proced-extra-keywords
  "Apply extra font-lock rules to diff buffers."
  :init-value nil
  :global t
  (if prot-proced-extra-keywords
      (progn
        (font-lock-flush (point-min) (point-max))
        (font-lock-add-keywords nil prot-proced-keywords nil)
        (add-hook 'proced-mode-hook #'prot-proced-extra-keywords))
    (font-lock-remove-keywords nil prot-proced-keywords)
    (remove-hook 'proced-mode-hook #'prot-proced-extra-keywords)
    (font-lock-flush (point-min) (point-max))))

(provide 'prot-proced)
;;; prot-proced.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78" class="outline-3">
<h3 id="h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78"><span class="section-number-3">5.15.</span> Pass interface (password-store)</h3>
<div class="outline-text-3" id="text-h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78">
<p>
The external <code>pass</code> program, aka "password-store", is a password manager
that uses GPG and standard UNIX tools to handle passwords.  Encrypted
files are stored in a plain directory structure.  Very simple, very
nice: now all data is available with a variety of interfaces, such as
standard CLI, a <code>dmenu</code> interface, a graphical front-end like <code>qtpass</code>, etc.
</p>

<p>
The package below provides an Emacs interface to some of the most common
actions, in the form of a list of candidates that can be narrowed down
using completion methods (study <a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>).  I use
it to quickly store a password to the kill ring.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Pass interface (password-store)
(prot-emacs-elpa-package 'password-store
  (setq password-store-time-before-clipboard-restore 30)
  ;; Mnemonic is the root of the "code" word (κώδικας).  But also to add
  ;; the password to the kill-ring.  Other options are already taken.
  (define-key global-map (kbd "C-c k") #'password-store-copy))
</pre>
</div>

<p>
And this one adds a major mode for browsing the <code>pass</code> keychain.  Call
it with <code>M-x pass</code>.  There is a helpful section at the top with key
bindings and their functions.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(prot-emacs-elpa-package 'pass)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:524bc702-ff55-4ed9-9a38-26d30d64591d" class="outline-3">
<h3 id="h:524bc702-ff55-4ed9-9a38-26d30d64591d"><span class="section-number-3">5.16.</span> Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el</h3>
<div class="outline-text-3" id="text-h:524bc702-ff55-4ed9-9a38-26d30d64591d">
<p>
TODO 2021-09-08: This section needs to be expanded to cover the
integration with the built-in <code>bookmark.el</code> framework as well as the
third-party <code>elpher</code> package (Elpher is an Internet browser for the Gopher
and Gemini protocols).
</p>


<p>
The following code block encompasses libraries that power Emacs' web
browsing experience.
</p>

<ul class="org-ul">
<li><code>browse-url</code> determines what Emacs should do when the user follows a
link to the Internet.  For my purposes, I configure it to open the web
page inside of Emacs, while I let the Desktop Environment's default
graphical browser be declared as a secondary option.  Put simply, when
I click on a URL, I go to an EWW or Elpher buffer.  If the page is
part of the World Wide Web (<code>https?</code> protocol) I can opt to open it in
the GUI browser via <code>eww-browse-with-external-browser</code>, which is bound
to <code>&amp;</code> in <code>eww-mode-map</code>.  That is only ever needed for websites that do
not work well in a text-centric interface.  For pages that implement
the Gopher or Gemini protocols, there is no need whatsoever to open
them externally as they are plain text anyway.</li>

<li><code>shr</code> is the "Simple HTML Renderer", which basically means to interpret
the underlying code of a web page and show it in the way it is
intended for the end user.  Unlike graphical web browsers, <code>shr</code>
capabilities are limited, because it does not use style sheets (CSS)
and more demanding resources (javascript, embedded multimedia, etc.).</li>

<li><code>eww</code> is what we use to browse the Web.  It effectively is the front-end
to <code>shr</code>, adding on top of it the layer of interactivity that is
expected of a basic browser, such as to keep a history of visited
pages, handle bookmarks, navigate through links, and the like.  As
always, remember to read the manual of EWW, such as by evaluating this
form: <code>(info "(eww) Top")</code>.  It is short and should give you an idea of
what its features are.</li>

<li><code>prot-eww</code> adds commands that align EWW with my expectations and make it
do what I want to achieve in a primarily text-based web browsing
experience.  It also provides the layer of integration between EWW and
Elpher, making the resulting browsing experience consistent as one
follows links that are implemented in the relevant protocols.</li>
</ul>

<p>
My configurations for <code>browse-url</code> and <code>shr</code> are straightforward and are
meant to keep things simple.  I want EWW to behave like the rest of
Emacs, which means that it should not try to introduce random colours
from web pages, nor use its own fonts.  Both intefere with the
consistency I seek in my computing environment (and why I use Emacs to
begin with).
</p>

<p>
For <code>eww</code>, I repurpose some of its key bindings that I never plan to use,
such as the toggle for proportional fonts, while I move around a few
others.  Just to make things easier for me.
</p>

<p>
As for <code>prot-eww</code>, it includes functionality that makes EWW good enough
for my day-to-day needs.
</p>

<p>
In particular:
</p>

<ul class="org-ul">
<li>It includes an unconditional internal mechanism that renames EWW
buffers based on the rendered web page's title or, when that is not
available, the URL.  This ensures that I can maintain multiple buffers
without getting lost in the noise of what would otherwise be an
awkward naming scheme in the form of <code>*eww*</code>, <code>*eww&lt;2&gt;*</code> and so on.  Now
it looks like <code>*Emacs - ArchWiki # eww*</code>, with a possible number
identifier added only for duplicate entries.</li>

<li>The variable <code>prot-eww-visited-history</code> records the URL of every
rendered page.  This is then used by <code>prot-eww-browse-dwim</code> (more
below).  To keep things in check, <code>prot-eww-visited-history</code> is
implemented as a minibuffer history which is ultimately limited to the
value of <code>history-length</code> (read: <a href="#h:2733674b-51f9-494e-b34d-e8842ac4ef96">Minibuffer history (savehist-mode)</a>).
Remember that each command can have its own history and this is common
in a lot of my extras.</li>

<li>The <code>prot-eww-browse-dwim</code> is my main point of entry to EWW.  When I
call it from a random place inside of Emacs, it just offers a prompt
that asks for a URL or search terms with which to query DuckDuckGo.
In addition, it reads through a history of such inputs, so that <code>M-p</code>,
<code>M-n</code> can quickly give me something I tried before.  Plus it supports
completion (check the mega-section <a href="#h:98d3abcc-f34e-4029-aabc-740f0b6421f8">Completion framework and extras</a>).
When this command is called from inside an EWW buffer it retains the
aforementioned functionality, but its prompt is pre-populated with the
URL of the current page.  This is particularly useful for editing the
path directly, such as to go from <code>https://protesilaos.com/contact</code> to
<code>https://protesilaos.com</code>.  When called with a universal prefix argument
(<code>C-u</code>), it opens a new EWW buffer instead of using the last one.</li>

<li><code>prot-eww-search-engine</code> offers selection among the custom search
commands I define, such as to query Wikipedia directly or search for a
bug number in the Emacs issue tracker.  Those search engine commands
can be invoked on their own, while each of them has its own minibuffer
history (so if you searched for "elephant" in Wikipedia, you will not
get that for the Arch Wiki).</li>

<li><code>prot-eww-bookmark-page</code> does what its name suggests though, unlike the
built-in equivalent, it first asks for how to name the bookmarked
entry before storing it in the relevant memory compartment.</li>

<li><code>prot-eww-visit-bookmark</code> prompts with completion to visit an entry in
EWW's bookmark list.  A <code>C-u</code> prefix means to open it in a new EWW
buffer.</li>

<li><code>prot-eww-visit-url-on-page</code> traverses the entire web page to construct
a list of all links and their anchor text.  The list can be narrowed
with completion.  Selecting a item with visit its corresponding web
page.</li>

<li><code>prot-eww-jump-to-url-on-page</code> is similar to the above, with the major
difference that it only stores buffer positions and jumps to them.
This makes it ideal for generating an ad-hoc index of "points of
interest" in the current buffer with the help of Embark's ability to
collect a list of candidates into a bespoke buffer (make sure to check
<a href="#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">Extended minibuffer actions and more (embark.el and prot-embark.el)</a>).
Of course, it can be used on its own to jump around the web page.
Upon jumping, the line will pulse momentarily to help keep a sense of
context (also read: <a href="#h:6bbc41d6-da7c-4301-84c6-c5887c29283f">prot-pulse.el (highlight cursor position)</a>).</li>

<li><code>prot-eww-find-feed</code> inspects the source code of the current web page
and produces an <code>occur</code> buffer with links that represent RSS or Atom
feeds.  This command is quite useful for retrieving the feed of a
website whose designers failed to provide a user-facing link for it
(which is the norm nowadays).  I read feeds on a daily basis: it is
the best way to keep track of updates to web pages (read section
<a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el</a>).</li>

<li><code>prot-eww-readable</code> is a more opinionated take on the built-in option.
It specifies a narrower <code>shr-width</code>, specifically at the 72 character
limit which is my <code>current-fill-column</code>.  Furthermore, it reduces images
to a maximum of 0.35 of the window's width/height.  This is not always
a good approach, though it works most of the time for the kind of
content I am interested in: text-heavy articles.</li>

<li><code>prot-eww-download-html</code> downloads the current web page as an <code>.html</code>
file.  It asks for a name to give to it, defaulting to the title of
the page, and it also prepends the current date and time.  To ensure
that the file name is easily accessible with Unix tools, all
punctuation marks and spaces are removed or replaced with hyphens.  So
if the page is titled <code>"GNU Emacs manual | My ‘cool’ “website”!?"</code> the
saved file will be processed and stored as a filesystem path like
<code>~/Downloads/eww/20210324_185035--gnu-emacs-manual-my-cool-website.html</code>.
I find that this is superior to the generic <code>eww-download</code> which neither
asks for a name, nor adds a date and file type extension.  Where
<code>eww-download</code> still excels is for downloading the link at point, when
that is not an HTML file (e.g. a pdf or zip archive).</li>

<li><code>prot-eww-open-in-other-window</code> is meant to open the link at point in a
new buffer and in another window.  It complements the default <code>M-RET</code>
(<code>eww-open-in-new-buffer</code>) which re-uses the same window.</li>
</ul>

<p>
Some final tips:
</p>

<ul class="org-ul">
<li><code>g</code> reloads the web page by fetching it anew over the network, while its
<code>C-u g</code> counterpart re-renders what has already been downloaded.  The
latter is useful when, for example, you have a new window
configuration and wish to fit the EWW buffer's contents in the window.</li>

<li>As already noted above, several commands that open an EWW buffer
accept a <code>C-u</code> prefix to put their contents in a new buffer rather than
re-use the existing one.  With <code>M-RET</code> over a link in an EWW buffer, you
can do the same.</li>

<li>When point is over an image, the <code>shr-image-map</code> gets activated.  This
allows you to run commands such as <code>image-increase-size</code>, bound to <code>+</code>,
and <code>image-decrease-size</code> on <code>-</code>.  This means that you can always view an
image at an appropriate size, regardless of whether its initial
dimensions were affected by <code>shr-max-image-proportion</code> and the size of
the window holding the EWW buffer.</li>
</ul>

<p>
Also watch <a href="https://protesilaos.com/codelog/2021-03-25-emacs-eww/">EWW and my extras</a> (2021-03-25) for a video demonstration of
some of the above.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
(prot-emacs-builtin-package 'browse-url
  (setq browse-url-browser-function 'eww-browse-url)
  (setq browse-url-secondary-browser-function 'browse-url-default-browser))

(prot-emacs-builtin-package 'shr
  (setq shr-use-colors nil)             ; t is bad for accessibility
  (setq shr-use-fonts nil)              ; t is not for me
  (setq shr-max-image-proportion 0.6)
  (setq shr-image-animate nil)          ; No GIFs, thank you!
  (setq shr-width nil)                  ; check `prot-eww-readable'
  (setq shr-discard-aria-hidden t)
  (setq shr-cookie-policy nil))

(prot-emacs-builtin-package 'url-cookie
  (setq url-cookie-untrusted-urls '(".*")))

(prot-emacs-builtin-package 'eww
  (setq eww-restore-desktop t)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format nil)
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")
  (setq eww-download-directory (expand-file-name "~/Documents/eww-downloads"))
  (setq eww-suggest-uris
        '(eww-links-at-point
          thing-at-point-url-at-point))
  (setq eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
  (setq eww-history-limit 150)
  (setq eww-use-external-browser-for-content-type
        "\\`\\(video/\\|audio\\)") ; On GNU/Linux check your mimeapps.list
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")
  ;; NOTE `eww-retrieve-command' is for Emacs28.  I tried the following
  ;; two values.  The first would not render properly some plain text
  ;; pages, such as by messing up the spacing between paragraphs.  The
  ;; second is more reliable but feels slower.  So I just use the
  ;; default (nil), though I find wget to be a bit faster.  In that case
  ;; one could live with the occasional errors by using `eww-download'
  ;; on the offending page, but I prefer consistency.
  ;;
  ;; '("wget" "--quiet" "--output-document=-")
  ;; '("chromium" "--headless" "--dump-dom")
  (setq eww-retrieve-command nil)

  (define-key eww-link-keymap (kbd "v") nil) ; stop overriding `eww-view-source'
  (define-key eww-mode-map (kbd "L") #'eww-list-bookmarks)
  (define-key dired-mode-map (kbd "E") #'eww-open-file) ; to render local HTML files
  (define-key eww-buffers-mode-map (kbd "d") #'eww-bookmark-kill)   ; it actually deletes
  (define-key eww-bookmark-mode-map (kbd "d") #'eww-bookmark-kill)) ; same

(prot-emacs-elpa-package 'elpher)    ; NOTE 2021-07-24: work-in-progress

(prot-emacs-builtin-package 'prot-eww
  (setq prot-eww-save-history-file
        (locate-user-emacs-file "prot-eww-visited-history"))
  (setq prot-eww-save-visited-history t)
  (setq prot-eww-bookmark-link nil)

  (add-hook 'prot-eww-history-mode-hook #'hl-line-mode)

  (define-prefix-command 'prot-eww-map)
  (define-key global-map (kbd "C-c w") 'prot-eww-map)
  (let ((map prot-eww-map))
    (define-key map (kbd "b") #'prot-eww-visit-bookmark)
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "s") #'prot-eww-search-engine))
  (let ((map eww-mode-map))
    (define-key map (kbd "B") #'prot-eww-bookmark-page)
    (define-key map (kbd "D") #'prot-eww-download-html)
    (define-key map (kbd "F") #'prot-eww-find-feed)
    (define-key map (kbd "H") #'prot-eww-list-history)
    (define-key map (kbd "b") #'prot-eww-visit-bookmark)
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "o") #'prot-eww-open-in-other-window)
    (define-key map (kbd "E") #'prot-eww-visit-url-on-page)
    (define-key map (kbd "J") #'prot-eww-jump-to-url-on-page)
    (define-key map (kbd "R") #'prot-eww-readable)
    (define-key map (kbd "Q") #'prot-eww-quit)))
</pre>
</div>

<p>
And here is <code>prot-eww.el</code> in its entirety.  It is available as a file in
<a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (same for all my Emacs libraries):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-eww.el --- Extensions for EWW -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou, Abhiseck Paira

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;;         Abhiseck Paira &lt;abhiseckpaira@disroot.org&gt;
;; Maintainer: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for the eww, intended for my Emacs setup:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.
;;
;; Thanks to Abhiseck Paira for the patches (see commit log for this
;; file, such as with C-x v l (vc-print-log)).  Some of those improved
;; on various aspects of the EWW-specific functionality, while others
;; provide the layer of integration with Elpher.  Abhiseck's online
;; presence:
;;
;; 1. &lt;https://social.linux.pizza/@redstarfish&gt;
;; 2. &lt;gemini://redstarfish.flounder.online/&gt;

;;; Code:

(require 'shr)
(require 'eww)
(require 'elpher nil t)
(require 'url-parse)
(require 'prot-common)
(require 'prot-pulse)

(defgroup prot-eww ()
  "Tweaks for EWW."
  :group 'eww)

;;;; Basic setup

;; TODO 2021-10-15: Deprecate this in favour of what we added to Emacs29.
;; &lt;https://protesilaos.com/codelog/2021-10-15-emacs-29-eww-rename-buffers/&gt;.

(defun prot-eww--rename-buffer ()
  "Rename EWW buffer using page title or URL.
To be used by `eww-after-render-hook'."
  (let ((name (if (eq "" (plist-get eww-data :title))
                  (plist-get eww-data :url)
                (plist-get eww-data :title))))
    (rename-buffer (format "*%s # eww*" name) t)))

(add-hook 'eww-after-render-hook #'prot-eww--rename-buffer)
(advice-add 'eww-back-url :after #'prot-eww--rename-buffer)
(advice-add 'eww-forward-url :after #'prot-eww--rename-buffer)

;;;; History extras

(defvar prot-eww-visited-history '()
  "History of visited URLs.")

(defcustom prot-eww-save-history-file
  (locate-user-emacs-file "prot-eww-visited-history")
  "File to save the value of `prot-eww-visited-history'."
  :type 'file
  :group 'prot-eww)

(defcustom prot-eww-save-visited-history nil
  "Whether to save `prot-eww-visited-history'.
If non-nil, save the value of `prot-eww-visited-history' in
`prot-eww-save-history-file'."
  :type 'boolean
  :group 'prot-eww)

(defcustom prot-eww-list-history-buffer "*prot-eww-history*"
  "Name of buffer for `prot-eww-list-history'."
  :type 'string
  :group 'prot-eww)

;; These history related functions are adapted from eww.
(defun prot-eww--save-visited-history ()
  "Save the value of `prot-eww-visited-history' in a file.
The file is determined by the variable `prot-eww-save-history-file'."
  (when prot-eww-save-visited-history
    (with-temp-file prot-eww-save-history-file
      (insert (concat ";; Auto-generated file;"
                      " don't edit -*- mode: lisp-data -*-\n"))
      (pp prot-eww-visited-history (current-buffer)))))

(defun prot-eww--read-visited-history (&amp;optional error-out)
  "Read history from `prot-eww-save-history-file'.
If ERROR-OUT, signal `user-error' if there is no history."
  (when prot-eww-save-visited-history
    (let ((file prot-eww-save-history-file))
      (setq prot-eww-visited-history
            (unless (zerop
                     (or (file-attribute-size (file-attributes file))
                         0))
              (with-temp-buffer
                (insert-file-contents file)
                (read (current-buffer)))))
      (when (and error-out (not prot-eww-visited-history))
        (user-error "No history is defined")))))

(unless prot-eww-visited-history
  (prot-eww--read-visited-history t))

(defun prot-eww--history-prepare ()
  "Prepare dedicated buffer for browsing history."
  (set-buffer (get-buffer-create prot-eww-list-history-buffer))
  (prot-eww-history-mode)
  (let ((inhibit-read-only t)
        start)
    (erase-buffer)
    (setq-local header-line-format
                "Unified EWW and Elpher Browsing History (prot-eww)")
    (dolist (history prot-eww-visited-history)
      (setq start (point))
      (insert (format "%s" history) "\n")
      (put-text-property start (1+ start) 'prot-eww-history history))
    (goto-char (point-min))))

;;;###autoload
(defun prot-eww-list-history ()
  "Display `prot-eww-visited-history' in a dedicated buffer.
This is a replacement for `eww-list-histories' (or equivalent),
as it can combine URLs in the Gopher or Gemini protocols."
  (interactive)
  (when prot-eww-visited-history
    (prot-eww--save-visited-history))
  (prot-eww--read-visited-history t)
  (pop-to-buffer prot-eww-list-history-buffer)
  (prot-eww--history-prepare))

(defvar prot-eww-history-kill-ring nil
  "Store the killed history element.")

(defun prot-eww-history-kill ()
  "Kill the current history."
  (interactive)
  (let* ((start (line-beginning-position))
         (history (get-text-property start 'prot-eww-history))
         (inhibit-read-only t))
    (unless history
      (user-error "No history on the current line"))
    (forward-line 1)
    (push (buffer-substring start (point))
          prot-eww-history-kill-ring)
    (delete-region start (point))
    (setq prot-eww-visited-history (delq history
                                         prot-eww-visited-history))
    (prot-eww--save-visited-history)))

(defun prot-eww-history-yank ()
  "Yank a previously killed history to the current line."
  (interactive)
  (unless prot-eww-history-kill-ring
    (user-error "No previously killed history"))
  (beginning-of-line)
  (let ((inhibit-read-only t)
        (start (point))
        history)
    (insert (pop prot-eww-history-kill-ring))
    (setq history (get-text-property start 'prot-eww-history))
    (if (= start (point-min))
        (push history prot-eww-visited-history)
      (let ((line (count-lines start (point))))
        (setcdr (nthcdr (1- line) prot-eww-visited-history)
                (cons history (nthcdr line
                                      prot-eww-visited-history)))))
    (prot-eww--save-visited-history)))

(defun prot-eww-history-browse ()
  "Browse the history under point."
  (interactive)
  (let ((history (get-text-property (line-beginning-position)
                                     'prot-eww-history)))
    (unless history
      (user-error "No history on the current line"))
    (quit-window)
    (prot-eww history)))

(defvar prot-eww-history-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-k") 'prot-eww-history-kill)
    (define-key map (kbd "C-y") 'prot-eww-history-yank)
    (define-key map (kbd "&lt;RET&gt;") 'prot-eww-history-browse)

    (easy-menu-define nil map
      "Menu for `prot-eww-history-mode-map'."
      '("prot-eww history"
        ["Exit" quit-window t]
        ["Browse" prot-eww-history-browse
         :active (get-text-property (line-beginning-position)
                                    'prot-eww-history)]
        ["Kill" prot-eww-history-kill
         :active (get-text-property (line-beginning-position)
                                    'prot-eww-history)]
        ["Yank" prot-eww-history-yank
         :active prot-eww-history-kill-ring]))
    map))

(define-derived-mode prot-eww-history-mode
  special-mode
  "prot-eww-history"
  "Mode for listing history.

\\{prot-eww-history-mode-map}"
  (buffer-disable-undo)
  (setq truncate-lines t))

(defun prot-eww--record-history ()
  "Store URL in `prot-eww-visited-history'.
To be used by `eww-after-render-hook'."
  (let ((url (plist-get eww-data :url)))
    (add-to-history 'prot-eww-visited-history url)))

(autoload 'elpher-page-address "elpher")
(autoload 'elpher-address-to-url "elpher")
(defvar elpher-current-page)

(defun prot-eww--record-elpher-history (arg1 &amp;optional arg2 arg3)
  "Store URLs visited using elpher in `prot-eww-visited-history'.
To be used by `elpher-visited-page'.  ARG1, ARG2, ARG3 are
unused."
  (let* ((address (elpher-page-address elpher-current-page))
         (url (elpher-address-to-url address)))
    ;; elpher-address-to-url checks for special pages.
    (when url
      (add-to-list 'prot-eww-visited-history url))))

(add-hook 'eww-after-render-hook #'prot-eww--record-history)
(advice-add 'eww-back-url :after #'prot-eww--record-history)
(advice-add 'eww-forward-url :after #'prot-eww--record-history)
(advice-add 'elpher-visit-page :after #'prot-eww--record-elpher-history)
;; Is there a better function to add this advice?

;;;; Commands

;; handler that browse-url calls.

(defun prot-eww--get-current-url ()
  "Return the current-page's URL."
  (cond ((eq major-mode 'elpher-mode)
         (elpher-address-to-url
          (elpher-page-address elpher-current-page)))
        ((eq major-mode 'eww-mode)
         (plist-get eww-data :url))
        ;; (t (user-error "Not a eww or elpher buffer"))
        ))

;; This is almost identical to browse-url-interactive-arg except it
;; calls thing-at-point-url-at-point instead of
;; browse-url-url-at-point[1]. The problem with [1] is that it cancats
;; "http" anything it finds, which is a problem for gemini, gopher
;; etc.  urls. I hope there's something similar or better way to do
;; it, we don't have to use this one.
(defun prot-eww--interactive-arg (prompt)
  "Read a URL from the minibuffer, prompting with PROMPT.
If Transient-mark-mode is non-nil and the mark is active, it
defaults to the current region, else to the URL at or before
point.  If invoked with a mouse button, it moves point to the
position clicked before acting.

Return URL for use in a interactive."
  (let ((event (elt (this-command-keys) 0)))
    (and (listp event) (mouse-set-point event)))
  (read-string prompt
               (or (and transient-mark-mode mark-active
                        ;; rfc2396 Appendix E.
                        (replace-regexp-in-string
                         "[\t\r\f\n ]+" ""
                         (buffer-substring-no-properties
                          (region-beginning) (region-end))))
                   (thing-at-point-url-at-point t))))

(declare-function elpher-go "elpher")

;;;###autoload
(defun prot-eww (url &amp;optional arg)
  "Pass URL to appropriate client.
With optional ARG, use a new buffer."
  (interactive
   (list (prot-eww--interactive-arg "URL: ")
         current-prefix-arg))
  (let ((url-parsed (url-generic-parse-url url)))
    (pcase (url-type url-parsed)
      ((or "gemini" "gopher" "gophers" "finger")
       (elpher-go url))
      (_ (eww url arg)))))

;;;###autoload
(defun prot-eww-browse-dwim (url &amp;optional arg)
  "Visit a URL, maybe from `eww-prompt-history', with completion.

With optional prefix ARG (\\[universal-argument]) open URL in a
new eww buffer.  If URL does not look like a valid link, run a
web query using `eww-search-prefix'.

When called from an eww buffer, provide the current link as
\\&lt;minibuffer-local-map&gt;\\[next-history-element]."
  (interactive
   (let ((all-history (delete-dups
                       (append prot-eww-visited-history
                               eww-prompt-history)))
         (current-url (prot-eww--get-current-url)))
     (list
      (completing-read "Run EWW on: " all-history
                       nil nil current-url 'eww-prompt-history current-url)
      (prefix-numeric-value current-prefix-arg))))
  (prot-eww url arg))

;; NOTE 2021-09-08: This uses the EWW-specific bookmarks, NOT those of
;; bookmark.el.  Further below I provide integration with the latter,
;; meaning that we must either make this obsolete or make it work with
;; the new system.
;;;###autoload
(defun prot-eww-visit-bookmark (&amp;optional arg)
  "Visit bookmarked URL.

With optional prefix ARG (\\[universal-argument]) open URL in a
new EWW buffer."
  (interactive "P")
  (eww-read-bookmarks)
  (let ((list (gensym)))
    (dolist (bookmark eww-bookmarks)
      (push (plist-get bookmark :url) list))
    (if eww-bookmarks
        (eww (completing-read "Visit EWW bookmark: " list)
             (when arg 4))
      (user-error "No bookmarks"))))

(defun prot-eww--capture-url-on-page (&amp;optional position)
  "Capture all the links on the current web page.

Return a list of strings.  Strings are in the form LABEL @ URL.
When optional argument POSITION is non-nil, include position info
in the strings too, so strings take the form
LABEL @ URL ~ POSITION."
  (let (links match)
    (save-excursion
      (goto-char (point-min))
      ;; NOTE 2021-07-25: The first clause in the `or' is meant to
      ;; address a bug where if a URL is in `point-min' it does not get
      ;; captured.
      (while (setq match (text-property-search-forward 'shr-url))
        (let* ((raw-url (prop-match-value match))
               (start-point-prop (prop-match-beginning match))
               (end-point-prop (prop-match-end match))
               (url (when (stringp raw-url)
                      (propertize raw-url 'face 'link)))
               (label (replace-regexp-in-string "\n" " " ; NOTE 2021-07-25: newlines break completion
                       (buffer-substring-no-properties
                       start-point-prop end-point-prop)))
               (point start-point-prop)
               (line (line-number-at-pos point t))
               (column (save-excursion (goto-char point) (current-column)))
               (coordinates (propertize
                             (format "%d,%d (%d)" line column point)
                             'face 'shadow)))
          (when url
            (if position
                (push (format "%-15s ~ %s  @ %s"
                              coordinates label url)
                      links)
              (push (format "%s  @ %s"
                            label url)
                    links))))))
    links))

(defmacro prot-eww-act-visible-window (&amp;rest body)
  "Run BODY within narrowed-region.
If region is active run BODY within active region instead.
Return the value of the last form of BODY."
  `(save-restriction
     (if (use-region-p)
         (narrow-to-region (region-beginning) (region-end))
       (narrow-to-region (window-start) (window-end)))
     ,@body))

;;;###autoload
(defun prot-eww-visit-url-on-page (&amp;optional arg)
  "Visit URL from list of links on the page using completion.

With optional prefix ARG (\\[universal-argument]) open URL in a
new EWW buffer."
  (interactive "P")
  (when (derived-mode-p 'eww-mode)
    (let* ((links (prot-eww--capture-url-on-page))
           (selection (completing-read "Browse URL from page: " links nil t))
           (url (replace-regexp-in-string ".*@ " "" selection)))
      (eww url (when arg 4)))))

;;;###autoload
(defun prot-eww-jump-to-url-on-page (&amp;optional arg)
  "Jump to URL position on the page using completion.

When called without ARG (\\[universal-argument]) get URLs only
from the visible portion of the buffer.  But when ARG is provided
consider whole buffer."
  (interactive "P")
  (when (derived-mode-p 'eww-mode)
    (let* ((links
            (if arg
                (prot-eww--capture-url-on-page t)
              (prot-eww-act-visible-window
               (prot-eww--capture-url-on-page t))))
           (prompt-scope (if arg
                             (propertize "URL on the page" 'face 'warning)
                           "visible URL"))
           (prompt (format "Jump to %s: " prompt-scope))
           (selection (completing-read prompt links nil t))
           (position (replace-regexp-in-string "^.*(\\([0-9]+\\))[\s\t]+~" "\\1" selection))
           (point (string-to-number position)))
      (goto-char point)
      (prot-pulse-pulse-line))))

(defvar prot-eww--occur-feed-regexp
  (concat "\\(rss\\|atom\\)\\+xml.\\(.\\|\n\\)"
          ".*href=[\"']\\(.*?\\)[\"']")
  "Regular expression to match web feeds in HTML source.")

;;;###autoload
(defun prot-eww-find-feed ()
  "Produce bespoke buffer with RSS/Atom links from XML source."
  (interactive)
  (let* ((url (or (plist-get eww-data :start)
                  (plist-get eww-data :contents)
                  (plist-get eww-data :home)
                  (plist-get eww-data :url)))
         (title (or (plist-get eww-data :title) url))
         (source (plist-get eww-data :source))
         (buf-name (format "*feeds: %s # eww*" title)))
    (with-temp-buffer
      (insert source)
      (occur-1 prot-eww--occur-feed-regexp "\\3" (list (current-buffer)) buf-name))
    ;; Handle relative URLs, so that we get an absolute URL out of them.
    ;; Findings like "rss.xml" are not particularly helpful.
    ;;
    ;; NOTE 2021-03-31: the base-url heuristic may not always be
    ;; correct, though it has worked in all cases I have tested it on.
    (when (get-buffer buf-name)
      (with-current-buffer (get-buffer buf-name)
        (let ((inhibit-read-only t)
              (base-url (replace-regexp-in-string "\\(.*/\\)[^/]+\\'" "\\1" url)))
          (goto-char (point-min))
          (unless (re-search-forward prot-common-url-regexp nil t)
            (re-search-forward ".*")
            (replace-match (concat base-url "\\&amp;"))))))))

;;TODO: Add this variable as user-option, that is, define it with
;;`defcustom' so that users can use the customization interface to
;;modify it.

(defvar prot-eww-search-engines
  '((debbugs . (debbugs
                "https://debbugs.gnu.org/cgi/bugreport.cgi?bug="
                hist-var prot-eww--debbugs-hist))
    (wikipedia . (wikipedia
                  "https://en.m.wikipedia.org/w/index.php?search="
                  hist-var prot-eww--wikipedia-hist))
    (archwiki . (archwiki
                 "https://wiki.archlinux.org/index.php?search="
                 hist-var prot-eww--archwiki-hist))
    (aur . (aur "https://aur.archlinux.org/packages/?K="
                hist-var prot-eww--aur-hist)))
  "Alist of Plist of web search engines related data.
From now on refer to this type of data as APLIST.  Each element
of APLIST is (KEY . VALUE) pair.  KEY is a symbol specifying
search engine name.  The VALUE is property list.

The plist has two key-value pairs.  K1 is the same symbol has KEY
and V1 is search string of the search engine.

K2 is the symbol 'hist-var', V2 is also a symbol that has a format
'prot-eww--K1-hist'.

NOTE: If you modify this variable after `prot-eww' is loaded you
need to run the following code after modification:

    (prot-eww--define-hist-var prot-eww-search-engines)")

;; Below 's-string' is short for 'search-string'. For wikipedia which
;; is this string: "https://en.m.wikipedia.org/w/index.php?search=". I
;; use this name because I don't know it's proper name.

;; Define constructor and selectors functions to access
;; `prot-eww-search-engines'.
;; the constructor
(defun prot-eww--cons-search-engines (name s-string)
  "Include a new Alist element.
The alist element is added to variable `prot-eww-search-engines'.

NAME should be symbol representing the search engine.  S-STRING
should be string, which is specific to named search engine."
  (let ((my-plist `(,name ,s-string))
        (hist-var-name (format "prot-eww--%s-hist"
                               (symbol-name name))))
    (plist-put my-plist 'hist-var (intern hist-var-name))
    (let ((my-alist (cons name my-plist)))
      (add-to-list 'prot-eww-search-engines my-alist))))

;; Selectors definitions start
(defun prot-eww--select-hist-name (aplist engine-name)
  "Get hist-var-name from APLIST of ENGINE-NAME."
  (let ((hist-var-name (plist-get
                        (alist-get engine-name aplist)
                        'hist-var)))
    hist-var-name))

(defun prot-eww--select-engine-names (aplist)
  "Return a list of search-engine names from APLIST.
Each value of the list is a string."
  (mapcar (lambda (x) (format "%s" (car x)))
          aplist))

(defun prot-eww--select-s-string (aplist engine-name)
  "Return the search-string for specified ENGINE-NAME from APLIST."
  (plist-get
   (alist-get engine-name aplist)
   engine-name))
;; Selector definitions end here.

(defun prot-eww--define-hist-var (aplist)
  "Initialize APLIST hist-variables to empty list; return nil."
  (let ((engine-names
         (prot-eww--select-engine-names aplist)))
    (dolist (engine engine-names)
      (let ((hist-var-name
             (prot-eww--select-hist-name aplist
                                         (intern engine))))
        (set hist-var-name '())))))

(prot-eww--define-hist-var prot-eww-search-engines)

;;;###autoload
(defun prot-eww-search-engine (engine s-term &amp;optional arg)
  "Search S-TERM using ENGINE.
ENGINE is an assossiation defined in `prot-eww-search-engines'.

With optional prefix ARG (\\[universal-argument]) open the search
result in a new buffer."
  (interactive
   (let* ((engine-list (prot-eww--select-engine-names
                        prot-eww-search-engines))
          (engine-name (completing-read
                        "Search with: " engine-list nil t nil
                        'prot-eww--engine-hist))
          (history-list (prot-eww--select-hist-name
                         prot-eww-search-engines
                         (intern engine-name)))
          (search-term (read-string
                        "Search for: " nil history-list)))
     (list engine-name search-term
           (prefix-numeric-value current-prefix-arg))))
  (let* ((s-string
          (prot-eww--select-s-string prot-eww-search-engines
                                     (intern engine)))
         (eww-pass (format "%s%s" s-string s-term))
         (history-list (prot-eww--select-hist-name
                        prot-eww-search-engines
                        (intern engine))))
    (add-to-history history-list s-term)
    (eww eww-pass arg)))

;;;###autoload
(defun prot-eww-open-in-other-window ()
  "Use `eww-open-in-new-buffer' in another window."
  (interactive)
  (other-window-prefix)       ; For emacs28 -- it's a hack, but why not?
  (eww-open-in-new-buffer))

;;;###autoload
(defun prot-eww-readable ()
  "Use more opinionated `eww-readable'.

Set width is set to `current-fill-column'.  Adjust size of
images."
  (interactive)
  (let ((shr-width (current-fill-column))
        (shr-max-image-proportion 0.35))
    (eww-readable)))

;; NOTE 2021-09-08: This uses the EWW-specific bookmarks, NOT those of
;; bookmark.el.  Further below I provide integration with the latter,
;; meaning that we must either make this obsolete or make it work with
;; the new system.
;;;###autoload
(defun prot-eww-bookmark-page (title)
  "Add eww bookmark named with TITLE."
  (interactive
   (list
    (read-string "Set bookmark title: " (plist-get eww-data :title))))
  (plist-put eww-data :title title)
  (eww-add-bookmark))

(defvar prot-eww--punctuation-regexp "[][{}!@#$%^&amp;*()_=+'\"?,.\|;:~`‘’“”]*"
  "Regular expression of punctionation that should be removed.")

(defun prot-eww--slug-no-punct (str)
  "Convert STR to a file name slug."
  (replace-regexp-in-string prot-eww--punctuation-regexp "" str))

(defun prot-eww--slug-hyphenate (str)
  "Replace spaces with hyphens in STR.
Also replace multiple hyphens with a single one and remove any
trailing hyphen."
  (replace-regexp-in-string
   "-$" ""
   (replace-regexp-in-string
    "-\\{2,\\}" "-"
    (replace-regexp-in-string "--+\\|\s+" "-" str))))

(defun prot-eww--sluggify (str)
  "Make STR an appropriate file name slug."
  (downcase (prot-eww--slug-hyphenate (prot-eww--slug-no-punct str))))

;;;###autoload
(defun prot-eww-download-html (name)
  "Download web page and call the file with NAME."
  (interactive
   (list
    (prot-eww--sluggify
     (read-string "Set downloaded file name: " (plist-get eww-data :title)))))
  (let* ((path (thread-last eww-download-directory
                 (expand-file-name
                  (concat (format-time-string "%Y%m%d_%H%M%S") "--" name ".html"))))
         (out (prot-common-shell-command-with-exit-code-and-output
               "wget" "-q" (format "%s" (plist-get eww-data :url))
               "-O" (format "%s" (shell-quote-argument path)))))
    (if (= (car out) 0)
        (message "Downloaded page at %s" path)
      (message "Error downloading page: %s" (cdr out)))))

(defun prot-eww--kill-buffers-when (predicate)
  "Kill buffers when PREDICATE is non-nil.

Loop through the buffer list, calling PREDICATE with each buffer.
When calling PREDICATE with a buffer returns non-nil, kill that
buffer.

PREDICATE must be function that takes buffer-object as the one
and only argument.  It should return nil or non-nil."
  (let ((list-buffers (buffer-list)))
    (dolist (buffer list-buffers)
      (when (funcall predicate buffer)
        (kill-buffer buffer)))))

(defun prot-eww--kill-eww-buffers-p (buffer)
  "Predicate function.  Return nil or non-nil.

Take BUFFER, make it current, check if it has 'eww-mode' as the
`major-mode' or if its major mode is derived from `special-mode'
and has \"eww\" in the buffer-name. Then return non-nil."
  (let ((case-fold-search t))  ; ignore case
    (with-current-buffer buffer
      (or (eq major-mode 'eww-mode)
          (and (derived-mode-p 'special-mode)
               (string-match "\\*.*eww.*\\*" (buffer-name)))))))

(defun prot-eww-kill-eww-buffers ()
  "Kill all EWW buffers.
Also kill special buffers made by EWW for example buffers like
\"*eww-bookmarks*\", \"*eww-history*\" etc."
  (prot-eww--kill-buffers-when 'prot-eww--kill-eww-buffers-p))

(defcustom prot-eww-delete-cookies t
  "If non-nil delete cookies when `prot-eww-quit' is called."
  :type 'boolean
  :group 'prot-eww)

(defun prot-eww-delete-cookies ()
  "Delete cookies from the cookie file."
  (when prot-eww-delete-cookies
    (url-cookie-delete-cookies)))

;; TODO: Make it defcustom
(defvar prot-eww-quit-hook nil
  "Run this hook when `prot-eww-quit' is called.")

;; Populate the hook with these functions.
(dolist (func '(prot-eww-delete-cookies
                prot-eww-kill-eww-buffers
                prot-eww--save-visited-history))
  (add-hook 'prot-eww-quit-hook func))

;;;###autoload
(defun prot-eww-quit ()
  "Quit eww, kill all its buffers, delete all cookies.
As a final step, save `prot-eww-visited-history' to a file (see
`prot-eww-save-history-file')."
  (interactive)
  (if prot-eww-save-visited-history
      (when (y-or-n-p "Are you sure you want to quit eww? ")
        (run-hooks 'prot-eww-quit-hook))
    ;;
    ;; Now users have full control what `prot-eww-quit' does, by
    ;; modifying `prot-eww-quit-hook'.
    (when (yes-or-no-p "Are you sure you want to quit eww?")
      (run-hooks 'prot-eww-quit-hook))))

;;;;; Bookmarks with bookmark.el
;; The following is adapted from vc-dir.el.

;; TODO 2021-09-08: Review all legacy bookmark functions defined herein.

(defcustom prot-eww-bookmark-link nil
  "Control the behaviour of bookmarking inside EWW buffers.

If non-nil bookmark the button at point, else the current page's
URL.  Otherwise only target the current page.

This concerns the standard bookmark.el framework, so it applies
to commands `bookmark-set' and `bookmark-set-no-overwrite'."
  :type 'boolean
  :group 'prot-eww)

(declare-function bookmark-make-record-default "bookmark" (&amp;optional no-file no-context posn))
(declare-function bookmark-prop-get "bookmark" (bookmark prop))
(declare-function bookmark-default-handler "bookmark" (bmk))
(declare-function bookmark-get-bookmark-record "bookmark" (bmk))

(defun prot-eww--bookmark-make-record ()
  "Return a bookmark record.
If `prot-eww-bookmark-link' is non-nil and point is on a link button,
return a bookmark record for that link.  Otherwise, return a bookmark
record for the current EWW page."
  (let* ((button (and prot-eww-bookmark-link
                      (button-at (point))))
         (url (if button
                  (button-get button 'shr-url)
                (plist-get eww-data :url))))
    (unless url
      (error "No link found; cannot bookmark this"))
    (let* ((title (if button
                      url
                    (concat "(EWW) " (plist-get eww-data :title))))
           (pos (if button nil (point)))
           (defaults (delq nil (list title url))))
      `(,title
        ,@(bookmark-make-record-default 'no-file)
        (eww-url . ,url)
        (filename . ,url) ; This is a hack to get Marginalia annotations
        (position . ,pos)
        (handler . prot-eww-bookmark-jump)
        (defaults . ,defaults)))))

(defun prot-eww--set-bookmark-handler ()
  "Set appropriate `bookmark-make-record-function'.
Intended for use with `eww-mode-hook'."
  (setq-local bookmark-make-record-function #'prot-eww--bookmark-make-record))

(add-hook 'eww-mode-hook #'prot-eww--set-bookmark-handler)

(defun prot-eww--pop-to-buffer (buffer &amp;rest _args)
  "Set BUFFER and ignore ARGS.
Just a temporary advice to override `pop-to-buffer'."
  (set-buffer buffer))

(declare-function bookmark-get-handler "bookmark" (bookmark-name-or-record))
(declare-function bookmark-get-front-context-string "bookmark" (bookmark-name-or-record))
(declare-function bookmark-get-rear-context-string "bookmark" (bookmark-name-or-record))
(declare-function bookmark-get-position "bookmark" (bookmark-name-or-record))
(declare-function bookmark-name-from-full-record "bookmark" (bookmark-record))
(declare-function bookmark-get-bookmark "bookmark" (bookmark-name-or-record &amp;optional noerror))

;; Copied from the `eww-conf.el' of JSDurand on 2021-09-17 10:19 +0300:
;; &lt;https://git.jsdurand.xyz/emacsd.git/tree/eww-conf.el&gt;.  My previous
;; version would not work properly when trying to open the bookmark in
;; the other window from inside the Bookmarks' list view.

;;;###autoload
(defun prot-eww-bookmark-jump (bookmark)
  "Jump to BOOKMARK in EWW.
This is intended to be the handler for bookmark records created
by `prot-eww--bookmark-make-record'.

If there is already a buffer visiting the URL of the bookmark,
simply jump to that buffer and try to restore the point there.
Otherwise, fetch URL and afterwards try to restore the point."
  (let ((handler (bookmark-get-handler bookmark))
        (location (bookmark-prop-get bookmark 'eww-url))
        (front (cons 'front-context-string
                     (bookmark-get-front-context-string bookmark)))
        (rear (cons 'rear-context-string
                    (bookmark-get-rear-context-string bookmark)))
        (position (cons 'position (bookmark-get-position bookmark)))
        (eww-buffers
         (delq
          nil
          (mapcar
           (lambda (buffer)
             (cond
              ((provided-mode-derived-p
                (buffer-local-value
                 'major-mode buffer)
                'eww-mode)
               buffer)))
           (buffer-list))))
        buffer)
    (cond
     ((and (stringp location)
           (not (string= location ""))
           (eq handler #'prot-eww-bookmark-jump))
      (let (reuse-p)
        (mapc
         (lambda (temp-buffer)
           (cond
            ((string=
              (plist-get
               (buffer-local-value 'eww-data temp-buffer)
               :url)
              location)
             (setq reuse-p temp-buffer)
             (setq buffer temp-buffer))))
         eww-buffers)
        ;; Don't switch to that buffer, otherwise it will cause
        ;; problems if we want to open the bookmark in another window.
        (cond
         (reuse-p
          (set-buffer reuse-p)
          ;; we may use the default handler to restore the position here
          (with-current-buffer reuse-p
            (goto-char (cdr position))
            (cond
             ((search-forward (cdr front) nil t)
              (goto-char (match-beginning 0))))
            (cond
             ((search-forward (cdr rear) nil t)
              (goto-char (match-end 0))))))
         (t
          ;; HACK, GIANT HACK!
          
          (advice-add #'pop-to-buffer :override
                      #'prot-eww--pop-to-buffer)
          (eww location 4)
          ;; after the `set-buffer' in `eww', the current buffer is
          ;; the buffer we want
          (setq buffer (current-buffer))
          ;; restore the definition of pop-to-buffer...
          (advice-remove
           #'pop-to-buffer #'prot-eww--pop-to-buffer)
          ;; add a hook to restore the position

          ;; make sure each hook function is unique, so that different
          ;; hooks don't interfere with each other.
          (let ((function-symbol
                 (intern
                  (format
                   "eww-render-hook-%s"
                   (bookmark-name-from-full-record
                    (bookmark-get-bookmark bookmark))))))
            (fset function-symbol
                  (lambda ()
                    (remove-hook
                     'eww-after-render-hook function-symbol)
                    (bookmark-default-handler
                     (list
                      "" (cons 'buffer buffer)
                      front rear position))))
            (add-hook 'eww-after-render-hook function-symbol))))))
     ((user-error "Cannot jump to this bookmark")))))


;;; lynx dump

(defcustom prot-eww-post-lynx-dump-function nil
  "Function to run on lynx dumped buffer for post-processing.
Function is called with the URL of the page the buffer is
visiting.

Specifying nil turns off this variable, meaning that no
post-processing takes place."
  :group 'prot-eww
  :type '(choice (const :tag "Unspecified" nil)
                 function))

(defcustom prot-eww-lynx-dump-dir
  (if (stringp eww-download-directory)
      eww-download-directory
    (funcall eww-download-directory))
  "Directory to save lynx dumped files.
It should be an existing directory or a sexp that evaluates to an
existing directory."
  :group 'prot-eww
  :type '(choice directory sexp))

(defun prot-eww--lynx-available-p ()
  "Check if `lynx' is available in PATH."
  (executable-find "lynx"))

(defun prot-eww--get-text-property-string (prop)
  "Return string that has text property PROP at (point).
The string is from (point) to end of PROP.  If there is no text
property PROP at (point), return nil."
  (let* ((match (text-property-search-forward prop))
         (start-point-prop (prop-match-beginning match))
         (end-point-prop (prop-match-end match)))
    (and
     (&lt;= start-point-prop (point) end-point-prop)
     (replace-regexp-in-string
      "\n" " "
      (buffer-substring-no-properties
       start-point-prop end-point-prop)))))

(defun prot-eww--current-page-title ()
  "Return title of the Web page EWW buffer is visiting."
  (plist-get eww-data :title))

(defun prot-eww-lynx-dump (url filename)
  "Run lynx -dump on URL and save output as FILENAME.
When run interactively in a eww buffer visiting a web page, run
lynx dump on the web page's URL.  If point is on a link, then run
lynx dump on that link instead."
  (interactive
   (let* ((default-url (or (get-text-property (point) 'shr-url)
                           (eww-current-url)))
          (dir prot-eww-lynx-dump-dir)
          (title (or
                  (prot-eww--get-text-property-string 'shr-url)
                  (prot-eww--current-page-title)))
          (def-file-name
            (file-name-concat dir
                              (concat (prot-eww--sluggify title) ".txt"))))
     (list
      (read-string (format "URL [%s]: " default-url) nil nil default-url)
      (read-file-name (format "File Name [%s]: " def-file-name) dir def-file-name))))
  (if (prot-eww--lynx-available-p)
      (progn
        (access-file prot-eww-lynx-dump-dir "Non existing directory specified")
        (with-temp-file filename
          (with-temp-message
              (format "Running `lynx --dump %s'" url)
            (let ((coding-system-for-read 'prefer-utf-8))
              (call-process "lynx" nil t nil "-dump" url)))
          (with-temp-message "Processing lynx dumped buffer..."
            (and
             (functionp prot-eww-post-lynx-dump-function)
             (funcall prot-eww-post-lynx-dump-function url)))))
    (error "`lynx' executable not found in PATH")))

(provide 'prot-eww)
;;; prot-eww.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:02894c1d-a739-48e7-9116-3c27a6505485" class="outline-3">
<h3 id="h:02894c1d-a739-48e7-9116-3c27a6505485"><span class="section-number-3">5.17.</span> Extensions for PDFs (pdf-tools)</h3>
<div class="outline-text-3" id="text-h:02894c1d-a739-48e7-9116-3c27a6505485">
<p>
The <code>pdf-tools</code> package builds on top of the external libraries, <code>poppler</code>
and <code>imagemagick</code> (if Emacs is compiled with support for it) to deliver a
series of minor modes for reading and interacting with PDF files from
inside of Emacs.  As it depends on those external files, it requires
extra steps to make it work properly.  Those are documented at length in
its README and vary depending on your operating system.
</p>

<p>
All you need to start reading PDFs is to put the <code>pdf-loader-install</code>
function in your configurations, which loads the tools once you open an
appropriate file, such as through <code>dired</code> or with <code>find-file</code>.  Once inside
the resulting buffer, do <code>C-h m</code> (<code>describe-mode</code>) to learn about the key
bindings and the commands they call.  The basics:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Key</th>
<th scope="col" class="org-left">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">+</td>
<td class="org-left">Enlarge (zoom in)</td>
</tr>

<tr>
<td class="org-left">-</td>
<td class="org-left">Shrink (zoom out)</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-left">Reset zoom</td>
</tr>

<tr>
<td class="org-left">C-n</td>
<td class="org-left">Next line</td>
</tr>

<tr>
<td class="org-left">C-p</td>
<td class="org-left">Previous line</td>
</tr>

<tr>
<td class="org-left">SPC</td>
<td class="org-left">Scroll down</td>
</tr>

<tr>
<td class="org-left">S-SPC</td>
<td class="org-left">Scroll up</td>
</tr>
</tbody>
</table>

<p>
To determine which minor modes out of the entire suite are activated,
you need to configure the variable <code>pdf-tools-enabled-modes</code>.  I reduce it
only a subset of what is available by default because I do not need all
the extras.  That granted, there are at least two minor modes that users
may find helpful: <code>pdf-annot-minor-mode</code> which provides annotation
capabilities and <code>pdf-sync-minor-mode</code> which syncs the PDF with its
corresponding TeX file when you are running some setup that compiles the
latter to the former.
</p>

<p>
The value proposition of <code>pdf-tools</code> is that it works with <code>isearch</code> and
<code>occur</code> so you can easily (i) search through the file and (ii) produce a
buffer of locations with matching queries.  As is the norm with
<code>pdf-tools</code>, those facilities are implemented as minor modes:
<code>pdf-isearch-minor-mode</code>, <code>pdf-occur-global-minor-mode</code> (this also works
with <code>ibuffer</code> and <code>dired</code>).
</p>

<p>
Another helpful integration is with Emacs' <code>outline-mode</code> and <code>imenu</code> by
means of <code>pdf-outline-minor-mode</code>.  Simply hit <code>o</code> while viewing a PDF to
produce an outline of the document and then, optionally, <code>M-x imenu</code> to
navigate it using minibuffer completion (though for the latter task you
may prefer something like <code>consult-outline</code>, which is part of the Consult
package: <a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el and prot-consult.el)</a>).
</p>

<p>
Finally, I have some tweaks to change the backdrop of the buffer so that
it is distinct from the page's background while using my light Modus
Operandi theme (<a href="#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">Modus themes (my highly accessible themes)</a>).  Plus, I
make it automatically adapt to the <code>modus-themes-toggle</code> command, so that
the PDF switches to a dark theme when it has to.  Those are documented
in the manual of the themes.  If you are using them, evaluate this form:
<code>(info "(modus-themes) Backdrop for pdf-tools (DIY)")</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Extensions for PDFs (pdf-tools)
(prot-emacs-elpa-package 'pdf-tools
  (setq pdf-tools-enabled-modes         ; simplified from the defaults
        '(pdf-history-minor-mode
          pdf-isearch-minor-mode
          pdf-links-minor-mode
          pdf-outline-minor-mode
          pdf-misc-size-indication-minor-mode
          pdf-occur-global-minor-mode))
  (setq pdf-view-display-size 'fit-height)
  (setq pdf-view-continuous t)
  (setq pdf-view-use-dedicated-register nil)
  (setq pdf-view-max-image-width 1080)
  (setq pdf-outline-imenu-use-flat-menus t)

  (pdf-loader-install)

  ;; Those functions and hooks are adapted from the manual of my
  ;; modus-themes.  The idea is to (i) add a backdrop that is distinct
  ;; from the background of the PDF's page and (ii) make pdf-tools adapt
  ;; to theme switching via, e.g., `modus-themes-toggle'.
  (defun prot/pdf-tools-backdrop ()
    (face-remap-add-relative
     'default
     `(:background ,(modus-themes-color 'bg-alt))))

  (defun prot/pdf-tools-midnight-mode-toggle ()
    (when (derived-mode-p 'pdf-view-mode)
      (if (eq (car custom-enabled-themes) 'modus-vivendi)
          (pdf-view-midnight-minor-mode 1)
        (pdf-view-midnight-minor-mode -1))
      (prot/pdf-tools-backdrop)))

  (add-hook 'pdf-tools-enabled-hook #'prot/pdf-tools-midnight-mode-toggle)
  (add-hook 'modus-themes-after-load-theme-hook #'prot/pdf-tools-midnight-mode-toggle))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:b6bd2eea-8269-4029-b446-ee340c12ebc3" class="outline-2">
<h2 id="h:b6bd2eea-8269-4029-b446-ee340c12ebc3"><span class="section-number-2">6.</span> General interface and interactions</h2>
<div class="outline-text-2" id="text-h:b6bd2eea-8269-4029-b446-ee340c12ebc3">
<p>
This section contains configurations for all aspects of the Emacs user
interface, as well lots of small or self-contained tweaks that cover a
wide range of built-in libraries.
</p>
</div>

<div id="outline-container-h:ac889a76-1092-449e-a184-9092093f3103" class="outline-3">
<h3 id="h:ac889a76-1092-449e-a184-9092093f3103"><span class="section-number-3">6.1.</span> Go to last change</h3>
<div class="outline-text-3" id="text-h:ac889a76-1092-449e-a184-9092093f3103">
<p>
I could not find any built-in method of <i>reliably</i> moving back to the
last change.  Using the mark ring is always an option, but does not fill
the exact same niche.
</p>

<p>
The <code>C-z</code> binding is <a href="#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb">disabled elsewhere in this document</a>.  It minimises
the Emacs GUI by default.  A complete waste of an extremely valuable key
binding!
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Go to last change
(prot-emacs-elpa-package 'goto-last-change
  (define-key global-map (kbd "C-z") #'goto-last-change))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:39f57b0d-300a-4310-9ba8-8c388fa72e1d" class="outline-3">
<h3 id="h:39f57b0d-300a-4310-9ba8-8c388fa72e1d"><span class="section-number-3">6.2.</span> Mode line</h3>
<div class="outline-text-3" id="text-h:39f57b0d-300a-4310-9ba8-8c388fa72e1d">
<p>
The mode line is an integral part of the Emacs interface.  While there
are lots of third party packages that style it in a variety of ways, I
find the default to be "good enough".
</p>

<p>
In the code snippet right below I reshuffle some of the mode line
indicators.  Nothing too fancy.  The <code>mode-line-defining-kbd-macro</code> is
tweaked to use a more appropriate string for its indicator and to apply
colours that are designed specifically for the mode line (the default
uses the generic font-lock warning face).
</p>

<p>
Note that in <a href="#h:77d14350-978d-4820-ab7f-4641706c445a">Custom extensions for "focus mode" (prot-logos.el)</a> I
provide a snippet that optionally toggles the visibility of the modeline
while entering a bespoke "focus mode" for writing/reading.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Mode line
(setq mode-line-percent-position '(-3 "%p"))
(setq mode-line-position-column-line-format '(" %l,%c")) ; Emacs 28
(setq mode-line-defining-kbd-macro
      (propertize " Macro" 'face 'mode-line-emphasis))

;; Thanks to Daniel Mendler for this!  It removes the square brackets
;; that denote recursive edits in the modeline.  I do not need them
;; because I am using Daniel's `recursion-indicator':
;; &lt;https://github.com/minad/recursion-indicator&gt;.
(setq-default mode-line-modes
              (seq-filter (lambda (s)
                            (not (and (stringp s)
                                      (string-match-p
                                       "^\\(%\\[\\|%\\]\\)$" s))))
                          mode-line-modes))

(setq mode-line-compact nil)            ; Emacs 28
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                mode-line-frame-identification
                mode-line-buffer-identification
                "  "
                mode-line-position
                mode-line-modes
                "  "
                (vc-mode vc-mode)
                "  "
                mode-line-misc-info
                mode-line-end-spaces))
</pre>
</div>

<p>
In the following sub-sections I provide customisations for some tools
that place information on the mode line.  Again, nothing flamboyant.
</p>
</div>

<div id="outline-container-h:c07b9dfc-14a2-41a6-9310-53539dec8684" class="outline-4">
<h4 id="h:c07b9dfc-14a2-41a6-9310-53539dec8684"><span class="section-number-4">6.2.1.</span> Moody.el (simple mode line configuration utility)</h4>
<div class="outline-text-4" id="text-h:c07b9dfc-14a2-41a6-9310-53539dec8684">
<p>
<code>moody.el</code> is a lightweight library that adds some flair to the mode line
without complicating things.  It is developed by Jonas Bernoulli.  I
have been using it on and off to make sure that it works well with my
themes (see <a href="#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">Modus themes (my highly accessible themes)</a>).
</p>

<p>
My fairly minor tweaks in <code>prot-moody.el</code> (reproduced further below) align
Moody with my <a href="#h:e03b6415-a18f-4058-b9b0-5721d38c6c50">Font configurations (prot-fonts.el)</a>.  What I basically
want is to make the mode line gracefully adapt to changes in font size.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Moody.el (simple mode line configuration utility)
(prot-emacs-elpa-package 'moody)

(prot-emacs-builtin-package 'prot-moody
  ;; Adjust this and then evaluate `prot-moody-set-height'.  Not all
  ;; fonts work equally well with the same value.
  (setq prot-moody-font-height-multiplier 1.35)

  ;; Also check the Modus themes' `modus-themes-mode-line' which can set
  ;; the styles specifically for Moody.
  (prot-moody-set-height -1))
</pre>
</div>

<p>
Here are my tweaks (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-moody.el --- Extensions to moody.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my moody.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)
(require 'prot-fonts)
(require 'moody nil t)

(defgroup prot-moody ()
  "Tweaks for moody.el."
  :group 'mode-line)

(defcustom prot-moody-font-height-multiplier 1.65
  "Multiple of the font size to derive the moody height."
  :type 'number
  :group 'prot-moody)

(defun prot-moody--height ()
  "Set Moody height to an even number.
Bind this to a hook that gets called after loading/changing the
mode line's typeface (or the default one if they are the same)."
  (let* ((font (face-font 'mode-line))
         (height (truncate (* prot-moody-font-height-multiplier (aref (font-info font) 2))))
         (height-even (if (prot-common-number-even-p height) height (+ height 1))))
    (if font
        height-even
      24)))

(defvar moody-mode-line-height)

(defun prot-moody--mode-line-height ()
  "Set Moody height to the value of `prot-moody--height'."
  (let ((height (prot-moody--height)))
    (setq moody-mode-line-height height)))

(autoload 'moody-replace-mode-line-buffer-identification "moody")
(autoload 'moody-replace-vc-mode "moody")

;;;###autoload
(define-minor-mode prot-moody-set-height
  "Toggle Moody for the mode line and configure its fonts."
  :init-value nil
  :global t
  (if prot-moody-set-height
      (progn
        (moody-replace-mode-line-buffer-identification)
        (moody-replace-vc-mode)
        (add-hook 'prot-fonts-set-typeface-hook #'prot-moody--mode-line-height)
        (run-hooks 'prot-fonts-set-typeface-hook))
    (let ((format (default-value 'mode-line-format)))
      (when (member 'moody-mode-line-buffer-identification format)
        (moody-replace-mode-line-buffer-identification 'reverse))
      (when (member '(vc-mode moody-vc-mode) format)
        (moody-replace-vc-mode 'reverse)))
    (remove-hook 'prot-fonts-set-typeface-hook #'prot-moody--mode-line-height)))

(defvar keycast-insert-after)

(defun prot-moody-keycast-insert-after ()
  "Specify `keycast-insert-after' buffer identification."
  (setq keycast-insert-after
        (if prot-moody-set-height
            'moody-mode-line-buffer-identification
          'mode-line-buffer-identification)))

(provide 'prot-moody)
;;; prot-moody.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:b31005e3-c475-4be9-87fd-85b404550d8c" class="outline-4">
<h4 id="h:b31005e3-c475-4be9-87fd-85b404550d8c"><span class="section-number-4">6.2.2.</span> Hide modeline "lighters" (minions.el)</h4>
<div class="outline-text-4" id="text-h:b31005e3-c475-4be9-87fd-85b404550d8c">
<p>
This package by Jonas Bernoulli neatly wraps up all minor mode
"lighters" and hides them behind a single character.  The "lighter" is
the text that identifies the minor mode on the mode line.  Having a
few of them is usually okay, but a lot of them do not scale well.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Hide modeline "lighters" (minions.el)
(prot-emacs-elpa-package 'minions
  (setq minions-mode-line-lighter ";")
  ;; NOTE: This will be expanded whenever I find a mode that should not
  ;; be hidden
  (setq minions-prominent-modes
        (list 'defining-kbd-macro
              'flymake-mode
              'prot-simple-monocle))
  (minions-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b" class="outline-4">
<h4 id="h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b"><span class="section-number-4">6.2.3.</span> Mode line recursion indicators</h4>
<div class="outline-text-4" id="text-h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b">
<p>
This utility by Daniel Mendler provides a couple of indicators for
denoting minibuffer recursion.  They offer a reminder that we are in the
midst of a recursive editing session when we should, perhaps, not be in
one.  I consider <code>recursion-indicator</code> complementary to what is already
built into Emacs in the form of <code>minibuffer-depth-indicate-mode</code> which
shows the level of recursion at the current minibuffer prompt (refer to
<a href="#h:c110e399-3f43-4555-8427-b1afe44c0779">Minibuffer configurations and my extras (mct.el)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Mode line recursion indicators
(prot-emacs-elpa-package 'recursion-indicator
  (setq recursion-indicator-general "&amp;")
  (setq recursion-indicator-minibuffer "@")
  (recursion-indicator-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:da14ac1d-a06f-4531-b6c3-0414e8c98102" class="outline-4">
<h4 id="h:da14ac1d-a06f-4531-b6c3-0414e8c98102"><span class="section-number-4">6.2.4.</span> Display current time (and <code>world-clock</code>)</h4>
<div class="outline-text-4" id="text-h:da14ac1d-a06f-4531-b6c3-0414e8c98102">
<p>
I normally use Emacs in fullscreen view.  No system panels, no window
decorations, no icons and blinking indicators.  Nothing to distract me.
While I really like this immersive experience, sometimes I need to take
a look at the time&#x2026;  Thankfully Emacs offers a convenient, built-in
way of displaying such information in the mode line: just enable
<code>display-time-mode</code>.
</p>

<p>
The <code>display-time-format</code> can be configured to show the current date and
time in all the various formats we would expect, using a string of
specifiers (find the docs with <code>C-h v format-time-string</code>).  Setting its
value to <code>nil</code> means that the information on display will be the combined
result of <code>display-time-24hr-format</code> and <code>display-time-day-and-date</code>.  I
prefer to just write a string directly, keeping those two inactive.
</p>

<p>
The <code>display-time-mode</code> can output more than just the current time.  It
also shows the load average and an email indicator.  I do not need the
load average as it adds too much noise.  As for the mail indicator, I
used it for a while, but eventually decided to use my own approach which
also shows the number of new emails (refer to the <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">Email settings</a> and
search, in particular, for either the old <code>prot-mail-mail-indicator</code> or
the newer <code>prot-notmuch-mail-indicator</code>).
</p>

<p>
Since the inception of <code>prot-tab.el</code> which creates a status line that
replaces mode lines, I enable the clock and mail indicator only when the
status line is enabled (see <a href="#h:63ad472f-c9c2-40ad-9675-1dc529487788">Tabs for window layouts</a>).
</p>

<p>
Lastly, I use the <code>world-clock</code> command (for Emacs28+) when I need to get
an overview of the current time in various parts of the planet.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Display current time
(prot-emacs-builtin-package 'time
  (setq display-time-format "%a %e %b, %H:%M")
  ;;;; Covered by `display-time-format'
  ;; (setq display-time-24hr-format t)
  ;; (setq display-time-day-and-date t)
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)
  ;; NOTE 2021-04-19: For all those, I have implemented a custom
  ;; solution that also shows the number of new items.  Refer to my
  ;; email settings, specifically `prot-mail-mail-indicator'.
  ;;
  ;; NOTE 2021-05-16: Or better check `prot-notmuch-mail-indicator'.
  (setq display-time-mail-directory nil)
  (setq display-time-mail-function nil)
  (setq display-time-use-mail-icon nil)
  (setq display-time-mail-string nil)
  (setq display-time-mail-face nil)

;;; World clock
  (setq zoneinfo-style-world-list
        '(("America/Los_Angeles" "Los Angeles")
          ("America/Chicago" "Chicago")
          ("Brazil/Acre" "Rio Branco")
          ("America/New_York" "New York")
          ("Brazil/East" "Brasília")
          ("Europe/Lisbon" "Lisbon")
          ("Europe/Brussels" "Brussels")
          ("Europe/Athens" "Athens")
          ("Asia/Tehran" "Tehran")
          ("Asia/Tbilisi" "Tbilisi")
          ("Asia/Yekaterinburg" "Yekaterinburg")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Tokyo" "Tokyo")
          ("Asia/Vladivostok" "Vladivostok")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z  %A %d %B")
  (setq world-clock-buffer-name "*world-clock*") ; Placement handled by `display-buffer-alist'
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60)

  ;; ;; NOTE 2021-10-04: Check `prot-tab-status-line'.
  ;; (add-hook 'after-init-hook #'display-time-mode)
  )
</pre>
</div>
</div>
</div>

<div id="outline-container-h:e8e51a73-e583-4250-ac26-15627cd93932" class="outline-4">
<h4 id="h:e8e51a73-e583-4250-ac26-15627cd93932"><span class="section-number-4">6.2.5.</span> Keycast mode</h4>
<div class="outline-text-4" id="text-h:e8e51a73-e583-4250-ac26-15627cd93932">
<p>
Once enabled, this package uses the mode line to show the keys being
pressed and the command they call.  It is quite useful for screen
casting.
</p>

<p>
The placement of the indicator is controlled by <code>keycast-window-predicate</code>
which I set to the current window.  The <code>moody.el</code> library offers that
specific piece of functionality (though <a href="#h:c07b9dfc-14a2-41a6-9310-53539dec8684">I also configure Moody</a> for its
primary purpose of styling the mode line).
</p>

<p>
The tweaks to the <code>keycast-substitute-alist</code> prevent the display of
self-inserting characters and some other commands that are not
particularly useful while screen casting.  Now the indicator will only
show commands, which looks cleaner.  I got the idea and original piece
of Elisp from the <a href="https://github.com/aadcg/dotfiles">dotfiles of André Alexandre Gomes</a> and then added a few
tweaks of my own.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Keycast mode
(prot-emacs-elpa-package 'keycast
  ;; Those are for `keycast-mode'
  (setq keycast-window-predicate 'moody-window-active-p) ; assumes `moody.el'
  (setq keycast-separator-width 1)
  (setq keycast-remove-tail-elements nil)

  (dolist (input '(self-insert-command
                   org-self-insert-command))
    (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

  (dolist (event '(mouse-event-p
                   mouse-movement-p
                   mwheel-scroll))
    (add-to-list 'keycast-substitute-alist `(,event nil)))

  ;; Those are for the `keycast-log-mode'
  (setq keycast-log-format "%-20K%C\n")
  (setq keycast-log-frame-alist
        '((minibuffer . nil)))
  (setq keycast-log-newest-first t)

  ;; Specify `keycast-insert-after' buffer identification.  This make it
  ;; possible to seamlessly toggle `prot-moody-set-height' without
  ;; disrupting keycast.
  (with-eval-after-load 'prot-moody
    (add-hook 'prot-moody-set-height-hook #'prot-moody-keycast-insert-after)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b" class="outline-3">
<h3 id="h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b"><span class="section-number-3">6.3.</span> Window divider mode</h3>
<div class="outline-text-3" id="text-h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b">
<p>
This is a built-in mode that can draw both vertical and horizontal
borders.  It can be particularly helpful when used with windows that do
not have a modeline, such as what happens when I enable my custom
<code>prot-tab-status-line</code> on Emacs28, which moves all the relevant
information to the tab bar (in effect, it creates a universal status
line&#x2014;see <a href="#h:63ad472f-c9c2-40ad-9675-1dc529487788">Tabs for window layouts (tab-bar.el and prot-tab.el)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Window divider mode
(setq window-divider-default-right-width 1)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-places 'right-only)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:26a4fac6-33e2-4f6c-8589-9463df8525c9" class="outline-3">
<h3 id="h:26a4fac6-33e2-4f6c-8589-9463df8525c9"><span class="section-number-3">6.4.</span> Fringe mode</h3>
<div class="outline-text-3" id="text-h:26a4fac6-33e2-4f6c-8589-9463df8525c9">
<p>
The fringes are areas to the right and left side of an Emacs frame.
They can be used to show status-related or contextual feedback such as
line truncation indicators, continuation lines, code linting markers,
etc.
</p>

<p>
The default fringe width (<code>nil</code>) is 8 pixels on either side, which I
approve of.  It is possible to set the value of the <code>fringe-mode</code> to
something like <code>'(10 . 5)</code> which applies the varied width to the left and
right side respectively.  Otherwise, we can use a single integer that
controls both sides.
</p>

<p>
The use of <code>setq-default</code> is necessary, otherwise these values become
buffer-local.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Fringe mode
(prot-emacs-builtin-package 'fringe
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:755d055b-ef80-4f63-af08-ce9e931de30c" class="outline-3">
<h3 id="h:755d055b-ef80-4f63-af08-ce9e931de30c"><span class="section-number-3">6.5.</span> Color tools (ct.el)</h3>
<div class="outline-text-3" id="text-h:755d055b-ef80-4f63-af08-ce9e931de30c">
<p>
The <code>ct.el</code> library by Github user "neeasade" provides various utilities
for testing colour values across several spaces.  The developer also has
an interesting article on the matter: <a href="https://notes.neeasade.net/color-spaces.html">Reasoning about Colors</a>.  I may
need some of those tools while developing my Modus themes.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Color tools (ct.el)
(prot-emacs-elpa-package 'ct)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:9061c694-5f45-46b0-a878-6bcfb018e18d" class="outline-3">
<h3 id="h:9061c694-5f45-46b0-a878-6bcfb018e18d"><span class="section-number-3">6.6.</span> Rainbow mode for colour previewing (rainbow-mode.el)</h3>
<div class="outline-text-3" id="text-h:9061c694-5f45-46b0-a878-6bcfb018e18d">
<p>
The following package reads a colour value, such as hexadecimal RGB,
and sets the background for the value in that colour.  Quite useful
when reviewing my themes (<code>rainbow-mode</code> is activated manually).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Rainbow mode for colour previewing (rainbow-mode.el)
(prot-emacs-elpa-package 'rainbow-mode
  (setq rainbow-ansi-colors nil)
  (setq rainbow-x-colors nil))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:6478350b-b89b-406e-9b08-2dc9e93cc5b4" class="outline-3">
<h3 id="h:6478350b-b89b-406e-9b08-2dc9e93cc5b4"><span class="section-number-3">6.7.</span> Depth-based code colourisation (prism.el)</h3>
<div class="outline-text-3" id="text-h:6478350b-b89b-406e-9b08-2dc9e93cc5b4">
<p>
Adam Porter's (aka alphapapa) <code>prism.el</code> colourises programming code based
on the level of depth, rather than targeting syntactic constructs like
keywords, strings, variables.  This can be useful when working with
highly-nested and/or unfamiliar code.  It has two modes that are
intended for specific types of programming languages:
</p>

<ol class="org-ol">
<li><code>prism-mode</code> is good for Lisp and languages that look like C (I only
code in Elisp);</li>
<li><code>prism-whitespace-mode</code> is for languages that are more sensitive to
indentation.</li>
</ol>

<p>
The degree of colouration for each level of depth is configurable, as
are the colours to be used.  Consult Prism's documentation for the
technicalities.
</p>

<p>
My <code>prot-prism.el</code> (reproduced after the following configurations)
provides a few extras that help me set the desired style of colouration.
It provides an alist of palette presets.  Those can be applied through
minibuffer completion with the command <code>prot-prism-set-colors</code>.  All the
presets are designed to extract colour values from the active Modus
theme (<a href="#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6">Modus themes (my highly accessible themes)</a>).  Those range from a
minimalist style of drawing only four colours, to a more expansive
sixteen-colour gamout.
</p>

<p>
The <code>prot-prism-set-colors</code> command also takes care to activate the
appropriate Prism mode for languages whose major mode is declared as
"indentation-sensitive".  Those are added as a list to the variable
<code>prot-prism-negative-space-sensitive-modes</code>.
</p>

<p>
To disable the effect, just do <code>M-x prot-prism-disable</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Depth-based code colourisation (prism.el)
(prot-emacs-elpa-package 'prism
  (setq prism-comments t))

(prot-emacs-builtin-package 'prot-prism
  (setq prot-prism-negative-space-sensitive-modes
        '(sh-mode yaml-mode))

  (setq prot-prism-presets-function #'prot-prism--colors))
</pre>
</div>

<p>
Here are my tweaks (from <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-prism.el --- Tweaks for prism.el -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Tweaks for the `prism.el' library of Adam Porter (alphapapa).
;; Intended for my Emacs setup: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prism nil t)
(require 'modus-themes nil t)

(defgroup prot-prism ()
  "Tweaks for cursor appearance."
  :group 'faces)

(declare-function modus-themes-with-colors "modus-themes" (&amp;rest body))

(defcustom prot-prism-negative-space-sensitive-modes '(sh-mode yaml-mode)
  "Modes where negative space or indentation indicates depth."
  :type '(repeat symbol)
  :group 'prot-prism)

(defcustom prot-prism-presets-function #'prot-prism--colors
  "Function that returns alist of style presets.
The car of the alist is a number, indicating `prism-num-faces'.
The cdr is a list of strings that represent color names or
values.  The latter use hexadecimal RGB notation."
  :type 'symbol
  :group 'prot-prism)

(defun prot-prism--colors ()
  "Return alist with color presets.
See `prot-prism-presets-function'."
  ;; NOTE 2021-09-18: The `modus-themes-with-colors' is documented at
  ;; length in the themes' manual.
  (modus-themes-with-colors
    `(("4"  . ,(list blue
                     magenta
                     magenta-alt-other
                     green-alt))
      ("8"  . ,(list blue
                     magenta
                     magenta-alt-other
                     cyan-alt-other
                     fg-main
                     blue-alt
                     red-alt-other
                     cyan))
      ("16" . ,(list fg-main
                     magenta
                     cyan-alt-other
                     magenta-alt-other
                     blue
                     magenta-alt
                     cyan-alt
                     red-alt-other
                     green
                     fg-main
                     cyan
                     yellow
                     blue-alt
                     red-alt
                     green-alt-other
                     fg-special-warm)))))

(add-hook 'modus-themes-after-load-theme-hook #'prot-prism--colors)

(defvar prot-prism--preset-hist '()
  "Minibuffer history for `prot-prism-set-colors'.")

(defun prot-prism--set-colors-prompt ()
  "Helper prompt for `prot-prism-set-colors'."
  (let* ((hist prot-prism--preset-hist)
         (default (when hist (nth 0 hist))))
    (completing-read
     (format "Outline style [%s]: " default)
     (mapcar #'car (funcall prot-prism-presets-function))
     nil t nil 'prot-prism--preset-hist default)))

(autoload 'prism-set-colors "prism")
(defvar prism-num-faces)
(declare-function prism-mode "prism")
(declare-function prism-whitespace-mode "prism")

;;;###autoload
(defun prot-prism-set-colors (preset)
  "Set prism colors to PRESET in `prot-prism-presets-function'."
  (interactive (list (prot-prism--set-colors-prompt)))
  (let* ((alist (funcall prot-prism-presets-function))
         (num (car (assoc preset alist)))
         (colors (cdr (assoc preset alist))))
    (setq prism-num-faces (string-to-number num))
    (prism-set-colors
      :desaturations '(0) ; do not change---may lower the contrast ratio
      :lightens '(0)      ; same
      :colors colors)
    (if (member major-mode prot-prism-negative-space-sensitive-modes)
        (prism-whitespace-mode 1)
      (prism-mode 1))
    (add-to-history 'prot-prism--preset-hist num)))

;;;###autoload
(defun prot-prism-disable ()
  "Disable Prism coloration."
  (interactive)
  (if (or (member major-mode prot-prism-negative-space-sensitive-modes)
          (bound-and-true-p prism-whitespace-mode))
      (prism-whitespace-mode -1)
    (prism-mode -1)))

(provide 'prot-prism)
;;; prot-prism.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:cb76fcee-e304-4b86-a764-6c3c6775da51" class="outline-3">
<h3 id="h:cb76fcee-e304-4b86-a764-6c3c6775da51"><span class="section-number-3">6.8.</span> Line numbers and relevant indicators (prot-sideline.el)</h3>
<div class="outline-text-3" id="text-h:cb76fcee-e304-4b86-a764-6c3c6775da51">
<p>
<code>prot-sideline.el</code> (reproduced after the package configurations) is a set
of simplete-minded features:
</p>

<ol class="org-ol">
<li>It bundles up together three distinct visual elements as part of a
common minor mode: <code>prot-sideline-mode</code>.  Its constituents are current
line highlighting (<code>hl-line-mode</code>), diff indicators (<code>diff-hl-mode</code>), and
line numbers (<code>display-line-numbers-mode</code>).  Line numbers and line
highlighting are built into Emacs.</li>

<li>A simple toggle for <code>whitespace-mode</code>, which I only ever use to double
check some area's indentation or to confirm that no newline is
missing at the end of the file.</li>
</ol>

<p>
Note that the <code>diff-hl</code> package offers some more features other than the
obvious colour-coded highlighting of changes, such as the ability to
move between diff hunks (with <code>C-x v [</code> and <code>C-x v ]</code>) or to revert the
current hunk (<code>C-x v n</code>).  Those can come in handy (check my comprehensive
extensions in <a href="#h:31deeff4-dfae-48d9-a906-1f3272f29bc9">Version control framework (vc.el and prot-vc.el)</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Line numbers and relevant indicators (prot-sideline.el)
(prot-emacs-builtin-package 'prot-sideline
  (require 'display-line-numbers)
  ;; Set absolute line numbers.  A value of "relative" is also useful.
  (setq display-line-numbers-type t)
  ;; Those two variables were introduced in Emacs 27.1
  (setq display-line-numbers-major-tick 0)
  (setq display-line-numbers-minor-tick 0)
  ;; Use absolute numbers in narrowed buffers
  (setq-default display-line-numbers-widen t)

  (prot-emacs-elpa-package 'diff-hl
    (setq diff-hl-draw-borders nil)
    (setq diff-hl-side 'left))

  (require 'hl-line)
  (setq hl-line-sticky-flag nil)
  (setq hl-line-overlay-priority -50) ; emacs28

  (require 'whitespace)

  (let ((map global-map))
    (define-key map (kbd "&lt;f6&gt;") #'prot-sideline-negative-space-toggle)
    (define-key map (kbd "&lt;f7&gt;") #'prot-sideline-mode)
    (define-key map (kbd "C-c z") #'delete-trailing-whitespace)))
</pre>
</div>

<p>
This is <code>prot-sideline.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-sideline.el --- Extensions for line numbers and relevant indicators -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for line numbers and relevant indicators, intended to be
;; used as part of my Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-sideline ()
  "Setup for reading and presenting text-heavy buffers."
  :group 'files)

;;;###autoload
(define-minor-mode prot-sideline-mode
  "Buffer-local wrapper mode for presentations."
  :init-value nil
  :global nil)

(autoload 'diff-hl-mode "diff-hl")

(defun prot-sideline--diff-hl-toggle ()
  "Toggle buffer local diff indicators in the fringe."
  (if (or (bound-and-true-p diff-hl-mode)
          (not (bound-and-true-p prot-sideline-mode)))
      (diff-hl-mode -1)
    (diff-hl-mode 1)))

(add-hook 'prot-sideline-mode-hook #'prot-sideline--diff-hl-toggle)

(defun prot-sideline--numbers-toggle ()
  "Toggle line numbers."
  (if (or (bound-and-true-p display-line-numbers-mode)
          (not (bound-and-true-p prot-sideline-mode)))
      (display-line-numbers-mode -1)
    (display-line-numbers-mode 1)))

(add-hook 'prot-sideline-mode-hook #'prot-sideline--numbers-toggle)

(defun prot-sideline--hl-line-toggle ()
  "Toggle line highlight."
  (if (or (bound-and-true-p hl-line-mode)
          (not (bound-and-true-p prot-sideline-mode)))
      (hl-line-mode -1)
    (hl-line-mode 1)))

(add-hook 'prot-sideline-mode-hook #'prot-sideline--hl-line-toggle)

(autoload 'whitespace-mode "whitespace")

;; We keep this separate, as I do not want it bundled up together with
;; the rest of the functionality included here.
;;;###autoload
(defun prot-sideline-negative-space-toggle ()
  "Toggle the display of indentation and space characters."
  (interactive)
  (if (bound-and-true-p whitespace-mode)
      (whitespace-mode -1)
    (whitespace-mode)))

(provide 'prot-sideline)
;;; prot-sideline.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:a8e737b8-7c90-4c68-8814-acf2f637ffa1" class="outline-3">
<h3 id="h:a8e737b8-7c90-4c68-8814-acf2f637ffa1"><span class="section-number-3">6.9.</span> Outline mode, outline minor mode, and extras (prot-outline.el)</h3>
<div class="outline-text-3" id="text-h:a8e737b8-7c90-4c68-8814-acf2f637ffa1">
<p>
The <code>outline.el</code> library defines a major mode (<code>outline-mode</code>) that is
similar to <code>org-mode</code> in that it consists of headings which can be
expanded or contracted individually or as a group (actually Outline
predates Org).  The major mode is meant to work with plain text files,
or be leveraged by other packages that need to have some structure and
the accompanying benefits of outline folding.  In practice, however, I
never found a dedicated use for it that would justify it over the more
featureful Org.
</p>

<p>
Where <code>outline.el</code> truly shines, in my experience, is in the minor mode it
defines (<code>outline-minor-mode</code>), which provides the familiar structured,
heading-folding facilities in other major modes, like <code>emacs-lisp-mode</code> or
any arbitrary mode, like <code>diff-mode</code> and the <code>diary</code>.
</p>

<p>
Also read:
</p>

<ul class="org-ul">
<li><a href="#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9">Calendar and Diary (and prot-diary.el)</a>.</li>
<li><a href="#h:2ff46d23-09d5-4d92-b0af-2339dc19719f">Diff-mode (and prot-diff.el extensions)</a>.</li>
</ul>

<p>
With some careful tweaks you can continue to work on your code while
also benefitting from a more effective means of organising and reviewing
what you have.
</p>

<p>
In practice, to make an outline for Elisp buffers, you need to start a
comment line <i>without leading spaces</i> and make it at least three comment
delimiters long (<code>;;;</code>) followed by a space and then the text of the
heading, such as <code>;;; Code:</code>.  That is considered a heading level 1.
Every extra delimiter will increase heading levels accordingly.  The
buffer-local variable <code>outline-regexp</code> determines what constitutes a
heading for this purpose.
</p>

<p>
Now on to my custom library, <code>prot-outline.el</code> which builds on those
concepts:
</p>

<ul class="org-ul">
<li>Provide several new commands and minor extras for working with
outlines.</li>

<li>Define a <code>prot-outline-minor-mode-safe</code> command that checks whether the
current buffer's major mode is not a member of a blocklist.  The idea
is to not run <code>outline-minor-mode</code> with major modes that already provide
its functionality: <code>org-mode</code>, <code>outline-mode</code>, <code>markdown-mode</code>.</li>
</ul>

<p>
Watch my <a href="https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/">video demo of outline-minor-mode and imenu</a> (2020-07-20), though
note that it was recorded long before I wrote <code>prot-outline.el</code>.  In
particular, older versions of my code would establish bindings for
<code>imenu.el</code>.  This was done via bespoke entry and exit hooks and was
intended to complement the standard Imenu headings with those of the
Outline.  This is no longer needed because <code>consult-outline</code> does exactly
that (<a href="#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb">Enhanced minibuffer commands (consult.el and prot-consult.el)</a>).  A
quick reminder of why this matters: you can navigate the outline using
minibuffer completion, which is my favourite way to browse a file.  You
can, in the same spirit, use Embark to produce a buffer with the
completion candidates, i.e. the headings, or a subset you have narrowed
to, and navigate therefrom.  It really is an efficient workflow:
<a href="#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984">Extended minibuffer actions and more (embark.el and prot-embark.el)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Outline mode, outline minor mode, and extras (prot-outline.el)
(prot-emacs-builtin-package 'outline
  (setq outline-minor-mode-highlight 'override) ; emacs28
  (setq outline-minor-mode-cycle t)             ; emacs28
  (let ((map outline-minor-mode-map))
    ;; ;; NOTE 2021-07-25: Those two are already defined (emacs28).
    ;; (define-key map (kbd "TAB") #'outline-cycle)
    ;; (define-key map (kbd "&lt;backtab&gt;") #'outline-cycle-buffer) ; S-TAB
    (define-key map (kbd "C-c C-n") #'outline-next-visible-heading)
    (define-key map (kbd "C-c C-p") #'outline-previous-visible-heading)
    (define-key map (kbd "C-c C-f") #'outline-forward-same-level)
    (define-key map (kbd "C-c C-b") #'outline-backward-same-level)
    (define-key map (kbd "C-c C-a") #'outline-show-all)
    (define-key map (kbd "C-c C-o") #'outline-hide-other)
    (define-key map (kbd "C-c C-u") #'outline-up-heading)))

(prot-emacs-builtin-package 'prot-outline
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-c C-v") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "M-&lt;down&gt;") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "C-c M-v") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "M-&lt;up&gt;") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "C-x n s") #'prot-outline-narrow-to-subtree))
  (define-key global-map (kbd "&lt;f10&gt;") #'prot-outline-minor-mode-safe))
</pre>
</div>

<p>
These are the contents of the <code>prot-outline.el</code> library (find the file in
<a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (as with all my Elisp code)):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-outline.el --- Extend outline.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions to the built-in `outline.el' library for my Emacs
;; configuration: &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'outline)
(require 'prot-common)

(defgroup prot-outline ()
  "Tweaks for Outline mode."
  :group 'outline)

;;;; Commands

;;;###autoload
(defun prot-outline-move-major-heading-down (&amp;optional arg)
  "Move Outline major heading down one or, optionally, ARG times.
A major heading is one that has subheadings."
  (interactive "p")
  (if (or (and (outline-on-heading-p) (outline-has-subheading-p))
          (outline-invisible-p))
      (outline-move-subtree-down (or arg 1))
    (forward-line (or arg 1))))

;;;###autoload
(defun prot-outline-move-major-heading-up (&amp;optional arg)
  "Move Outline major heading up one or, optionally, ARG times.
A major heading is one that has subheadings."
  (interactive "p")
  (if (or (and (outline-on-heading-p) (outline-has-subheading-p))
          (outline-invisible-p))
      (outline-move-subtree-up (or arg 1))
    (forward-line (- (or arg 1)))))

;;;###autoload
(defun prot-outline-narrow-to-subtree ()
  "Narrow to current Outline subtree."
  (interactive)
  (let ((start)
        (end)
        (point (point)))
    (when (and (prot-common-line-regexp-p 'empty)
               (not (eobp)))
      (forward-char 1))
    (when (or (outline-up-heading 1)
              (outline-back-to-heading))
      (setq start (point)))
    (if (outline-get-next-sibling)
        (forward-line -1)
      (goto-char (point-max)))
    (setq end (point))
    (narrow-to-region start end)
    (goto-char point)))

;;;; Minor mode setup

(defcustom prot-outline-headings-per-mode
  '((emacs-lisp-mode . ";\\{3,\\}+ [^\n]"))
  "Alist of major modes with `outline-regexp' values."
  :type '(alist :key-type symbol :value-type string)
  :group 'prot-outline)

(defcustom prot-outline-major-modes-blocklist
  '(org-mode outline-mode markdown-mode)
  "Major modes where Outline-minor-mode should not be enabled."
  :type '(repeat symbol)
  :group 'prot-outline)

;;;###autoload
(defun prot-outline-minor-mode-safe ()
  "Test to set variable `outline-minor-mode' to non-nil."
  (interactive)
  (let* ((blocklist prot-outline-major-modes-blocklist)
         (mode major-mode)
         (headings (alist-get mode prot-outline-headings-per-mode)))
    (when (derived-mode-p (car (member mode blocklist)))
      (error "Don't use `prot-outline-minor-mode' with `%s'" mode))
    (if (null outline-minor-mode)
        (progn
          (when (derived-mode-p mode)
            (setq-local outline-regexp headings))
          (outline-minor-mode 1)
          (message "Enabled `outline-minor-mode'"))
      (outline-minor-mode -1)
      (message "Disabled `outline-minor-mode'"))))

(provide 'prot-outline)
;;; prot-outline.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820" class="outline-3">
<h3 id="h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820"><span class="section-number-3">6.10.</span> Cursor and mouse settings</h3>
<div class="outline-text-3" id="text-h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820">
</div>
<div id="outline-container-h:cf9086c1-1b33-4127-a716-de94259e14a0" class="outline-4">
<h4 id="h:cf9086c1-1b33-4127-a716-de94259e14a0"><span class="section-number-4">6.10.1.</span> Cursor appearance and tweaks (prot-cursor.el)</h4>
<div class="outline-text-4" id="text-h:cf9086c1-1b33-4127-a716-de94259e14a0">
<p>
<code>prot-cursor.el</code> defines a set of presets that control the overall style
of the cursor.  There presuppose the <code>blink-cursor-mode</code>.  The properties
we pass to those presets mirror those we can pass for the various
built-in variables for the cursor.  Check the <code>prot-cursor.el</code> code, which
is reproduced right after the following package configurations.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Cursor appearance and tweaks (prot-cursor.el)
(prot-emacs-builtin-package 'prot-cursor
  (setq prot-cursor-presets
        '((bar . ( :cursor-type (bar . 2)
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (box . ( :cursor-type box
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (underscore . ( :cursor-type (hbar . 3)
                          :cursor-no-selected hollow
                          :blinks 50
                          :blink-interval 0.2
                          :blink-delay 0.2))))
  (setq prot-cursor-last-state-file
        (locate-user-emacs-file "prot-cursor-last-state"))

  (prot-cursor-restore-last-preset)

  ;; Sets my style on startup.
  (if prot-cursor--recovered-preset
      (prot-cursor-set-cursor prot-cursor--recovered-preset)
    (prot-cursor-set-cursor 'underscore))

  ;; The other side of `prot-cursor-restore-last-preset'.
  (add-hook 'kill-emacs-hook #'prot-cursor-store-last-preset)

  ;; We have to use the "point" mnemonic, because C-c c is for
  ;; `org-capture'.
  (define-key global-map (kbd "C-c p") #'prot-cursor-set-cursor))
</pre>
</div>

<p>
This is <code>prot-cursor.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-cursor.el --- Extensions for the cursor -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; Extensions for the cursor, intended for my Emacs setup:
;; &lt;https://protesilaos.com/emacs/dotemacs/&gt;.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-cursor ()
  "Tweaks for cursor appearance."
  :group 'cursor)

(defcustom prot-cursor-presets
  '((bar . ( :cursor-type (bar . 2)
             :cursor-no-selected hollow
             :blinks 10
             :blink-interval 0.5
             :blink-delay 0.2))

    (box  . ( :cursor-type box
              :cursor-no-selected hollow
              :blinks 10
              :blink-interval 0.5
              :blink-delay 0.2))

    (underscore . ( :cursor-type (hbar . 3)
                    :cursor-no-selected hollow
                    :blinks 50
                    :blink-interval 0.2
                    :blink-delay 0.2)))
  "Alist of desired typeface properties for Blink-cursor-mode.

The car of each cons cell is an arbitrary key that broadly
describes the display type.

The cdr is a plist that specifies the cursor type and blink
properties."
  :group 'prot-cursor
  :type 'alist)

(defcustom prot-cursor-last-state-file
  (locate-user-emacs-file "prot-cursor-last-state")
  "File to save the value of `prot-cursor-set-cursor'."
  :type 'file
  :group 'prot-cursor)

(defvar prot-cursor--style-hist '()
  "History of inputs for display-related font associations.")

(defun prot-cursor--set-cursor-prompt ()
  "Promp for font set (used by `prot-cursor-set-cursor')."
  (let ((def (nth 1 prot-cursor--style-hist)))
    (completing-read
     (format "Select cursor STYLE [%s]: " def)
     (mapcar #'car prot-cursor-presets)
     nil t nil 'prot-cursor--style-hist def)))

;;;###autoload
(defun prot-cursor-set-cursor (style)
  "Set cursor preset associated with STYLE.

STYLE is a symbol that represents the car of a cons cell in
`prot-cursor-presets'."
  (interactive (list (prot-cursor--set-cursor-prompt)))
  (when (or (eq style t) (null style))
    (setq style 'box))
  (let* ((styles (if (stringp style) (intern style) style))
         (properties (alist-get styles prot-cursor-presets))
         (type (plist-get properties :cursor-type))
         (type-no-select (plist-get properties :cursor-no-selected))
         (blinks (plist-get properties :blinks))
         (blink-interval (plist-get properties :blink-interval))
         (blink-delay (plist-get properties :blink-delay)))
    (setq-default cursor-type type
                  cursor-in-non-selected-windows type-no-select
                  blink-cursor-blinks blinks
                  blink-cursor-interval blink-interval
                  blink-cursor-delay blink-delay)
    (add-to-history 'prot-cursor--style-hist (format "%s" style))))

(defun prot-cursor-store-last-preset ()
  "Write latest cursor state to `prot-cursor-last-state-file'.
Can be assigned to `kill-emacs-hook'."
  (when prot-cursor--style-hist
    (with-temp-file prot-cursor-last-state-file
      (insert (concat ";; Auto-generated file;"
                      " don't edit -*- mode: lisp-data -*-\n"))
      (pp (intern (car prot-cursor--style-hist)) (current-buffer)))))

(defvar prot-cursor--recovered-preset nil
  "Recovered value of last store cursor preset.")

(defun prot-cursor-restore-last-preset ()
  "Restore last cursor style."
  (when-let ((file prot-cursor-last-state-file))
    (when (file-exists-p file)
      (setq prot-cursor--recovered-preset
            (unless (zerop
                     (or (file-attribute-size (file-attributes file))
                         0))
              (with-temp-buffer
                (insert-file-contents file)
                (read (current-buffer))))))))

(provide 'prot-cursor)
;;; prot-cursor.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:02572210-eb26-4941-8f7c-666a0314877b" class="outline-4">
<h4 id="h:02572210-eb26-4941-8f7c-666a0314877b"><span class="section-number-4">6.10.2.</span> Mouse wheel behaviour</h4>
<div class="outline-text-4" id="text-h:02572210-eb26-4941-8f7c-666a0314877b">
<p>
The value of <code>mouse-wheel-scroll-amount</code> means the following:
</p>

<ul class="org-ul">
<li>By default scroll by one line.</li>
<li>Hold down Shift to do so by five lines.</li>
<li>Hold down Meta to scroll half a screen.</li>
<li>Hold down Control to adjust the size of the text.  This was added in
Emacs 27.</li>
</ul>

<p>
The other options in short:
</p>

<ul class="org-ul">
<li>Hide mouse pointer while typing.</li>
<li>Enable mouse scroll.</li>
<li>Faster wheel movement means faster scroll.</li>
<li>Scroll window under mouse pointer regardless of whether it is the
current one or not.</li>
</ul>

<p>
Note that if we enable <code>mouse-drag-copy-region</code> we automatically place the
mouse selection to the kill ring.  This is the same behaviour as
terminal emulators that place the selection to the clipboard (or the
primary selection).  I choose not to use this here.
</p>

<p>
<code>tear-off-window</code> places the current window in a new frame.  On my generic
mouse, <code>&lt;mouse-3&gt;</code> is the right click.  Normally I call that command with
<code>M-x</code>, though it does not hurt to rely on the mouse from time to time.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Mouse wheel behaviour
(prot-emacs-builtin-package 'mouse
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 5)
          ((meta) . 0.5)
          ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-follow-mouse t)
  (add-hook 'after-init-hook #'mouse-wheel-mode)
  (define-key global-map (kbd "C-M-&lt;mouse-3&gt;") #'tear-off-window))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:0c44b318-813a-4f4a-b596-75df4a86476b" class="outline-4">
<h4 id="h:0c44b318-813a-4f4a-b596-75df4a86476b"><span class="section-number-4">6.10.3.</span> Scrolling behaviour</h4>
<div class="outline-text-4" id="text-h:0c44b318-813a-4f4a-b596-75df4a86476b">
<p>
By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.
</p>

<p>
As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following the point will stay at the top/bottom
of the screen while moving in that direction (use <code>C-l</code> to reposition it).
</p>

<p>
The <code>next-screen-context-lines</code> ensures that when moving by screenfulls
(with either <code>C-v</code> or <code>M-v</code>) we do not get any continuation lines from the
previous screen.  I find this more intuitive.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Scrolling behaviour
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default scroll-margin 0)
(setq-default next-screen-context-lines 0)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:d53b7b54-924a-443b-955a-3c5b222e3a90" class="outline-4">
<h4 id="h:d53b7b54-924a-443b-955a-3c5b222e3a90"><span class="section-number-4">6.10.4.</span> Delete selection</h4>
<div class="outline-text-4" id="text-h:d53b7b54-924a-443b-955a-3c5b222e3a90">
<p>
This is a very helpful mode.  It kills the marked region when inserting
directly to it.  It also has checks to ensure that yanking over a
selected region will not insert itself when <code>mouse-drag-copy-region</code> is in
effect (see the section on the <a href="#h:02572210-eb26-4941-8f7c-666a0314877b">mouse wheel behaviour</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Delete selection
(prot-emacs-builtin-package 'delsel
  (add-hook 'after-init-hook #'delete-selection-mode))
</pre>
</div>

<p>
<b>Pro tip</b>: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed.
</p>
</div>
</div>

<div id="outline-container-h:9f492949-70fb-4fba-a0ea-569d4a240be8" class="outline-4">
<h4 id="h:9f492949-70fb-4fba-a0ea-569d4a240be8"><span class="section-number-4">6.10.5.</span> Tooltips (tooltip-mode)</h4>
<div class="outline-text-4" id="text-h:9f492949-70fb-4fba-a0ea-569d4a240be8">
<p>
These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:
</p>

<ul class="org-ul">
<li>I just want to make sure that the GTK theme is <i>not used</i> for those: I
prefer the generic display which follows my current theme's styles.</li>
<li>The delay is slightly reduced for the initial pop-up, while it has
been increased for immediate pop-ups thereafter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Tooltips (tooltip-mode)
(prot-emacs-builtin-package 'tooltip
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  (add-hook 'after-init-hook #'tooltip-mode))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:aad79917-cd80-491b-9020-db27867ab132" class="outline-3">
<h3 id="h:aad79917-cd80-491b-9020-db27867ab132"><span class="section-number-3">6.11.</span> Dired-like list for registers (rlist)</h3>
<div class="outline-text-3" id="text-h:aad79917-cd80-491b-9020-db27867ab132">
<p>
This package by Sévère Durand implements a Dired-like interface for the
purpose of deleting an entry from the list.  I feel this is the one
major feature that is missing from the registers' toolkit: it provides
you with the means to remain in control of the data you accumulate in
those compartments, so nothing ever gets out of hand.
</p>

<p>
Note that this is a fairly new project (as of 2021-02-05), so things are
likely to change over the near term.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Dired-like list for registers (rlist)
;; Project repo: &lt;https://gitlab.com/mmemmew/rlist&gt;.  This is one of the
;; packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'rlist
  (setq rlist-expert t)
  (setq rlist-verbose t)
  (let ((map global-map))
    (define-key map (kbd "C-x r &lt;backspace&gt;") #'rlist-list-registers)
    (define-key map (kbd "C-x r &lt;delete&gt;") #'rlist-list-registers)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:271c9122-280b-424e-98f0-af9e4f09bbdb" class="outline-3">
<h3 id="h:271c9122-280b-424e-98f0-af9e4f09bbdb"><span class="section-number-3">6.12.</span> Conveniences and minor extras</h3>
<div class="outline-text-3" id="text-h:271c9122-280b-424e-98f0-af9e4f09bbdb">
</div>
<div id="outline-container-h:24c2ac42-a537-4658-8a08-9aebb0de1a73" class="outline-4">
<h4 id="h:24c2ac42-a537-4658-8a08-9aebb0de1a73"><span class="section-number-4">6.12.1.</span> Automatic time stamps for files (time-stamp.el)</h4>
<div class="outline-text-4" id="text-h:24c2ac42-a537-4658-8a08-9aebb0de1a73">
<p>
The built-in <code>time-stamp.el</code> provides the means to automatically update a
predefined header with the time its file was last edited/saved.  This
is, in my experience, particularly useful for packages that have a
stable version but also need to disambiguate their latest tagged release
from their current development state.
</p>

<p>
By default, this is done by checking the first eight lines of the file
for the <code>Time-stamp: &lt;&gt;</code> entry.  Though that is configurable.  To properly
utilise this library, you need to implement file-local variables.  Those
should control the exact format of the time stamp.  For examples, this
is what I have in my <code>modus-themes.el</code>:
</p>

<pre class="example" id="orgccd1429">
;; Local Variables:
;; time-stamp-start: "Last-Modified:[ \t]+\\\\?[\"&lt;]"
;; time-stamp-end: "\\\\?[\"&gt;]"
;; time-stamp-format: "%Y-%02m-%02d %02H:%02M:%02S %5z"
;; End:
</pre>

<p>
Check <code>M-x find-library RET time-stamp RET</code> for all variables you may want
to control.
</p>

<p>
All we do here is enable the package and add a hook to insert a time
stamp upon save, where relevant.  It works seamlessly.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Automatic time stamps for files (time-stamp.el)
(prot-emacs-builtin-package 'time-stamp
  (add-hook 'before-save-hook #'time-stamp))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:7a8422e6-86d1-40f3-add4-0a1c826e44a3" class="outline-4">
<h4 id="h:7a8422e6-86d1-40f3-add4-0a1c826e44a3"><span class="section-number-4">6.12.2.</span> Auto revert mode</h4>
<div class="outline-text-4" id="text-h:7a8422e6-86d1-40f3-add4-0a1c826e44a3">
<p>
This mode ensures that the buffer is updated whenever the file changes.
A change can happen externally or by some other tool inside of Emacs
(e.g. kill a Magit diff).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Auto revert mode
(prot-emacs-builtin-package 'autorevert
  (setq auto-revert-verbose t)
  (add-hook 'after-init-hook #'global-auto-revert-mode))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:9eae0d2a-eef1-4b14-b883-39094be4de71" class="outline-4">
<h4 id="h:9eae0d2a-eef1-4b14-b883-39094be4de71"><span class="section-number-4">6.12.3.</span> Preserve contents of system clipboard</h4>
<div class="outline-text-4" id="text-h:9eae0d2a-eef1-4b14-b883-39094be4de71">
<p>
Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere.  Before you do that, you notice something you want
to kill.  Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier.  We can have a kill ring
solution to this with the following:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Preserve contents of system clipboard
(setq save-interprogram-paste-before-kill t)
</pre>
</div>

<p>
Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with <code>M-y</code>).
</p>
</div>
</div>

<div id="outline-container-h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874" class="outline-4">
<h4 id="h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874"><span class="section-number-4">6.12.4.</span> Newline characters for file ending</h4>
<div class="outline-text-4" id="text-h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874">
<p>
For some major modes, such as <code>diff-mode</code>, a final newline is of paramount
importance.  Without it you cannot, for instance, apply a patch cleanly.
As such, the <code>mode-require-final-newline</code> will add a newline character
when visiting or saving a buffer of relevance.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Newline characters for file ending
(setq mode-require-final-newline 'visit-save)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00" class="outline-4">
<h4 id="h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00"><span class="section-number-4">6.12.5.</span> Zap characters</h4>
<div class="outline-text-4" id="text-h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00">
<p>
There are two kinds of "zap" functionality:
</p>

<ul class="org-ul">
<li><code>zap-up-to-char</code> will delete everything from point up to the character
you provide it with.  Think of how you may want to remove a file name
but keep its file type extension, so <code>M-x zap-up-to-char RET .</code> will do
just that.</li>
<li><code>zap-to-char</code>, which is bound to <code>M-z</code> by default, will delete the target
character as well.</li>
</ul>

<p>
I bind the former to <code>M-z</code> as I use it more often and leave its
counterpart on <code>M-Z</code> (<code>M-S-z</code>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Zap characters
(let ((map global-map))
  (define-key map (kbd "M-z") #'zap-up-to-char)
  (define-key map (kbd "M-Z") #'zap-to-char)) ; M-S-z
</pre>
</div>
</div>
</div>

<div id="outline-container-h:0d36996d-c12d-42e6-a388-b67c548c4a4b" class="outline-4">
<h4 id="h:0d36996d-c12d-42e6-a388-b67c548c4a4b"><span class="section-number-4">6.12.6.</span> Package lists</h4>
<div class="outline-text-4" id="text-h:0d36996d-c12d-42e6-a388-b67c548c4a4b">
<p>
With this I just want to enable line highlighting when browsing the list
of packages.  I generally use <code>hl-line-mode</code> on all interfaces where the
current line is more important than the exact column of the point.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Package lists
(prot-emacs-builtin-package 'package
  ;; All variables are for Emacs 28+
  (setq package-name-column-width 40)
  (setq package-version-column-width 14)
  (setq package-status-column-width 12)
  (setq package-archive-column-width 8)
  (add-hook 'package-menu-mode-hook #'hl-line-mode))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h:8fc1f9ca-f5ae-407a-b721-aab414ca657b" class="outline-2">
<h2 id="h:8fc1f9ca-f5ae-407a-b721-aab414ca657b"><span class="section-number-2">7.</span> Language settings for prose and code</h2>
<div class="outline-text-2" id="text-h:8fc1f9ca-f5ae-407a-b721-aab414ca657b">
<p>
This section is all about configurations and/or packages that deal with
natural or programming language enhancements.
</p>
</div>

<div id="outline-container-h:485bb253-208a-4a0a-99e3-ae1a205e3b7b" class="outline-3">
<h3 id="h:485bb253-208a-4a0a-99e3-ae1a205e3b7b"><span class="section-number-3">7.1.</span> Support for various major modes</h3>
<div class="outline-text-3" id="text-h:485bb253-208a-4a0a-99e3-ae1a205e3b7b">
<p>
These provide syntax highlighting and additional features for
environments that are not already supported by Emacs.
</p>
</div>

<div id="outline-container-h:a04db751-9675-4f31-befc-0b48671c4b3b" class="outline-4">
<h4 id="h:a04db751-9675-4f31-befc-0b48671c4b3b"><span class="section-number-4">7.1.1.</span> Plain text (text-mode with prot-text.el)</h4>
<div class="outline-text-4" id="text-h:a04db751-9675-4f31-befc-0b48671c4b3b">
<p>
My <code>prot-text.el</code> (copied verbatim further below) is meant to provide a
set of extensions for the built-in <code>text-mode.el</code>.  Currently there is
only one command:
</p>

<ul class="org-ul">
<li><code>prot-text-insert-heading</code> lets you add a heading delimiter to the line
at point.  The length of the delimiter is equal to that of the line.
By default, the delimiter consists of hyphens, but with a <code>C-u</code> prefix
argument those are substituted for equals signs.</li>
</ul>

<p>
I used to have another two in this file, which have now (2021-04-13)
been moved to <code>prot-simple.el</code>.  Those are <code>prot-simple-cite-region</code> and
<code>prot-simple-insert-undercaret</code>.
</p>

<p>
Refer to the source code in <a href="#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb">Common custom functions (prot-simple.el)</a>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Plain text (text-mode with prot-text.el)
(prot-emacs-builtin-package 'text-mode)

(prot-emacs-builtin-package 'prot-text
  (add-to-list 'auto-mode-alist '("\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)$" . text-mode))
  (define-key text-mode-map (kbd "&lt;M-return&gt;") #'prot-text-insert-heading)
  (define-key org-mode-map (kbd "&lt;M-return&gt;") #'org-meta-return) ; don't override M-RET here
  (define-key org-mode-map (kbd "M-;") nil))
</pre>
</div>

<p>
This is <code>prot-text.el</code> (find the file in <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a> (as with all my
Elisp code)):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-text.el --- Extensions to text-mode.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my text-mode.el extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)
(require 'prot-simple)

;;;###autoload
(defun prot-text-insert-heading (&amp;optional arg)
  "Insert equal length heading delimiter below current line.

A heading delimiter is drawn as a series of dashes (-).  With
optional ARG, i.e. by prefixing \\[universal-argument], draw the
heading delimiter with equals signs (=).  The latter is
considered a heading level 1, while the former is level 2.

A heading delimiter is inserted only when that would not mess up
with existing headings or lists.  In such cases, point will move
to the next line.  For the purposes of this command, text that
starts with a number and no further delimiter is not consider a
list element.

This command is meant to be used in Text mode buffers and
compatible derivatives, such as Markdown mode, though not Org
mode which has its own conventions."
  (interactive "P")
  (cond
   ((derived-mode-p 'outline-mode)
    (user-error "Do not use `prot-text-insert-heading' in `outline-mode' or derivatives!"))
   ((derived-mode-p 'text-mode)
    (let* ((num (- (point-at-eol) (point-at-bol)))
           (char (string-to-char (if arg "=" "-"))))
      (cond
       ((and (eobp)
             (or (prot-common-line-regexp-p 'list 1)
                 (prot-common-line-regexp-p 'heading 1)
                 (prot-common-line-regexp-p 'empty 1)
                 (prot-common-line-regexp-p 'indent 1)))
        (newline 1))
       ((or (prot-common-line-regexp-p 'empty 1)
            (prot-common-line-regexp-p 'indent 1))
        (prot-simple-new-line-below))
       ((or (prot-common-line-regexp-p 'list 1)
            (prot-common-line-regexp-p 'heading 2))
        (if (prot-common-line-regexp-p 'empty 3)
            (beginning-of-line 3)
          (prot-simple-new-line-below)))
       ((or (prot-common-line-regexp-p 'empty 2)
            (prot-common-line-regexp-p 'indent 2))
        (prot-simple-new-line-below)
        (insert (make-string num char))
        (newline 1)
        (beginning-of-line 2))
       (t
        (prot-simple-new-line-below)
        (insert (make-string num char))
        (newline 2)))))))

(provide 'prot-text)
;;; prot-text.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:7e0416c0-3acc-4748-9eca-4dd4da11d79b" class="outline-4">
<h4 id="h:7e0416c0-3acc-4748-9eca-4dd4da11d79b"><span class="section-number-4">7.1.2.</span> Markdown (markdown-mode)</h4>
<div class="outline-text-4" id="text-h:7e0416c0-3acc-4748-9eca-4dd4da11d79b">
<p>
I edit lots of Markdown files.  This makes things easier.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Markdown (markdown-mode)
(prot-emacs-elpa-package 'markdown-mode
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t))
;; Allows for fenced block focus with C-c ' (same as Org blocks).
(prot-emacs-elpa-package 'edit-indirect)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:c6a1aa30-4850-40b4-9764-302d98ba95fc" class="outline-4">
<h4 id="h:c6a1aa30-4850-40b4-9764-302d98ba95fc"><span class="section-number-4">7.1.3.</span> YAML (yaml-mode)</h4>
<div class="outline-text-4" id="text-h:c6a1aa30-4850-40b4-9764-302d98ba95fc">
<p>
This adds support for YAML files.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; YAML (yaml-mode)
(prot-emacs-elpa-package 'yaml-mode
  (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode)))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:ec10bfe6-5340-481c-9de2-3e346868241b" class="outline-4">
<h4 id="h:ec10bfe6-5340-481c-9de2-3e346868241b"><span class="section-number-4">7.1.4.</span> CSS (css-mode)</h4>
<div class="outline-text-4" id="text-h:ec10bfe6-5340-481c-9de2-3e346868241b">
<p>
This is the built-in mode for working with CSS and SCSS.  I just want it
to not apply previews to colour references.  If I ever need that, there
is <code>rainbow-mode</code> (see <a href="#h:9061c694-5f45-46b0-a878-6bcfb018e18d">relevant section</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; CSS (css-mode)
(prot-emacs-builtin-package 'css-mode
  (add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
  (add-to-list 'auto-mode-alist '("\\.scss$" . scss-mode))
  (setq css-fontify-colors nil))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:fee2b8ff-80d6-4669-904c-c8ee64c9719c" class="outline-4">
<h4 id="h:fee2b8ff-80d6-4669-904c-c8ee64c9719c"><span class="section-number-4">7.1.5.</span> Shell scripts (sh-mode)</h4>
<div class="outline-text-4" id="text-h:fee2b8ff-80d6-4669-904c-c8ee64c9719c">
<p>
<code>sh-mode.el</code> is another built-in mode that targets shell scripts.  I
think it works well out-of-the-box, even though it provides lots of
configuration options to further control its behaviour.
</p>

<p>
All I want here is to enable <code>sh-mode</code> in various files that are not
obvious shell scripts, like Arch Linux's package recipes.  As such, the
value assigned to <code>auto-mode-alist</code> will be expanded each time I
identify such a file.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Shell scripts (sh-mode)
(prot-emacs-builtin-package 'sh-script
  (add-to-list 'auto-mode-alist '("PKGBUILD" . sh-mode)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3" class="outline-3">
<h3 id="h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3"><span class="section-number-3">7.2.</span> Paragraphs and fill-mode (prot-fill.el)</h3>
<div class="outline-text-3" id="text-h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3">
<p>
The <code>prot-fill.el</code> library (reproduced below) is a tiny wrapper around
some Emacs settings and modes that are scrattered around several files,
which control (i) how paragraphs or comments in programming modes should
be wrapped to a given column count, and (ii) what constitutes a
sentence.  I put them all together here to make things easier to track.
</p>

<ul class="org-ul">
<li>With regard to paragraphs, I find that a double space is the best way
to delimit sentences in source form, where a monospaced typeface is
customary.  There is no worry that this will be shown on a website or
rendered version of a document, because processors know how to handle
spacing.  We do this to make phrases easier to tell apart, but also to
render unambiguous commands like <code>forward-sentence</code>.</li>

<li><code>prot-fill-fill-mode</code> sets my desired default column width for all
buffers, while it applies another value for programming modes (in case
there is a need to control the two cases separately).  Those values
are stored in the variables <code>prot-fill-default-column</code> and
<code>prot-fill-prog-mode-column</code> respectively.  My minor mode also enables
<code>auto-fill-mode</code> in <code>text-mode</code> and <code>prog-mode</code> buffers through the
appropriate hooks.  Disabling <code>prot-fill-fill-mode</code> will remove all
those customisations.</li>
</ul>

<p>
Note that <a href="#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb">Common custom functions (prot-simple.el)</a> contains some
commands related to auto-fill.  Besides, you can always do it manually
for the current paragraph or the active region with <code>M-x fill-paragraph</code>,
bound by default to <code>M-q</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Paragraphs and fill-mode (prot-fill.el)
(prot-emacs-builtin-package 'prot-fill
  (setq prot-fill-default-column 72)
  (setq prot-fill-prog-mode-column 72)  ; Set this to another value if you want
  ;; Those variables come from various sources, though they feel part of the
  ;; same conceptual framework.
  (setq sentence-end-double-space t)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t)
  (prot-fill-fill-mode 1)
  (add-hook 'after-init-hook #'column-number-mode))
</pre>
</div>

<p>
These are the contents of <code>prot-fill.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-fill.el --- Minor fill-mode tweaks for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my fill-mode extensions, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-fill ()
  "Tweak for filling paragraphs."
  :group 'fill)

(defcustom prot-fill-default-column 72
  "Default width for `fill-column'."
  :type 'integer
  :group 'prot-fill)

(defcustom prot-fill-prog-mode-column 80
  "`prog-mode' width for `fill-column'.
Also see `prot-fill-default-column'."
  :type 'integer
  :group 'prot-fill)

(defun prot-fill--fill-prog ()
  "Set local value of `fill-column' for programming modes.
Meant to be called via `prog-mode-hook'."
  (setq-local fill-column prot-fill-prog-mode-column))

;;;###autoload
(define-minor-mode prot-fill-fill-mode
  "Set up fill-mode and relevant variable."
  :init-value nil
  :global t
  (if prot-fill-fill-mode
      (progn
        (setq-default fill-column prot-fill-default-column)
        (add-hook 'prog-mode-hook #'prot-fill--fill-prog)
        (add-hook 'text-mode-hook #'turn-on-auto-fill))
    (setq-default fill-column 70)
    (remove-hook 'prog-mode-hook #'prot-fill--fill-prog)
    (remove-hook 'text-mode-hook #'turn-on-auto-fill)))

(provide 'prot-fill)
;;; prot-fill.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:fa56241c-6840-4a39-8f59-18460d37fc69" class="outline-3">
<h3 id="h:fa56241c-6840-4a39-8f59-18460d37fc69"><span class="section-number-3">7.3.</span> Comments (newcomment.el and prot-comment.el)</h3>
<div class="outline-text-3" id="text-h:fa56241c-6840-4a39-8f59-18460d37fc69">
<p>
The built-in <code>newcomment.el</code> library offers several useful commands for
working with comments in source code.  While my <code>prot-comment.el</code>
(reproduced after the package configurations) adds some simple extras.
</p>

<p>
The intent of my configurations here is straightforward: re-configure
key bindings to make the most common action easier to access and then
arrange the rest in a meaningful way, while also setting up the
appropriate variables.
</p>

<p>
The most common action is the command <code>prot-comment-comment-dwim</code> which is
bound to <code>C-;</code>.  Note that <code>C-;</code> is normally occupied by some <code>flyspell</code>
command (disabled in <a href="#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c">Flyspell and prot-spell.el (spell check)</a>).  Compare
that keybinding to the one I have for the much more specialised
<code>prot-comment-timestamp-keyword</code>: <code>C-x C-;</code>.  What those commands do is
documented in their docstrings, so please check the code below.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Comments (newcomment.el and prot-comment.el)
(prot-emacs-builtin-package 'newcomment
  (setq comment-empty-lines t)
  (setq comment-fill-column nil)
  (setq comment-multi-line t)
  (setq comment-style 'multi-line)
  (let ((map global-map))
    (define-key map (kbd "C-:") #'comment-kill)         ; C-S-;
    (define-key map (kbd "M-;") #'comment-indent)))

(prot-emacs-builtin-package 'prot-comment
  (setq prot-comment-comment-keywords
        '("TODO" "NOTE" "XXX" "REVIEW" "FIXME"))
  (setq prot-comment-timestamp-format-concise "%F")
  (setq prot-comment-timestamp-format-verbose "%F %T %z")
  (let ((map global-map))
    (define-key map (kbd "C-;") #'prot-comment-comment-dwim)
    (define-key map (kbd "C-x C-;") #'prot-comment-timestamp-keyword)))
</pre>
</div>

<p>
And here is <code>prot-comment.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-comment.el --- Extensions newcomment.el for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my newcomment.el extras, for use in my Emacs setup:
;; https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'prot-common)

(defgroup prot-comment ()
  "Extensions for newcomment.el."
  :group 'comment)

(defcustom prot-comment-comment-keywords
  '("TODO" "NOTE" "XXX" "REVIEW" "FIXME")
  "List of strings with comment keywords."
  :type '(repeat string)
  :group 'prot-comment)

(defcustom prot-comment-timestamp-format-concise "%F"
  "Specifier for date in `prot-comment-timestamp-keyword'.
Refer to the doc string of `format-time-string' for the available
options."
  :type 'string
  :group 'prot-comment)

(defcustom prot-comment-timestamp-format-verbose "%F %T %z"
  "Like `prot-comment-timestamp-format-concise', but longer."
  :type 'string
  :group 'prot-comment)

;;;###autoload
(defun prot-comment-comment-dwim (arg)
  "Flexible, do-what-I-mean commenting.

If region is active and ARG is either a numeric argument greater
than one or a universal prefix (\\[universal-argument]), then
apply `comment-kill' on all comments in the region.

If the region is active and no ARG is supplied, or is equal to a
numeric prefix of 1, then toggle the comment status of the region.

Else toggle the comment status of the line at point.  With a
numeric prefix ARG, do so for ARGth lines (negative prefix
operates on the lines before point)."
  (interactive "p")
  (cond
   ((and (&gt; arg 1) (use-region-p))
    (let* ((beg (region-beginning))
           (end (region-end))
           (num (count-lines beg end)))
      (save-excursion
        (goto-char beg)
        (comment-kill num))))
   ((use-region-p)
    (comment-or-uncomment-region (region-beginning) (region-end)))
   (t
    (save-excursion (comment-line (or arg 1))))))

(defvar prot-comment--keyword-hist '()
  "Input history of selected comment keywords.")

(defun prot-comment--keyword-prompt (keywords)
  "Prompt for candidate among KEYWORDS."
  (let ((def (car prot-comment--keyword-hist)))
    (completing-read
     (format "Select keyword [%s]: " def)
     keywords nil nil nil 'prot-comment--keyword-hist def)))

;;;###autoload
(defun prot-comment-timestamp-keyword (keyword &amp;optional verbose)
  "Add timestamped comment with KEYWORD.

When called interactively, the list of possible keywords is that
of `prot-comment-comment-keywords', though it is possible to
input arbitrary text.

If point is at the beginning of the line or if line is empty (no
characters at all or just indentation), the comment is started
there in accordance with `comment-style'.  Any existing text
after the point will be pushed to a new line and will not be
turned into a comment.

If point is anywhere else on the line, the comment is indented
with `comment-indent'.

The comment is always formatted as 'DELIMITER KEYWORD DATE:',
with the date format being controlled by the variable
`prot-comment-timestamp-format-concise'.

With optional VERBOSE argument (such as a prefix argument
`\\[universal-argument]'), use an alternative date format, as
specified by `prot-comment-timestamp-format-verbose'."
  (interactive
   (list
    (prot-comment--keyword-prompt prot-comment-comment-keywords)
    current-prefix-arg))
  (let* ((date (if verbose
                   prot-comment-timestamp-format-verbose
                 prot-comment-timestamp-format-concise))
         (string (format "%s %s: " keyword (format-time-string date)))
         (beg (point)))
    (cond
     ((or (eq beg (point-at-bol))
          (prot-common-line-regexp-p 'empty))
      (let* ((maybe-newline (unless (prot-common-line-regexp-p 'empty 1) "\n")))
        ;; NOTE 2021-07-24: we use this `insert' instead of
        ;; `comment-region' because of a yet-to-be-determined bug that
        ;; traps `undo' to the two states between the insertion of the
        ;; string and its transformation into a comment.
        (insert
         (concat comment-start
                 ;; NOTE 2021-07-24: See function `comment-add' for
                 ;; why we need this.
                 (make-string
                  (comment-add nil)
                  (string-to-char comment-start))
                 comment-padding
                 string
                 comment-end))
        (indent-region beg (point))
        (when maybe-newline
          (save-excursion (insert maybe-newline)))))
     (t
      (comment-indent t)
      (insert (concat " " string))))))

(provide 'prot-comment)
;;; prot-comment.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9" class="outline-3">
<h3 id="h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9"><span class="section-number-3">7.4.</span> Configure 'electric' behaviour</h3>
<div class="outline-text-3" id="text-h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9">
<p>
Emacs labels as "electric" any behaviour that involves contextual
auto-insertion of characters.  while the idea is neat, I generally
dislike it because of its false positives.  This is a summary of my
settings:
</p>

<ul class="org-ul">
<li>If <code>electric-pair-mode</code> is enabled (which I might do manually), insert
quotes and brackets in pairs.  Only do so if there is no alphabetic
character after the cursor.</li>
<li>The cryptic numbers in the pairs set, correspond to curly single and
double quotes and these <code>«»</code>.  The contents of this set are always
inserted in pairs, regardless of major mode.  To get those numbers,
evaluate <code>(string-to-char CHAR)</code> where CHAR is the one you are
interested in.  For example, get the literal tab's character with
<code>(string-to-char "\t")</code>.</li>
<li>While inputting a pair, inserting the closing character will just skip
over the existing one, rather than add a new one.  So typing <code>(</code> will
insert <code>()</code> and then typing <code>)</code> will just be the same as moving forward
one character <code>C-f</code>.</li>
<li>Do not skip over whitespace when operating on pairs.  Combined with
the above point, this means that a new character will be inserted,
rather than be skipped over.  I find this better, because it prevents
the point from jumping forward, plus it allows for more natural
editing.</li>
<li>The whitespace characters are space (<code>\s</code>), tab (<code>\t</code>), and newline (<code>\n</code>).</li>
<li>The rest concern the conditions for transforming quotes into their
curly equivalents.  I keep this disabled, because curly quotes are
distinct characters.  It is difficult to search for them.  Just note
that on GNU/Linux you can type them directly by hitting the "compose"
key and then an angled bracket (<code>&lt;</code> or <code>&gt;</code>) followed by a quote mark.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Configure 'electric' behaviour
(prot-emacs-builtin-package 'electric
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  ;; I don't like auto indents in Org and related.
  (add-hook 'prog-mode-hook #'electric-indent-local-mode))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:3d374354-843f-4efa-aa38-1ba2c9ccc14c" class="outline-3">
<h3 id="h:3d374354-843f-4efa-aa38-1ba2c9ccc14c"><span class="section-number-3">7.5.</span> Parentheses (show-paren-mode)</h3>
<div class="outline-text-3" id="text-h:3d374354-843f-4efa-aa38-1ba2c9ccc14c">
<p>
Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.
</p>

<p>
Summary of what these do:
</p>

<ul class="org-ul">
<li>Activate the mode upon startup.</li>
<li>Show the matching delimiter/parenthesis if on screen, else show
nothing.  It is possible to highlight the expression enclosed by the
delimiters, by using either <code>mixed</code> or <code>expression</code>.  The latter always
highlights the entire balanced expression, while the former will only
do so if the matching delimiter is off screen.</li>
<li><code>show-paren-when-point-in-periphery</code> lets you highlight parentheses even
if the point is in their vicinity.  This means the beginning or end of
the line, with space in between.  I used that for a long while and it
server me well.  Now that I have a better understanding of Elisp, I
disable it.</li>
<li>Do not highlight a match when the point is on the inside of the
parenthesis.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Parentheses (show-paren-mode)
(prot-emacs-builtin-package 'paren
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (add-hook 'after-init-hook #'show-paren-mode))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:d51d37df-4e58-4e0b-85a1-019ceda342f6" class="outline-3">
<h3 id="h:d51d37df-4e58-4e0b-85a1-019ceda342f6"><span class="section-number-3">7.6.</span> Tabs, indentation, and the TAB key</h3>
<div class="outline-text-3" id="text-h:d51d37df-4e58-4e0b-85a1-019ceda342f6">
<p>
I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which <i>can actually lead to misalignments</i>
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.
</p>

<p>
If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.
</p>

<p>
Note that <code>tab-always-indent</code> will first do indentation and then try to
complete whatever you have typed in.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Tabs, indentation, and the TAB key
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
</pre>
</div>
</div>
</div>

<div id="outline-container-h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c" class="outline-3">
<h3 id="h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c"><span class="section-number-3">7.7.</span> Flyspell and prot-spell.el (spell check)</h3>
<div class="outline-text-3" id="text-h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c">
<p>
I need spell checking mostly for English, though I also install
dictionaries for Greek, French, and Spanish.  These are external to
Emacs and are provided by the <code>aspell</code> library.
</p>

<p>
In previous versions of this section I had configurations that would
automate spell checking.  It worked but was rather slow.  Upon further
inspection, I realised that I seldom need to work in mixed language
circumstances.  Moreover, I now understand that I do not need to have
spell checking always on: it is distracting.
</p>

<p>
My workflow is to call an interactive command to perform spell checking.
This is <code>prot-spell-spell-dwim</code>, which is part of my <code>prot-spell.el</code> library
(reproduced after the following package configurations).  What it does is
search for errors in the active region or, if that does not apply,
operate on the word at point.  Its fallback condition is a call to
<code>prot-spell-change-dictionary</code>, which I use to switch between languages
using minibuffer completion.
</p>

<p>
Also bear in mind that the key binding <code>C-;</code> that Flyspell uses by default
is disabled because I re-purpose it for a faster version of <code>C-x C-;</code>
(much more useful for my work—see the <a href="#h:fa56241c-6840-4a39-8f59-18460d37fc69">section on comments</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Flyspell and prot-spell.el (spell check)
(prot-emacs-builtin-package 'flyspell
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "aspell")
  (setq ispell-dictionary "en_GB")
  (define-key flyspell-mode-map (kbd "C-;") nil))

(prot-emacs-builtin-package 'prot-spell
  (setq prot-spell-dictionaries
        '(("EN English" . "en")
          ("EL Ελληνικά" . "el")
          ("FR Français" . "fr")
          ("ES Espanõl" . "es")))
  (let ((map global-map))
    (define-key map (kbd "M-$") #'prot-spell-spell-dwim)
    (define-key map (kbd "C-M-$") #'prot-spell-change-dictionary)))
</pre>
</div>

<p>
This is <code>prot-spell.el</code> (part of <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>):
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; prot-spell.el --- Spelling-related extensions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2021  Protesilaos Stavrou

;; Author: Protesilaos Stavrou &lt;info@protesilaos.com&gt;
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

;;; Commentary:
;;
;; This covers my spelling-related extensions, for use in my Emacs
;; setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(defgroup prot-spell ()
  "Extensions for ispell and flyspell."
  :group 'ispell)

(defcustom prot-spell-dictionaries
  '(("EN English" . "en")
    ("EL Ελληνικά" . "el")
    ("FR Français" . "fr")
    ("ES Espanõl" . "es"))
  "Alist of strings with descriptions and dictionary keys.
Used by `prot-spell-change-dictionary'."
  :type 'alist
  :group 'prot-spell)

(defvar prot-spell--dictionary-hist '()
  "Input history for `prot-spell-change-dictionary'.")

(defun prot-spell--dictionary-prompt ()
  "Helper prompt to select from `prot-spell-dictionaries'."
  (let ((def (car prot-spell--dictionary-hist)))
    (completing-read
     (format "Select dictionary [%s]: " def)
     (mapcar #'car prot-spell-dictionaries)
     nil t nil 'prot-spell--dictionary-hist def)))

;;;###autoload
(defun prot-spell-change-dictionary (dictionary)
  "Select a DICTIONARY from `prot-spell-dictionaries'."
  (interactive
   (list (prot-spell--dictionary-prompt)))
  (let* ((key (cdr (assoc dictionary prot-spell-dictionaries)))
         (desc (car (assoc dictionary prot-spell-dictionaries))))
    (ispell-change-dictionary key)
    (message "Switched dictionary to %s" (propertize desc 'face 'bold))))

(autoload 'flyspell-region "flyspell")
(autoload 'thing-at-point "thingatpt")
(autoload 'ispell-word "ispell")

;;;###autoload
(defun prot-spell-spell-dwim (beg end)
  "Spellcheck between BEG END, current word, or select dictionary.

Use `flyspell-region' on the active region.  With point over a
word and no active region invoke `ispell-word'.  Else call
`prot-spell-change-dictionary'."
  (interactive "r")
  (cond
   ((use-region-p)
    (flyspell-region beg end))
   ((thing-at-point 'word)
    (call-interactively 'ispell-word))
   (t
    (call-interactively 'prot-spell-change-dictionary))))

(provide 'prot-spell)
;;; prot-spell.el ends here
</pre>
</div>
</div>
</div>

<div id="outline-container-h:20448ad8-9371-4e00-b88b-6b93f4c654d9" class="outline-3">
<h3 id="h:20448ad8-9371-4e00-b88b-6b93f4c654d9"><span class="section-number-3">7.8.</span> Code and text linters</h3>
<div class="outline-text-3" id="text-h:20448ad8-9371-4e00-b88b-6b93f4c654d9">
</div>

<div id="outline-container-h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a" class="outline-4">
<h4 id="h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a"><span class="section-number-4">7.8.1.</span> Flymake</h4>
<div class="outline-text-4" id="text-h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a">
<p>
This is a built-in linter interface.  It visualises in a buffer what you
would otherwise get on the command-line prompt (or compilation log),
while it also marks the line[s] where the note, warning, or error
occurs.  In short, it is quite a nice tool to have.
</p>

<p>
Several extensions to Flymake are already available, mostly targeted at
programmers.  For my case, there is no need for any of those, while
Flymake can lint Elisp without any further configuration.
</p>

<p>
The external <code>flymake-diagnostic-at-point</code> package provides a simple and
effective interface to displaying information about the warning at
point.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Flymake
(prot-emacs-builtin-package 'flymake
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  (setq flymake-mode-line-format
        '("" flymake-mode-line-exception flymake-mode-line-counters))
  (setq flymake-mode-line-counter-format
        '(" " flymake-mode-line-error-counter
          flymake-mode-line-warning-counter
          flymake-mode-line-note-counter ""))

  (let ((map flymake-mode-map))
    (define-key map (kbd "C-c ! s") #'flymake-start)
    (define-key map (kbd "C-c ! d") #'flymake-show-buffer-diagnostics) ; Emacs28
    (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
    (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error)))

(prot-emacs-elpa-package 'flymake-diagnostic-at-point
  (setq flymake-diagnostic-at-point-display-diagnostic-function
        'flymake-diagnostic-at-point-display-minibuffer))
</pre>
</div>
</div>

<div id="outline-container-h:a45fd661-8cd7-4ee7-bff0-5f738d82b73b" class="outline-5">
<h5 id="h:a45fd661-8cd7-4ee7-bff0-5f738d82b73b"><span class="section-number-5">7.8.1.1.</span> Flymake + Shellcheck</h5>
<div class="outline-text-5" id="text-h:a45fd661-8cd7-4ee7-bff0-5f738d82b73b">
<p>
The <code>flymake-shellcheck</code> package simply adds support for Shellcheck, the
linter for shell scripts.  It otherwise relies on the standard utilities
of <code>flymake-mode</code> (see <a href="#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a">main Flymake configs</a>).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Flymake + Shellcheck
(prot-emacs-elpa-package 'flymake-shellcheck
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:2a954862-c532-43e9-afdf-4bacd152295f" class="outline-5">
<h5 id="h:2a954862-c532-43e9-afdf-4bacd152295f"><span class="section-number-5">7.8.1.2.</span> Flymake + Proselint</h5>
<div class="outline-text-5" id="text-h:2a954862-c532-43e9-afdf-4bacd152295f">
<p>
Manuel Uberti has published <a href="https://github.com/manuel-uberti/flymake-proselint">flymake-proselint on Github</a> and MELPA.  It
offers a Flymake interface to the external <code>proselint</code> executable (see
<a href="#h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b">Proselint configuration</a>).
</p>

<p>
This comes in handy when I need to review some long-form text for common
inconsistencies and stylistic irregularities.  Errors will be marked on
the fringe, while you can quickly get an overview with pointers to the
precise line number by invoking <code>flymake-show-diagnostics-buffer</code> (check
my <a href="#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a">configurations for Flymake</a> and then also review what I have to
spelling in <a href="#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c">Flyspell and prot-spell.el (spell check)</a>).
</p>

<p>
To run the program, you just need to hook it to whatever major-mode you
use for prose.  Then you need to enable <code>flymake-mode</code> to start using it.
I prefer to do the final step manually, as I normally do not run a
linter while writing: it is too distracting.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Flymake + Proselint
(prot-emacs-elpa-package 'flymake-proselint
  (add-hook 'markdown-mode-hook #'flymake-proselint-setup)
  (add-hook 'org-mode-hook #'flymake-proselint-setup)
  (add-hook 'text-mode-hook #'flymake-proselint-setup))
</pre>
</div>
</div>

<div id="outline-container-h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b" class="outline-6">
<h6 id="h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b"><span class="section-number-6">7.8.1.2.1.</span> Proselint configuration</h6>
<div class="outline-text-6" id="text-h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b">
<p>
This is my configuration for the external <code>proselint</code> executable (check
<a href="https://github.com/amperser/proselint">that project's README</a>).  The following should be made available at
<code>~/.config/proselint/config</code>.
</p>

<p>
See <a href="#h:2a954862-c532-43e9-afdf-4bacd152295f">Flymake + Proselint</a> for how I use this tool to review my long-form
writing.
</p>

<div class="org-src-container">
<pre class="src src-conf">{
    "max_errors": 200,
    "checks": {
        "airlinese.misc"                : false,
        "annotations.misc"              : true,
        "archaism.misc"                 : true,
        "cliches.hell"                  : true,
        "cliches.misc"                  : true,
        "consistency.spacing"           : true,
        "consistency.spelling"          : true,
        "corporate_speak.misc"          : false,
        "cursing.filth"                 : false,
        "cursing.nfl"                   : false,
        "cursing.nword"                 : false,
        "dates_times.am_pm"             : false,
        "dates_times.dates"             : false,
        "hedging.misc"                  : true,
        "hyperbole.misc"                : true,
        "jargon.misc"                   : true,
        "lexical_illusions.misc"        : true,
        "lgbtq.offensive_terms"         : true,
        "lgbtq.terms"                   : true,
        "links.broken"                  : false,
        "malapropisms.misc"             : true,
        "misc.apologizing"              : true,
        "misc.back_formations"          : true,
        "misc.bureaucratese"            : true,
        "misc.but"                      : true,
        "misc.capitalization"           : true,
        "misc.chatspeak"                : false,
        "misc.commercialese"            : true,
        "misc.composition"              : true,
        "misc.currency"                 : false,
        "misc.debased"                  : true,
        "misc.false_plurals"            : true,
        "misc.illogic"                  : true,
        "misc.inferior_superior"        : true,
        "misc.institution_name"	        : true,
        "misc.latin"                    : true,
        "misc.many_a"                   : false,
        "misc.metaconcepts"             : true,
        "misc.metadiscourse"            : true,
        "misc.narcissism"               : true,
        "misc.not_guilty"               : true,
        "misc.phrasal_adjectives"       : true,
        "misc.preferred_forms"          : true,
        "misc.pretension"               : true,
        "misc.professions"              : true,
        "misc.punctuation"              : true,
        "misc.scare_quotes"             : true,
        "misc.suddenly"                 : false,
        "misc.tense_present"            : true,
        "misc.waxed"                    : true,
        "misc.whence"                   : false,
        "mixed_metaphors.misc"          : true,
        "mondegreens.misc"              : true,
        "needless_variants.misc"        : true,
        "nonwords.misc"                 : true,
        "oxymorons.misc"                : true,
        "psychology.misc"               : true,
        "redundancy.misc"               : true,
        "redundancy.ras_syndrome"       : true,
        "skunked_terms.misc"            : true,
        "spelling.able_atable"          : true,
        "spelling.able_ible"            : true,
        "spelling.athletes"             : false,
        "spelling.em_im_en_in"          : true,
        "spelling.er_or"                : true,
        "spelling.in_un"                : true,
        "spelling.misc"                 : true,
        "security.credit_card"          : false,
        "security.password"             : false,
        "sexism.misc"                   : true,
        "terms.animal_adjectives"       : true,
        "terms.denizen_labels"          : true,
        "terms.eponymous_adjectives"    : true,
        "terms.venery"                  : true,
        "typography.diacritical_marks"  : false,
        "typography.exclamation"        : true,
        "typography.symbols"            : true,
        "uncomparables.misc"            : true,
        "weasel_words.misc"             : true,
        "weasel_words.very"             : false
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h:d03342da-3035-409f-a5e7-5df1e614d507" class="outline-4">
<h4 id="h:d03342da-3035-409f-a5e7-5df1e614d507"><span class="section-number-4">7.8.2.</span> Elisp packaging requirements</h4>
<div class="outline-text-4" id="text-h:d03342da-3035-409f-a5e7-5df1e614d507">
<p>
With this in place we can perform checks that pertain to Emacs lisp
packaging.  I use it for my themes but also for any elisp library I may
want to send patches to.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Elisp packaging requirements
(prot-emacs-elpa-package 'package-lint-flymake
  (add-hook 'flymake-diagnostic-functions #'package-lint-flymake))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:d0f76937-4f54-401c-aae8-ffadf8697357" class="outline-3">
<h3 id="h:d0f76937-4f54-401c-aae8-ffadf8697357"><span class="section-number-3">7.9.</span> Eldoc (elisp live documentation feedback)</h3>
<div class="outline-text-3" id="text-h:d0f76937-4f54-401c-aae8-ffadf8697357">
<p>
When editing elisp, this mode will display useful information about the
construct at point in the echo area.  For functions it will display the
list of arguments they accept.  While it will show the the first
sentence of a variable's documentation string.
</p>

<p>
At first, I dismissed this package.  Upon closer inspection, it does
offer a lightweight complementary facility to that of the standard help
commands: <code>C-h f FUNCTION</code>, <code>C-h v VARIABLE</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Eldoc (elisp live documentation feedback)
(prot-emacs-builtin-package 'eldoc
  (global-eldoc-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:ce420306-c40c-4d9a-bc01-205c5e49a5d1" class="outline-3">
<h3 id="h:ce420306-c40c-4d9a-bc01-205c5e49a5d1"><span class="section-number-3">7.10.</span> Tools for manual pages (manpages)</h3>
<div class="outline-text-3" id="text-h:ce420306-c40c-4d9a-bc01-205c5e49a5d1">
<p>
Emacs offers a couple of commands for reading manual pages: <code>man</code> and
<code>woman</code>.  The former relies on the standard Unix tools, while the latter
is an elisp implementation of the same idea.  As I only ever run a
GNU/Linux system, I am okay with just <code>man</code>.
</p>

<p>
Why bother?
</p>

<ul class="org-ul">
<li>All the goodies of consistency: fonts, themes, operating on text with
your familiar Emacs functionality, handling buffers…</li>
<li>Each manpage provides direct links to other items it references.</li>
</ul>

<p>
What you can do inside such a buffer (with minor tweaks by me):
</p>

<ul class="org-ul">
<li>Hit <code>i</code> to go to the information node you want using completion (same
principle as with the Info pages of <code>C-h i</code> and the like).</li>
<li><code>g</code> will generate the buffer anew.  Do it to reformat the text manually,
though this should also happen automatically when adjusting a window's
size.</li>
<li><code>n</code> and <code>p</code> move between section headings.</li>
<li>Hit <code>RET</code> while over a referenced manpage to produce a new buffer with
its contents.</li>
<li><code>s</code> takes you directly to the familiar "See Also" section.</li>
<li>Use <code>m</code> to search for another manpage using your completion framework.
If you invoke this command while point is over a referenced manpage,
it becomes the default choice (same concept as with common help
commands, <code>C-h f</code>, <code>C-h v</code>, and with many others like <code>find-library</code>).</li>
</ul>

<p>
Need to filter out those <code>man</code> buffers?  Check <a href="#h:06290f9c-491c-45b2-b213-0248f890c83d">my Ibuffer entry</a>.
</p>

<p>
While there are customisation options for this tool, I find the defaults
to work as expected.  Note that the capitalisation of those symbols is
canonical.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Tools for manual pages (manpages)
(prot-emacs-builtin-package 'man
  (let ((map Man-mode-map))
    (define-key map (kbd "i") #'Man-goto-section)
    (define-key map (kbd "g") #'Man-update-manpage)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b" class="outline-2">
<h2 id="h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b"><span class="section-number-2">8.</span> History and state</h2>
<div class="outline-text-2" id="text-h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b">
<p>
This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer.
</p>
</div>

<div id="outline-container-h:68d57dd2-4df1-4b7a-8766-231216e6cd9c" class="outline-3">
<h3 id="h:68d57dd2-4df1-4b7a-8766-231216e6cd9c"><span class="section-number-3">8.1.</span> Emacs server and desktop</h3>
<div class="outline-text-3" id="text-h:68d57dd2-4df1-4b7a-8766-231216e6cd9c">
<p>
The following uses the first <i>running</i> process of Emacs as the one others
may connect to.  This means that calling <code>emacsclient</code> (with or without
<code>--create-frame</code>), will share the same buffer list and data as the
original running process, aka "the server".  The server persists for as
long as there is an Emacs frame attached to it.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Emacs server and desktop
(prot-emacs-builtin-package 'server
  (add-hook 'after-init-hook #'server-start))
</pre>
</div>

<p>
With some exceptions aside, I only ever use Emacs in a single frame.
What I find more useful is the ability to save what Emacs calls the
<code>desktop</code>, which is an amalgamation of data such as the buffer list,
visited files, and some important data like the content of registers
(for various histories or other data see the following sections on
<a href="#h:ab868c1a-7ca6-4f54-83d8-eab49447da82">recording various types of history</a>).
</p>

<p>
Because I can always access files I have visited before using completion
(see <a href="#h:5723c4bb-ff6c-449f-bb60-be66fab3f137">Completion for recent files and directories (prot-recentf.el)</a>), I
opt to discard all files and buffers from the <code>desktop</code>.  Instead, I use
it to restore everything in the variable <code>desktop-globals-to-save</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(prot-emacs-builtin-package 'desktop
  (setq desktop-auto-save-timeout 300)
  (setq desktop-path `(,user-emacs-directory))
  (setq desktop-base-file-name "desktop")
  (setq desktop-files-not-to-save ".*")
  (setq desktop-buffers-not-to-save ".*")
  (setq desktop-globals-to-clear nil)
  (setq desktop-load-locked-desktop t)
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 0)
  (setq desktop-restore-frames nil)
  (setq desktop-save 'ask-if-new)
  (dolist (symbol '(kill-ring log-edit-comment-ring))
    (add-to-list 'desktop-globals-to-save symbol))

  (desktop-save-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:ab868c1a-7ca6-4f54-83d8-eab49447da82" class="outline-3">
<h3 id="h:ab868c1a-7ca6-4f54-83d8-eab49447da82"><span class="section-number-3">8.2.</span> Record various types of history</h3>
<div class="outline-text-3" id="text-h:ab868c1a-7ca6-4f54-83d8-eab49447da82">
</div>
<div id="outline-container-h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978" class="outline-4">
<h4 id="h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978"><span class="section-number-4">8.2.1.</span> Record cursor position</h4>
<div class="outline-text-4" id="text-h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978">
<p>
Just remember where the point is in any given file.  This can often be a
subtle reminder of what you were doing the last time you visited that
file, allowing you to pick up from there.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Record cursor position
(prot-emacs-builtin-package 'saveplace
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
</pre>
</div>
</div>
</div>

<div id="outline-container-h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296" class="outline-4">
<h4 id="h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296"><span class="section-number-4">8.2.2.</span> Backups</h4>
<div class="outline-text-4" id="text-h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296">
<p>
And here are some settings pertaining to backups.  I rarely need those,
but I prefer to be safe in the knowledge that if something goes awry
there is something to fall back to.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; Backups
(setq backup-directory-alist
      `(("." . ,(concat user-emacs-directory "backup/"))))
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq create-lockfiles nil)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h:4e73b827-cdf3-46a2-81c5-55b6e95701b7" class="outline-2">
<h2 id="h:4e73b827-cdf3-46a2-81c5-55b6e95701b7"><span class="section-number-2">9.</span> Frequently Asked Questions about this document</h2>
<div class="outline-text-2" id="text-h:4e73b827-cdf3-46a2-81c5-55b6e95701b7">
<p>
There are some persistent questions that pop up in my email exchange, so
I thought I would cover them all in this section.
</p>
</div>

<div id="outline-container-h:83730fe8-d917-4d94-96f4-bbc5c900fe38" class="outline-3">
<h3 id="h:83730fe8-d917-4d94-96f4-bbc5c900fe38"><span class="section-number-3">9.1.</span> How do you learn Emacs?</h3>
<div class="outline-text-3" id="text-h:83730fe8-d917-4d94-96f4-bbc5c900fe38">
<p>
There is no one-size-fits-all approach to learning.  What one finds
satisfactory, another may consider insufficient.  In my opinion, the
best way to learn Emacs is to start small, be patient, and brace
yourself for a lot of reading and experimentation.
</p>

<p>
The best skill you can master, the one that will always help you in your
Emacs journey, is the built-in help system.  Learn to ask Emacs about
things you do not know about.  This section documents the essentials of
Emacs' <i>introspectable nature</i>.
</p>

<p>
Know that <code>C-h</code> is the universal key for help commands (broadly
understood).  It works both as a prefix and as a suffix.  Some common
help commands:
</p>

<ul class="org-ul">
<li><code>C-h f</code> (<code>describe-function</code>) allows you to search for documentation about
<b>functions</b>.</li>
<li><code>C-h v</code> (<code>describe-variable</code>) is the same for <b>variables</b>.</li>
<li><code>C-h o</code> (<code>describe-symbol</code>) is a wrapper of the above two, so you are
searching for functions <b>or</b> variables.  The proper name for any of
these items is called a "symbol" (think of <code>name-of-thing</code> as
symbolising a definition in the source code).</li>
<li><code>C-h k</code> (<code>describe-key</code>) will prompt you for a <b>key</b> binding.  Once you type
it in you will get help about what command corresponds to that key (if
any).  Note that this depends on the major mode you are in.  For
example <code>C-c C-c</code> does something different in Org and Eshell buffers.
Try <code>C-h k C-c C-c</code> to find about the different functions these will
invoke in their respective major mode.</li>
<li><code>C-h w</code> (<code>where-is</code>) asks you for the symbol of a command and tells you to
which key binding it is assigned to.</li>
<li><code>C-h l</code> (<code>view-lossage</code>) produces a log with your most recent key presses
and the commands they call.  Emacs calls this the "lossage".  Ever
mistyped something and got to the wrong place?  Use this as an
opportunity to learn and, perhaps, a way to identify key sequences you
would like to modify.  (<b>pro tip</b>: you can edit/convert your lossage
into a keyboard macro with <code>C-x C-k l</code>&#x2014;also watch <a href="https://protesilaos.com/codelog/2020-03-14-emacs-kmacro-edit/">Edit keyboard macros</a>
(2020-03-14)).</li>
</ul>

<p>
In the above scenaria we see how <code>C-h</code> is used as a prefix: you are
starting a key sequence with it.  Now here are some cases of using it as
a suffix:
</p>

<ul class="org-ul">
<li>For <i>every incomplete key sequence</i> if you follow it up with <code>C-h</code> you
will get a help buffer about all possible key combinations that
complete that sequence.  For example, if you type <code>C-c C-h</code> inside of an
Org buffer you will get all possible commands for Org mode and for all
other minor modes you have active.</li>
<li>The <code>C-h</code> suffix can be appended to longer key sequences.  Indeed the
length is irrelevant.  Suppose you want to learn more about some of
the advanced features of registers.  <code>C-x r</code> is the common prefix for
those commands, so you just do <code>C-x r C-h</code> and you get a buffer with
more information.</li>
<li>And, as you may imagine, you can even append the <code>C-h</code> <i>suffix</i> to the <code>C-h</code>
<i>prefix</i>.  This is a fancy way of saying that <code>C-h C-h</code> will show you help
about help commands themselves.  But because this is a special case,
it comes with some extras.  Try it!</li>
</ul>

<p>
<b>All help buffers include links</b> to other parts of Emacs, from where you
can learn ever more information.  For example, the help for <code>C-c C-h</code>
includes links to the commands that correspond to each key chord.
Follow the link to get documentation about that symbol.
</p>

<p>
More generally, you will find that a symbol is linked to its source.
Look carefully at the top of the buffer that displays the symbol's
documentation and you will find a link to the source code (library) from
where the function/variable (symbol) comes from.
</p>

<p>
Also know that the source code can be accessed at any time by means of
<code>M-x find-library</code> followed by the name you are looking for.  Those are
called "features", by the way, and each library declares them using the
<code>provide</code> form at the end of the file (so when you use <code>require</code> you pass a
quoted feature symbol).
</p>

<p>
Help commands that ask you for a symbol to input can also be aware of
the context of the point (the cursor).  If you are over the name of a
function and you type <code>C-h f</code>, that function will be the default match.
Hitting RET (Enter) will take you to its documentation.  <i>This is a great
way to study source code</i>, because it will guide you to other libraries
or other parts of the same library from where you can understand how
things are pieced together.  And it also works with the <code>find-library</code>
command.
</p>

<p>
While browsing Elisp source code, there are two commands that can be of
great help to navigate definitions.  <code>xref-find-definitions</code>, bound to <code>M-.</code>
will take you to the definition of the symbol at point.  While its
counterpart, the <code>xref-pop-marker-stack</code> (<code>M-,</code>), will bring you back to
where you where before.  Similarly, the built-in Isearch tool can search
for the symbol at point with <code>M-s .</code> (the <code>isearch-forward-symbol-at-point</code>
command), which can then be followed up with <code>M-s o</code> to produce an "Occur"
buffer with all the results&#x2014;use that as an index to move around (also
check: <a href="#h:b67687ee-25a3-4bf4-a924-180ccb63c629">Isearch, occur, and extras (prot-search.el)</a>).
</p>

<p>
Finally, you should practice <code>C-h m</code> (<code>describe-mode</code>) as much as possible.
This is the help command for getting information about the major mode
you are in and for all the minor modes you have active and which are
pertinent to the current buffer.  It will show you some valuable
documentation as well as the main key bindings and their commands.  Try
it whenever you use something you have not mastered yet.  For example,
do it in a <code>dired</code> buffer to see the main operations you can perform
inside of it (see <a href="#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d">Dired (directory editor, file manager)</a>).
</p>
</div>
</div>

<div id="outline-container-h:b9233089-5a3a-4e7a-81ef-3ad395a26036" class="outline-3">
<h3 id="h:b9233089-5a3a-4e7a-81ef-3ad395a26036"><span class="section-number-3">9.2.</span> Why maintain all those 'prot-*.el' files?</h3>
<div class="outline-text-3" id="text-h:b9233089-5a3a-4e7a-81ef-3ad395a26036">
<p>
Those contain my custom Elisp code.  Several of them provide extensions
to existing tools, while others introduce some new functionality.  They
are written in accordance with the best coding practices and are, for
all intents and purposes, regular packages even though they only target
my use-case.
</p>

<p>
The main benefits of packaging my code are thus:
</p>

<dl class="org-dl">
<dt>Lexical scope</dt><dd>The code is written in a way that does not introduce
implicit dependencies on the environment.  Everything within the file
has to be known so that the compiler can properly interpret it.</dd>

<dt>Byte compilation</dt><dd>Because of the above, the code compiles cleanly.
This allows me to execute my code a bit faster than it would otherwise
be possible.  The more I write, the greater the otherwise marginal
performance gains.</dd>

<dt>Transparency</dt><dd>Users who copy my code are made aware of its
dependencies, which saves me time answering emails why X or Y from my
dotemacs does not work on another's setup.</dd>

<dt>Modularity</dt><dd>Since my files render their dependencies and bindings
explicit, it is easier to catch errors and debug them.</dd>
</dl>

<p>
While my <code>prot-*.el</code> are distributed as packages, please understand that I
consider this an exercise in programming.  I develop them because I
believe they will be useful to me.  Do not unilaterally put them in some
package archive as I cannot promise that I will keep them around forever
(distributing a package implies a commitment to its users).
</p>
</div>
</div>

<div id="outline-container-h:0077f7e0-409f-4645-a040-018ee9b5b2f2" class="outline-3">
<h3 id="h:0077f7e0-409f-4645-a040-018ee9b5b2f2"><span class="section-number-3">9.3.</span> What is the purpose of "prot/" and "contrib/"?</h3>
<div class="outline-text-3" id="text-h:0077f7e0-409f-4645-a040-018ee9b5b2f2">
<p>
[Also read: <a href="#h:b9233089-5a3a-4e7a-81ef-3ad395a26036">Why maintain all those 'prot-*.el' files?</a>]
</p>

<p>
The <code>prot/</code> prefix in some unpackaged symbols works as a namespace that
captures all my custom, yet-to-be-reviewed code.  These can be functions
or variables.  The utility of this prefix is two-fold:
</p>

<ol class="org-ol">
<li>It informs others that this symbol is not part of core Emacs or some
other package.  Otherwise it can be difficult to understand why
something you copied did not work.  Say, for example, I have a
function that accepts an argument: <code>(prot/function prot/variable)</code>.  If
none of these had the namespace you could be misled into thinking
that your Emacs setup already includes those symbols (and then you
would get an error message).</li>

<li>It makes it easier for me (and others) to quickly discover what
additions I have made, for whatever reason that may.  For instance,
<code>M-x prot/</code> will give me matches for all my interactive functions
(depending on the completion framework, one can access those with
just <code>M-x p/</code>).  This also means that I can do <code>M-x occur prot/</code> to
produce an Occur buffer with all my symbols (pass a numeric argument
to display N lines of context <code>C-u 5 M-s o</code>).  From there I can, say,
browse them all easily or even edit them using the full array of
Emacs' relevant powers (occur's results buffer is made editable with
<code>e</code>, but you should be able to find that by using the information
documented in <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).</li>
</ol>

<p>
The same principles apply to the <code>contrib/</code> namespace.  Whenever I copy
something from another user, I use that namespace to tell others that
this is not part of Emacs or any other package (and I always link to the
source).
</p>

<p>
Adding <code>contrib/</code> also has another longer-term benefit.  It informs my
future self that some bespoke configuration was needed to solve a
particular problem and, maybe, this has since been solved by a good
package, a newer version of Emacs, or I may eventually be able to
furnish my own alternative.
</p>

<p>
Again, <code>occur</code> or similar tools will filter those out when necessary.
Imagine having to do that without any namespaces…  You would need to
check each symbol one by one to determine its origin.
</p>

<p>
The convention of separating namespaces with a forward slash is not
particularly important, though the linter for Elisp packaging will
complain about it, if you ever go down that path.  It could be something
like <code>prot-</code> or <code>my-</code> or whatever.  What matters is to keep things
consistent and fairly easy to identify.
</p>
</div>
</div>

<div id="outline-container-h:ba373e0d-29d1-4224-b0f1-64b640ceeaae" class="outline-3">
<h3 id="h:ba373e0d-29d1-4224-b0f1-64b640ceeaae"><span class="section-number-3">9.4.</span> Why do you use so many `setq'?</h3>
<div class="outline-text-3" id="text-h:ba373e0d-29d1-4224-b0f1-64b640ceeaae">
<p>
To be clear, these are equivalent:
</p>

<pre class="example" id="org86fef6a">
;; Style A
(setq var-1 'symbol)
(setq var-2 '(a b c))
(setq var-3 '((a . b) (c . d)))

;; Style B
(setq var-1 'symbol
      var-2 '(a b c)
      var-3 '((a . b) (c . d)))
</pre>

<p>
You will notice that most of my configurations follow Style A.  I do so
for a couple of reasons:
</p>

<ul class="org-ul">
<li>It makes each variable easier to copy elsewhere, say, when sharing it
online or to an <code>emacs -Q</code> scratch buffer.</li>

<li>It is trivial to run <code>C-x C-e</code> (<code>eval-last-sexp</code>) on each balanced
expression individually (note that <code>C-M-x</code> (<code>eval-defun</code>) can be used in
Elisp buffers to evaluate the expression at point).</li>
</ul>

<p>
There are some cases where I use a single <code>setq</code> to configure several
closely related variables (Style B), but those are the exception to the
norm.
</p>

<p>
Style B gives me more problems with copy-pasting, while it does not
solve any real issues (besides, I finalise style A using a keyboard
macro, so there is no real difference in typing).
</p>

<p>
I find that Style A consists of balanced expressions that are easier to
keep consistent.  This is especially true when you have a mixture of
values: boolean types, property lists, association lists…
</p>
</div>
</div>

<div id="outline-container-h:3e4fefda-c069-4403-a2ad-6d77ee8c0914" class="outline-3">
<h3 id="h:3e4fefda-c069-4403-a2ad-6d77ee8c0914"><span class="section-number-3">9.5.</span> Why do you explicitly set variables the same as default?</h3>
<div class="outline-text-3" id="text-h:3e4fefda-c069-4403-a2ad-6d77ee8c0914">
<p>
You may have realised that many of my configurations will use a <code>setq</code>
that declares a value that is the same as its original in the source
code.  I do this for two reasons:
</p>

<ol class="org-ol">
<li>To raise awareness of its existence.  If someone does not like how
the defaults work, they know where to look.</li>

<li>I guard against future versions that could be changing the defaults.</li>
</ol>

<p>
Obviously point 2 is not particularly strong for built-in libraries that
are already very stable, though I find that, on the balance, nothing bad
comes out of it.
</p>

<p>
At any rate, one must always read the NEWS (<code>C-h n</code> for <code>view-emacs-news</code>)
whenever they upgrade to a new version of Emacs.  Though there is no
equivalent mechanism for individual packages…  So here we are.
</p>

<p>
By the way, the fastest way to find a package's customisation options is
to visit its source code and produce an Occur buffer for its <code>defcustom</code>
configurations (which extends the ideas in <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).
</p>
</div>
</div>

<div id="outline-container-h:a654fcb5-0163-4dc6-977a-8c50175118a1" class="outline-3">
<h3 id="h:a654fcb5-0163-4dc6-977a-8c50175118a1"><span class="section-number-3">9.6.</span> Did you know XYZ package is better than the defaults?</h3>
<div class="outline-text-3" id="text-h:a654fcb5-0163-4dc6-977a-8c50175118a1">
<p>
As a rule of thumb, I choose external packages only after I give a fair
chance to the defaults.  The idea is to take things slowly and learn
along the way, while consulting the official manual and relevant
documentation (I strongly encourage you to study the information I
provide in <a href="#h:83730fe8-d917-4d94-96f4-bbc5c900fe38">How do you learn Emacs?</a>).
</p>

<p>
Without exposure to the built-in tools it is impossible to make an
informed decision about what is actually missing and what could be
improved further.  Additionally, it is difficult to appreciate the
underlying rationale that led to a given element of design without
actually trying to put yourself in that mindset or workflow.
</p>

<p>
Put differently, keep an open mind about the alternatives before
deciding to reproduce the thing you had before, else you are assuming
your prior knowledge to be true in advance of any possible evidence to
the contrary (a sign of dogmatism).
</p>

<p>
The process of learning the internals of Emacs means that I write my own
Elisp functions when I feel that a standard tool could be tweaked on the
margin of its core utility in order to do what I want (read my answer to
the question <a href="#h:b9233089-5a3a-4e7a-81ef-3ad395a26036">Why maintain all those 'prot-*.el' files?</a> as well as the
one on <a href="#h:0077f7e0-409f-4645-a040-018ee9b5b2f2">What is the purpose of "prot/" and "contrib/"?</a>).  External
packages that I do use are either a clear upgrade over the defaults or
otherwise extend the functionality of what is already available.
</p>

<p>
You will not find any superficialities herein: no rainbow-coloured mode
lines, no icons, no tool bars with bells and spinning wheels, nothing.
I respect the fact that they exist, but find that they do not contribute
to my productivity.
</p>

<p>
Though a former Vim user for ~3 years, I decided <b>not</b> to use <code>evil-mode</code> or
any kind of Vi emulation (remember the point about keeping an open
mind?).  I wanted to do things differently in order to ultimately set on
the best approach going forward.  I have eventually settled on a system
that builds on top of the "Emacs way" to key bindings, which I discuss
in my hour-long presentation about <a href="https://protesilaos.com/codelog/2019-12-20-vlog-switch-emacs/">Switching to Emacs</a> (2019-12-20).  I
believe that a mnemonics-based set of keys is easier to get started
with.  It expands organically as you familiarise yourself with the
multitude of Emacs' functionalities: there is an entire world of
applications outside the narrow confines of editing code.
</p>

<p>
Since you read this (and the rest of my dotemacs, I presume), also
consider two highly valuable blog posts by Karthik Chikmagalur:
</p>

<ul class="org-ul">
<li><a href="https://karthinks.com/software/batteries-included-with-emacs/">Batteries included with Emacs</a> (2020-11-17).</li>
<li><a href="https://karthinks.com/software/more-batteries-included-with-emacs/">More batteries included with Emacs</a> (2020-12-11).</li>
</ul>
</div>
</div>

<div id="outline-container-h:7be4b564-4360-4905-aa10-1405fba6ea2a" class="outline-3">
<h3 id="h:7be4b564-4360-4905-aa10-1405fba6ea2a"><span class="section-number-3">9.7.</span> Compare Gnus, Mu4e, Notmuch?</h3>
<div class="outline-text-3" id="text-h:7be4b564-4360-4905-aa10-1405fba6ea2a">
<p>
This question is best answered in reference to one's background and the
intuitions made possible by it.  The short answer is that all three are
good in different ways: the best tool for the job is the one that makes
you most productive in the moment.
</p>

<p>
Now to the longer reply, which fleshes out this time-sensitive
subjectivity I am hinting at.
</p>

<p>
Before switching to Emacs in the summer of 2019, I used to use Mutt or
Thunderbird as a plan B (starting from mid 2016).  At that time I did
not receive a lot of email, maybe 2-3 per week or even less, and did not
follow any mailing lists.  My Mutt setup was just a basic front-end to
the IMAP server, meaning that I did not have anything like <code>offlineimap</code>
or <code>mbsync</code> set up.  My workflow back then was heavily focused on
elaborate directories/folders to store the mail I wanted.  For example,
I had an "archive" directory for each of my three email accounts and
inside of that I had yearly archives.  To cut the long story short, in
order to find an email I had to go looking for it at some exact
location.  It was not efficient, but I was okay with it as my mail
traffic was very low.
</p>

<p>
Once I became a full-time Emacs user, I decided to push the boundaries
of what I could do with email.  The most popular option seemed to be
Mu4e so I picked that one (autumn 2019).  It was easy for me to set up
and I liked its middle-of-the-road approach of combining a typical
directory-based structure with a potent search tool.  I had stopped
doing the complex directory structures with my archives and would keep
everything in my inbox.  Still, the volume of incoming mail was very
low: I was not really using the search features and was reverting to the
directory views instead.
</p>

<p>
Thus I decided to go with Gnus (early 2020) whose value proposition
seemed to be <i>"directories are first-class citizens here, same for
Newsgroup sources"</i>.  Gnus calls all of them "groups" based on its useful
metaphor of treating everything as ephemeral news.  What I learnt from
my time with Gnus is that:
</p>

<ol class="org-ol">
<li>Mailing lists are worth paying attention to as you can learn a lot
from other people's input in various conversations (emacs-devel, bug
reports, etc.).</li>

<li>It is good to use <code>mbsync</code> or equivalent as it removes the burden from
Emacs and allows you to keep a copy of your mail correspondence.  I
had started with Gnus' nnimap backend, which communicated directly
with the IMAP server, but once my email traffic started to increase,
I learnt the hard way that <code>mbsync</code> was better suited for the task, as
it did not block Emacs.</li>

<li>Directory-based workflows do not scale.  As I started to get more
email, I realised that I often needed to quickly retrieve some piece
of information that was kept in one of my three inbox directories or
some other location.  Gnus has search methods but there are
inconsistencies between nntp, nnmaildir, etc. to the effect that I
would need to have special rules for each case.  Maybe I did not read
the manual very carefully?  Perhaps I did not understand something?
At any rate, it did not feel like worth the effort.</li>
</ol>

<p>
The search engine I wanted to use with Gnus was <code>notmuch</code>, because it is
mentioned in the Gnus manual.  As I was looking for a way to be in full
control of my email setup, I thought it would be better to try Notmuch
without the layer of abstraction that Gnus added on top of it, stop
following a directory-based workflow, and embrace filtering and
narrowing (concepts I learnt to appreciate through my daily usage of
Emacs).
</p>

<p>
My few test on the command-line convinced me to refactor my email setup.
So I decided to read through all the manpages and then go with
notmuch.el (made the switch between 2021-05-13 and 2021-05-14).  I did
not want to revert to Mu4e because I had the feeling that its hybrid
approach to directories and search would push me back to my old
inefficient habits.  Whereas Notmuch is all about tagging and filtering,
which makes me believe that I can push myself into new territory (the
configs and docs: <a href="#h:a196812e-1644-4536-84ba-687366867def">Notmuch (mail indexer and mail user agent (MUA))</a>).
</p>

<p>
This is not to say that any of these tools is inherently better/worse
than its peers.  You can be productive with all three of them (my old
configurations for Mu4e and Gnus can be found in <a href="https://gitlab.com/protesilaos/dotfiles">my dotfiles' repo</a>).
What matters is to identify your requirements, set your expectations or
ambitions, and pick the option that can optimise your productivity.  The
point is to not be dogmatic about it: just use what works for you the
same way I did in through journey to where I currently am.
</p>
</div>
</div>

<div id="outline-container-h:7e4448ec-3878-4ea2-9cd6-75e9faaac373" class="outline-3">
<h3 id="h:7e4448ec-3878-4ea2-9cd6-75e9faaac373"><span class="section-number-3">9.8.</span> Have you tried Gnus for RSS feeds?</h3>
<div class="outline-text-3" id="text-h:7e4448ec-3878-4ea2-9cd6-75e9faaac373">
<p>
<b>NOTE 2021-05-13:</b> This question used to pop up when I was using Gnus as
my mail client.  Though I have since switched to Notmuch, I think the
information provided here remains relevant.
</p>


<p>
For the relevant setup, refer to the mega-section on <a href="#h:5ad80664-3163-4d9d-be65-462637d77903">Email settings</a>.
</p>

<p>
I tried to make feeds work with Gnus because I generally like it and
wish to extend it further.  The issues I encountered are manifold.
These qualify as "problems" based on my expectations, so please do not
take this as a pretence of objectivity.
</p>

<ol class="org-ol">
<li>The <code>nnrss</code> backend does not support the Atom spec.  To make feeds work
you need to pipe them through some other script that will convert
them to the RSS format.  I do not like that, because it puts the
burden on the user for something that should work out-of-the-box.
The Atom spec has been around for a long time; long enough to expect
feed readers to have caught up to the current state of affairs.</li>

<li>The <code>nnrss-opml-import</code> command prompts you twice for every feed.
First to confirm it and then to add a name for it.  Try that for,
say, 200 feeds.  Not pretty.  Maybe there is some way to bypass this
and just do it programmatically.  I could not find it.  Again, this
may be due to my false expectations, where I consider it a basic
thing that should "just work" (because while I like customising
everything, this is not a substitute for things working well by
default).</li>

<li>Fetching feeds blocks Emacs entirely.  Especially when the list is
long.  Again, think of a 200-long list.  I am fine with this
happening for email when I choose to update things manually, because
I only have three accounts and the interruption is barely noticeable.
But it otherwise is a show-stopper.  This means that you must run the
process externally.  Fine in principle, though I cannot avoid the
fact that Elfeed already has an option for that (also refer to the
section <a href="#h:0cd8ddab-55d1-40df-b3db-1234850792ba">Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el</a>).</li>

<li>Updating feeds often produces duplicate items or fetches the same
item again, even though it was already read.  The solution is to
customise <code>nnrss-ignore-article-fields</code>.  Its default value is an XML
tag that you only learn about if you actually read a relevant feed's
source code: "(slash:comments)".  So if you want to, say, ignore the
published date, you need to check the XML and find the <code>pubDate</code> tag.
Fine, I can do that, but it is not a good idea to expect users to
know such technicalities.</li>

<li>Gwene is a good compromise in lieu of a genuine solution, namely:
proper support for the Atom spec and the option to fetch feed updates
through curl/wget (or equivalent).  However, I do not like the whole
workflow around it.  It runs contrary to what I am doing with Emacs:
which is to control things from inside of Emacs.  Gwene is a website
facade and a public server.  You go to the website to upload your
OPML file.  Where is the <code>M-x</code> command for that?  And why should a list
of decentralised feeds be dependent on a centralised server, anyway?
And why should the list be made public?  What about private feeds?</li>
</ol>

<p>
Apologies if this sounds too negative.  I am sure there are workarounds
and there is always a good chance that either I missed something, or I
simply am not knowledgeable enough to make Gnus+Feeds work properly.  I
also wish I had better Elisp skills to help patch those issues in core
Emacs, but I must work with what I have.
</p>
</div>
</div>

<div id="outline-container-h:fbba4dea-9cc8-4e73-bffa-02aab10a6703" class="outline-3">
<h3 id="h:fbba4dea-9cc8-4e73-bffa-02aab10a6703"><span class="section-number-3">9.9.</span> What is the meaning of the `s-KEY' bindings?</h3>
<div class="outline-text-3" id="text-h:fbba4dea-9cc8-4e73-bffa-02aab10a6703">
<p>
Some sections of this document assign functions to key combinations that
involve the "Super" key (also known as the "Windows key" on some
commercial keyboards).  This is represented as a lower case <code>s</code>.
</p>

<p>
Those key bindings typically are alternative ways of invoking <i>common
commands</i> that are by default bound to longer key chords.  The original
keys will continue to function as intended (for example, <code>C-x o</code> is also
<code>s-o</code>).  Otherwise they are bound to my own custom commands.
</p>

<p>
To find all my keybindings of this sort in the source code version of
this document from inside of Emacs, do <code>M-s o</code> (or <code>M-x occur</code>) followed by
the pattern <code>"[a-zA-Z&lt;]?-?s-.+?"</code> (please contact me if you know how to
improve this).
</p>

<p>
Note that your choice of desktop environment (or window manager) might
render some of those useless.  The DE/WM will simply intercept the key
chord before it is ever sent to Emacs.  For example, GNOME has a <b>hidden</b>
key mapping to <code>s-p</code>, which does something with monitors (last time I
checked on GNOME 3.30).  Such bindings are scattered throughout the
config database that is normally accessed with <code>gsettings</code> on the command
line or the graphical <code>dconf-editor</code> (not pretty either way).  For me this
is not a problem, because I disable all of the DE's key bindings (also
read: <a href="#h:044977f2-a909-4804-bf89-576dd429d405">What is your distro and/or window manager?</a>).
</p>
</div>
</div>

<div id="outline-container-h:0675f798-e2d9-4762-9df2-f47cd24cf00a" class="outline-3">
<h3 id="h:0675f798-e2d9-4762-9df2-f47cd24cf00a"><span class="section-number-3">9.10.</span> How to reproduce your dotemacs?</h3>
<div class="outline-text-3" id="text-h:0675f798-e2d9-4762-9df2-f47cd24cf00a">
<p>
<i>Remember that I am not using Emacs 27 or some other stable release.  I
currently am on GNU Emacs 29.0.50.</i>
</p>

<p>
First you must understand that this is my personal setup: I have never
tried to develop a framework that works out-of-the-box for other users.
It runs contrary to how I approach Emacs as a long-term investment that
involves learning everything from the basics to the more advanced
issues: which means starting from scratch while being patient,
persistent, and humble.
</p>

<p>
Furthermore, it is important to understand that the very nature of this
setup makes it highly opinionated and, thus, several of its components
may be predicated on implicit assumptions about preferences.  For
example, I only use my Modus themes because that is the design I want to
interface with, and will therefore not make any effort whatsoever to
provide options that can let someone pick a theme out of the multitude
that is on offer: this is not to say that those options are inherently
wrong, just that they make no sense in a <i>personal Emacs setup</i>.
</p>

<p>
As you may know from René Magritte's famous <i>Ceci n'est pas une pipe</i>
painting, what you think you are looking at is not equivalent to its
actuality.  You may be led to believe that my dotemacs is in fact an
"Emacs distro", or "starter kit", or whatnot, and that you can just
clone it and re-use it right away.  In truth <i>ceci n'est pas une
distribution Emacs</i>.  It is my personal setup.
</p>

<p>
With those granted, I understand that people may want to benefit from
what I already make public and, in turn, I want to help them to that
end.  It is not my intent to create impediments to one's progress as an
Emacs user, nor to obfuscate my otherwise readily available corpus of
labour.  I wish to make things easy and accessible, without prejudice to
the aforementioned points about what <i>this</i> is.
</p>

<p>
To reproduce my setup, you first need to clone my dotfiles' repository.
This includes more stuff than just my Emacs files, though it is what I
use.  Let's say you plan to clone the repo at <code>~/Git/prot-dotfiles</code>.  You
invoke this command from your shell:
</p>

<pre class="example" id="org0c7d436">
git clone https://gitlab.com/protesilaos/dotfiles.git ~/Git/prot-dotfiles
</pre>

<p>
If you do not want to copy the entire history of the project, you can
pass the <code>--depth</code> flag, like this:
</p>

<pre class="example" id="orgde723cc">
git clone --depth 1 https://gitlab.com/protesilaos/dotfiles.git ~/Git/prot-dotfiles
</pre>

<p>
That one fetches just the latest commit and is considerably faster.
Though the full history is useful if you plan to retrieve some datum
from it.
</p>

<p>
My dotfiles are managed with the help of the GNU Stow program.  What
that does is create and handle symlinks from a source directory to a
destination.  The file structure of my dotfiles is designed to reflect
the expected end result at the <code>$HOME</code> directory.
</p>

<p>
Stow operates on what it calls a "package": a set of files whose file
structure will be reproduced at the target filesystem path.  Take a look
at the tree representation of my "emacs package", per Stow's parlance
(this output may not be exactly the same you will get depending on when
you review it, but that is beside the point).
</p>

<pre class="example" id="orgc9bd377">
~/Git/prot-dotfiles $ tree -aF --dirsfirst emacs
emacs
└── .emacs.d/
    ├── modus-themes/
    │   ├── modus-operandi-theme.el
    │   ├── modus-themes.el
    │   └── modus-vivendi-theme.el
    ├── prot-lisp/
    │   ├── prot-bongo.el
    │   ├── prot-comment.el
    │   ├── prot-common.el
    │   ├── prot-consult.el
    │   ├── prot-cursor.el
    │   ├── prot-diff.el
    │   ├── prot-dired.el
    │   ├── prot-elfeed-bongo.el
    │   ├── prot-elfeed.el
    │   ├── prot-embark.el
    │   ├── prot-embark-extras.el
    │   ├── prot-eshell.el
    │   ├── prot-fill.el
    │   ├── prot-fonts.el
    │   ├── prot-mail.el
    │   ├── prot-ibuffer.el
    │   ├── prot-icomplete.el
    │   ├── prot-logos.el
    │   ├── prot-minibuffer.el
    │   ├── prot-moody.el
    │   ├── prot-orderless.el
    │   ├── prot-outline.el
    │   ├── prot-project.el
    │   ├── prot-pulse.el
    │   ├── prot-recentf.el
    │   ├── prot-search.el
    │   ├── prot-sideline.el
    │   ├── prot-simple.el
    │   ├── prot-spell.el
    │   ├── prot-tab.el
    │   ├── prot-text.el
    │   ├── prot-vc.el
    │   ├── tmr.el
    │   └── usls.el
    ├── basic-init.el
    ├── early-init.el
    ├── init.el
    ├── prot-emacs.org
    └── user-emacs.org

3 directories, 42 files
</pre>

<p>
When we invoke a <code>stow</code> command on this <code>emacs</code> package we are instructing
the program to create symlinks to a directory called <code>.emacs.d</code> and to
place all relevant files/directories inside of it.  What we want is to
mirror this tree in our <code>$HOME</code> directory (I only use GNU/Linux, by the
way):
</p>

<pre class="example" id="org8153b2e">
~/Git/prot-dotfiles $ stow -t "$HOME" emacs
</pre>

<p>
As you will learn from Stow's manpage, the <code>-t</code> flag points at the target
destination.  So we want to mirror the <code>.emacs.d</code> of my dotfiles to that
found in <code>~/.emacs.d</code>.  If the latter exists, only the relevant files will
be symlinked.  Otherwise it will be created outright as a symlink
itself.
</p>

<p>
If files that conflict with mine, like <code>init.el</code>, already exist at the
target path, then Stow will throw an error and abort its operation.
This is good: we do not want to overwrite existing data.  So make sure
to create backups of everything and move them to another location.
</p>

<p>
Whenever I add or remove a file, my "emacs package" needs to be updated
accordingly: the symlinks have to be generated anew.  Adding the <code>-R</code> flag
does the trick:
</p>

<pre class="example" id="orge0bcc2d">
~/Git/prot-dotfiles $ stow -t "$HOME" -R emacs
</pre>

<p>
Similarly, if you ever want to delete those symlinks in a clean way,
pass the <code>-D</code> flag instead of <code>-R</code>:
</p>

<pre class="example" id="org5ba62fd">
~/Git/prot-dotfiles $ stow -t "$HOME" -D emacs
</pre>

<p>
The same is true for all other "packages" in my dotfiles' repo.
</p>

<p>
At this point you are ready to start using my Emacs setup.  But not
everything will work just yet.  As was already discussed in the section
about <a href="#h:584c3604-55a1-49d0-9c31-abe46cb1f028">Main macros and other contents of my init.el (for Emacs 28)</a>, I
have a policy of not auto-installing packages by default.  If you want
to do that when you first launch my Emacs, you must create a new file
called <code>basic-init.el</code> and place it in the same place where my <code>init.el</code> and
<code>prot-emacs.org</code> are found (the <code>basic-init.el</code> is read before initiating my
main configuration file).  In that file you must add the following:
</p>

<pre class="example" id="orgd8440ee">
(setq prot-emacs-autoinstall-elpa t)
</pre>

<p>
This means that you explicitly opt in to automatically installing all my
defined packages that are found in GNU ELPA or MELPA.
</p>

<p>
If you do not create the <code>basic-init.el</code> with those contents, then the
default behaviour is to run my setup and produce a series of warnings
about missing packages that you need to install on your own.  The
resulting log's messages will explain how to do that in one go, though
you can always opt for another approach if you want.  This default
method offers you the opportunity to think carefully about what packages
you really need and proceed to remove the ones you do not want to keep
around.
</p>

<p>
Whatever you do with the installation of items from Emacs Lisp Package
Archives, you will always have to manually configure the few packages I
maintain through their source code.  Again, the warning messages will
tell you what they expect from you.  Basically, you will need to look up
their names in the <code>prot-emacs.org</code> file to find their repo's URL.  Then
you will have to clone that to the <code>contrib-elisp</code> path inside of your
<code>.emacs.d</code>.  Or comment out their code block (or delete it) if you do not
want them.
</p>

<p>
You are finally done and ready to start using what I develop.  And you
have realised by now that <i>this definitely is my personal Emacs setup and
I only target my use-case</i> which means, among others, that I will never
add bells and whistles that I do not use just to satisfy demand for them
(e.g. icons).
</p>

<p>
To append your own configurations, you can create a new <code>user-emacs.org</code>
file and place it in the same path as my <code>prot-emacs.org</code>.  It must
include code blocks like the ones I provide in my Org config.  Those
will be evaluated at startup and everything will work as expected:
<code>user-emacs.org</code> is loaded after <code>prot-emacs.org</code> and you assume
responsibility for everything.
</p>

<p>
This hopefully covers it.  If you have any questions, either open an
issue in <a href="https://gitlab.com/protesilaos/dotfiles/">my dotfiles' repo</a> or <a href="https://protesilaos.com/contact/">contact me directly</a>.  Remember that I wish
to be helpful, though I have no plan to turn this into yet another Emacs
distro.
</p>
</div>
</div>

<div id="outline-container-h:044977f2-a909-4804-bf89-576dd429d405" class="outline-3">
<h3 id="h:044977f2-a909-4804-bf89-576dd429d405"><span class="section-number-3">9.11.</span> What is your distro and/or window manager?</h3>
<div class="outline-text-3" id="text-h:044977f2-a909-4804-bf89-576dd429d405">
<p>
I have been on GNU/Linux since the summer of 2016.  For the most time I
have used Debian and Arch Linux, switching between the two.  As of
2020-05-03, I am back on Arch.
</p>

<p>
My criterion for picking a distro is that it is community-driven and has
a strong following to ensure its longer-term continuity and overall
stability.  This happens to be consistent with my current focus on
Emacs: I need things to work so that I may not be bothered by too many
administrative tasks (and yes, Arch is super-stable once you know what
you are doing&#x2014;and, well, Debian is designed for that).
</p>

<p>
Given that I mostly live inside of Emacs, the desktop environment is not
super important to me.  Though I still like to configure things to my
liking, partially because it gives me a predictable environment but also
for the inherent fun of it.
</p>

<p>
I run a custom session centred around a tiling window manager.  Normally
this is bspwm (Binary Space Partitioning Window Manager), though my
dotfiles also include configurations for (i) swaywm and (ii)
herbstluftwm.  The former is a Wayland compositor.  I keep it as a
reliable solution for the inevitable Wayland future (Xorg is in
maintenance mode, but it still works perfectly fine for my needs).
While the latter is conceptually similar to bspwm, with the major
exception being how it handles monitors and workspaces.
</p>

<p>
As of 2021-11-08, I have an ultrawide display as part of a temporary
exchange.  My bspwm is not optimised for it, because contents start off
far to the left.  It is possible to make it behave in a desirable
fashion, but I don't want to adapt my setup to this monitor and then
revert back to what I had before.  So I am using herbstluftwm for the
time being, which lets me designate areas of the physical display as
virtual monitors.  So I divide the 2560x1080 area into two parts with
the right one being 1920x1080.  This means that my Emacs goes to the
right virtual monitor and its left window (the Emacs concept of
"window") is positioned closer to the centre of the display.  My setup
includes a shell script which splits the display in three, with the
largest area in the middle.
</p>

<p>
Herbstluftwm's virtual monitors are not mere workspaces.  They do
confine everything inside of them, as if they were physical displays.
Fullscreen mode, for example.
</p>

<p>
None of my tiling window managers is as well documented as my Emacs
setup.  I do plan to improve things at some point.  Until then, my
dotfiles are only intended for experienced users or, generally, those
who understand that they will handle everything on their own:
<a href="https://gitlab.com/protesilaos/dotfiles">https://gitlab.com/protesilaos/dotfiles</a>.
</p>

<p>
My Emacs is <a href="https://git.savannah.gnu.org/cgit/emacs.git/">built from source</a>, directly from trunk (i.e. the <code>master</code>
branch).
</p>
</div>
</div>

<div id="outline-container-h:e134a8b2-224e-4383-bf03-b080ab6659c7" class="outline-3">
<h3 id="h:e134a8b2-224e-4383-bf03-b080ab6659c7"><span class="section-number-3">9.12.</span> What hardware do you use?</h3>
<div class="outline-text-3" id="text-h:e134a8b2-224e-4383-bf03-b080ab6659c7">
<p>
I used to have a Lenovo Thinkpad X220 which I purchased in 2018 for ~80
EUR.  In early August 2021 its battery stopped working and, for reasons
I do not understand, it does not power up without it even though the
Internet tells me it should&#x2026;
</p>

<p>
Watch: <a href="https://protesilaos.com/codelog/2021-08-29-emacs-community-new-pc/">The Emacs community bought me a new PC</a> (2021-08-29).
</p>

<p>
After the <a href="https://protesilaos.com/news/2021-08-16-status-update-computer/">donations I received up until August 16 2021</a>, which amounted
to 430 EUR, I contacted a friend of mine who is tech-savvy and was able
to build a custom desktop computer with his help.  I don't have the full
picture of all the specs, as I know very little about hardware (the
first computer I ever owned was my laptop and now this one) and my
friend was the one who took care of everything.
</p>

<p>
In the following table the discepancy between the values in the column
"my cost" and "brand new" indicates that the component came second-hand.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Component</th>
<th scope="col" class="org-left">Specification</th>
<th scope="col" class="org-right">My cost</th>
<th scope="col" class="org-right">Brand new</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GPU</td>
<td class="org-left">VGA BIOSTAR AMD RADEON RX560 2GB VA5615RF21</td>
<td class="org-right">100</td>
<td class="org-right">140</td>
</tr>

<tr>
<td class="org-left">CPU</td>
<td class="org-left">AMD RYZEN 5 1600 AF 3.20GHZ 6-CORE</td>
<td class="org-right">120</td>
<td class="org-right">180</td>
</tr>

<tr>
<td class="org-left">RAM</td>
<td class="org-left">TEAM GROUP TED416G2400C1601 ELITE 16GB DDR4 2400MHZ</td>
<td class="org-right">83</td>
<td class="org-right">83</td>
</tr>

<tr>
<td class="org-left">MOTHERBOARD</td>
<td class="org-left">ASUS PRIME B450M - A II</td>
<td class="org-right">85</td>
<td class="org-right">85</td>
</tr>

<tr>
<td class="org-left">Fans</td>
<td class="org-left">Don't know</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">Power supply</td>
<td class="org-left">Don't know</td>
<td class="org-right">30</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-left">Box</td>
<td class="org-left">Don't know</td>
<td class="org-right">30</td>
<td class="org-right">30</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">458</td>
<td class="org-right">558</td>
</tr>
</tbody>
</table>

<p>
Other components I already had: monitor, mouse, keyboard, speakers.  I
had acquired those over the years.  The keyboard is a generic Qwerty
layout that I got from a toy store for 7 EUR together with a small mouse
(the size of the mouse is about half that of a regular one).  The mouse
is annoying to work with (thankfully not often), though the keyboard
feels better than what its cost suggests&#x2014;still toy-level though.  Same
for the speakers, which I think cost 8 or 10 EUR.  The monitor is
1920x1080 and the best part is that I got it free of charge from a
clearance several years ago, before I even had the Thinkpad.
</p>

<p>
As of 2021-11-08, I exchanged that monitor with a friend's ultrawide
one, which is 2560x1080.  I thought I would experiment with it for a
while to see what kind of software solutions can be applied to such an
otherwise awkward ratio (<a href="#h:044977f2-a909-4804-bf89-576dd429d405">What is your distro and/or window manager?</a>).
While my friend needs to use a dual monitor setup for some work.
</p>

<p>
On the day I got the computer (August 6, 2021), I got a camera and
microphone for 40 EUR combined.  Now I have a good setup in place to do
live streams in addition to the prerecorded videos I would produce.
</p>

<p>
Since we are here: the recording software is OBS Studio, while I do no
video editing whatsoever.
</p>
</div>
</div>
</div>

<div id="outline-container-h:7b39c38c-ae23-4385-b439-afca89baca52" class="outline-2">
<h2 id="h:7b39c38c-ae23-4385-b439-afca89baca52"><span class="section-number-2">10.</span> Other people's Emacs work</h2>
<div class="outline-text-2" id="text-h:7b39c38c-ae23-4385-b439-afca89baca52">
<p>
Emacs is both a piece of software and a diverse community of people that
are brought together by their shared interest in this unique program.
Emacs' development unfolds through a distributed network of volunteers,
coordinated by members of the GNU project.  While the community at-large
develops and ultimately internalises lots of valuable ideas to a pool of
accumulated knowledge, such as configurations with custom Elisp code,
video or written tutorials on particular workflows, and packages that
cover a broad range of needs.
</p>

<p>
Outside the narrow confines of the computer, Emacs is its people.
</p>

<p>
Here is a non-exhaustive list of users that I have found to be helpful,
each in their own unique way&#x2014;the order is not significant:
</p>

<dl class="org-dl">
<dt>Omar Antolín Camarena</dt><dd>Omar's work is mentioned several times in
this document (author of Orderless, Embark, and co-author of
Marginalia).  Apart from those inherently useful packages, Omar has
helped me several times with various programming issues by sharing
concrete code examples.  Make sure to check Omar's packages and also
monitor <a href="https://github.com/oantolin/emacs-config">the personal Emacs configuration</a> which doubles as a laboratory
of experimentation for new packages or other useful ideas.</dd>

<dt>Daniel Mendler</dt><dd>Daniel's name is referenced in a number of this
document's sections (author of Consult, Corfu, Vertico, Recursion
indicator, co-author of Marginalia together with Omar&#x2014;you get the
idea).  As far as I can tell, Daniel does not share an Emacs
configuration, though one can still learn a lot by studying the code
of the numerous repositories on <a href="https://github.com/minad">@minad's Github</a>.</dd>

<dt>Manuel Uberti</dt><dd>Manuel's contributions have been of paramount
importance to the development of my Modus themes.  Manuel offers a lot
to the Emacs milieu through code contributions but also by reporting
issues and communicating with package maintainers.  The domain name
<a href="https://www.manueluberti.eu/">www.manueluberti.eu</a> hosts a blog with Manuel's musings on Emacs.  For
example, you will find articles that I have already referenced in this
document, such as <a href="https://www.manueluberti.eu/emacs/2020/11/14/extending-project/">Extending project.el</a>.  If you are interested in
cinema like Manuel, do not miss the reviews on <a href="https://www.filmsinwords.eu/">www.filmsinwords.eu</a>.</dd>

<dt>Nicolas De Jaeghere</dt><dd>Nicolas is another contributor to my Modus
themes and has helped me understand several Elisp concepts, such as by
helping me refine the macros that are defined in my <code>init.el</code>.  Nicolas
maintains <a href="https://github.com/Koekelas/dotfiles">a personal dotfiles repo</a> where you can find an <code>emacs.org</code>
file with lots of advanced code snippets.</dd>

<dt>Adam Porter (aka alphapapa, github-alphapapa)</dt><dd>Adam is a prolific
contributor to the Emacs packaging milieu and a prominent member of
the community on the <code>r/emacs</code> subreddit.  <a href="https://github.com/alphapapa">Adam's packages on Github</a>
cover a wide range of needs and are designed using excellent coding
practices.  These include a client for the Matrix communication
protocol (<code>ement.el</code>), a robust query language for Org (<code>org-ql</code>), a code
colouriser that applies colour based on the level of depth (<code>prism.el</code>),
a powerful buffer-management system (<code>bufler.el</code>), a sticky header that
shows the first line of the code's definition when that is outside the
visible window (<code>topsy.el</code>), a tool that tracks your position across
Emacs buffers so you can return exactly to where you need to be
(<code>dogears.el</code>)&#x2026;  You get the idea.  I still plan to incorporate some
of those into my workflow, starting with dogears, topsy, and bufler.</dd>

<dt>Andrew Tropin</dt><dd>Andrew is a programmer and contributor to free
software who also produces <a href="https://www.youtube.com/channel/UCuj_loxODrOPxSsXDfJmpng">live streams on Youtube</a> about various
Emacs-related topics, as well as the Guix System.  You will find
valuable information there, such as a Git workflow about pull requests
as compared to patches, an advanced email setup with Emacs+Notmuch,
and project management.  Andrew's <code>rde</code> is <a href="https://sr.ht/~abcdw/rde/">a suite of tools</a> that manages
computing environments in Guix.</dd>

<dt>Rainer König</dt><dd>Rainer has <a href="https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE">a series of video tutorials</a> on how to
organise your life using various Org features, such as check-lists and
the agenda.  Each video covers a single utility or closely related
concepts, while the whole playlist offers a progression from basic to
more advanced workflows.  Highly recommended!</dd>

<dt>Mike Zamansky</dt><dd>Mike is a computer science professor who has been
doing <a href="https://www.youtube.com/channel/UCxkMDXQ5qzYOgXPRnOBrp1w">videos on Emacs</a> for several years.  There is a wealth of
information to parse from those presentations as well as the
corresponding <a href="https://github.com/zamansky/dot-emacs">dot-emacs code repository</a>.</dd>

<dt>Emacs Elements</dt><dd>This is <a href="https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ">a channel on Youtube</a> where Raoul Comninos
shows how to get things done using Emacs.  There are tutorials on how
to use the <code>diary</code>, <code>calendar</code>, and <code>org-agenda</code>, while you will also find
more advanced topics such as how to install, use, and make sense of
the powerful Icicles completion framework, as well as other useful
packages.</dd>

<dt>System Crafters</dt><dd>David Wilson's work on Emacs covers a broad range
of themes, encapsulated in the <a href="https://github.com/daviwil/emacs-from-scratch">Emacs from scratch</a> configuration.  The
<a href="https://youtube.com/c/SystemCrafters">Youtube channel</a> contains lots of videos on how to set up and use all
sorts of packages in Emacs, such as Org and the Mu4e email client.  It
is fair to say that if something is related to Emacs, David has either
already done a video about it or is planning to do one in the near
future.  The <a href="https://systemcrafters.cc/">System Crafters</a> website includes references to all such
work, while it also covers contributions by the community that David
has helped foster.  The material on offer is top-notch.  It serves as
an excellent resource and point of reference for new and experienced
users alike.</dd>

<dt>Alain M. Lafon</dt><dd>Alain is one of my early influences in my Emacs
journey.  As soon as I had made the switch, I watched the video
presentation <a href="https://www.youtube.com/watch?v=gfZDwYeBlO4">Play Emacs like an instrument</a>, which shows some advanced
workflows of using Emacs in a seemingly effortless fashion.  I knew
Emacs was good, but did not realise it could be <i>that good</i>.  Alain is a
programmer as well as a Zen monk, who is the founder and CEO of the
200ok consultancy.  The <a href="https://200ok.ch/blog.html">consultancy's blog</a> contains a lot of articles
and guides on Emacs, while you can find video tutorials on similar
topics over at <a href="https://www.youtube.com/channel/UCIFJHWyIlN0XFrW2vMKG6QA">Alain's Youtube channel</a>.</dd>

<dt>Xah Lee</dt><dd>Xah is a well-known member of the community through years
of contributions either with packages or <a href="http://www.xahlee.info/">informational websites</a> on
various aspects of Emacs.  On <a href="https://www.youtube.com/channel/UCXEJNKH9I4xsoyUNN3IL96A">Xah's Youtube channel</a> you will find
videos about Emacs on all sorts of topics.  Those are live streamed.</dd>

<dt>Karthik Chikmagalur</dt><dd>Karthik's <a href="https://karthinks.com/software/batteries-included-with-emacs/">Batteries included with Emacs</a>
(2020-11-17) and <a href="https://karthinks.com/software/more-batteries-included-with-emacs/">More batteries included with Emacs</a> (2020-12-11) are
essential reading for anyone wanting to gain an overview of some of
Emacs' built-in capabilities and learn about its 'hidden gems'.
Another excellent piece is <a href="https://karthinks.com/software/fifteen-ways-to-use-embark/">Fifteen ways to use Embark</a> (2021-10-06).
Karthik's website includes philosophical insights as well, such as
those found in <a href="https://karthinks.com/blog/thoughts-on-strength-training/">Thoughts on Strength Training</a> (2019-03-02).  You will
also discover packages by Karthik in this document, such as
<code>consult-dir</code> and <code>project-x</code>.</dd>

<dt>James Norman Vladimir Cash</dt><dd>James produces videos on Emacs, such as
this one <a href="https://occasionallycogent.com/custom_emacs_modeline_video_edition/index.html">on customising the modeline</a> and writes about similar topics,
like reading email in Emacs.  Though I also appreciate commentary of a
political sort: <a href="https://occasionallycogent.com/against_mindless_minimalism/index.html">Against Mindless Software Minimalism</a> (2019-03-24).</dd>

<dt>Karl Voit</dt><dd>Karl is an expert in Personal Information Management
(PIM) covering that and relevant topics over at <a href="https://karl-voit.at/">karl-voit.at</a>.  There
are lots of interesting articles on offer, such as how to organise
data with <a href="https://karl-voit.at/2020/01/25/avoid-complex-folder-hierarchies/">Don't Do Complex Folder Hierarchies</a> and to keep a web
presence with <a href="https://karl-voit.at/2020/10/23/avoid-web-forums/">Don't Contribute Anything Relevant in Web Forums</a>.  Karl
also participated in the 2021 edition of the <i>Grazer Linuxtage</i>
conference with <a href="https://karl-voit.at/2021/04/10/GLT21-emacs-org-features/">a talk on Org features and extras</a>.</dd>

<dt>Sacha Chua</dt><dd>Sacha's work is instrumental to the Emacs community's
self awareness.  The <a href="https://sachachua.com/blog/category/geek/emacs/">weekly "Emacs news" blog entries</a> offers an
overview of what is happening in our space&#x2014;consider it essential
reading.  While Sacha was among the organisers of the last two yearly
Emacsconf events and has shared a lot of valuable insights throughout
the years, such as hand-drawn guides to using Emacs, chats with
prominent members of the Emacs community, and more.</dd>

<dt>Bozhidar Batsov</dt><dd>Bozhidar is the maintainer of several popular Emacs
packages (and not only), such as the <a href="https://github.com/bbatsov/projectile">Projectile library</a> for
interacting with projects (like a Git repo), the <a href="https://github.com/bbatsov/prelude">Prelude starter kit</a>
which tries to enhance&#x2014;but otherwise remain faithful to&#x2014;the
standard Emacs experience, ports of the popular Zenburn and Solarized
themes, as well as the informative <a href="https://emacsredux.com/">blog Emacs redux</a>.</dd>

<dt>Timothy (aka tecosaur)</dt><dd>Timothy, better known as TEC or tecosaur, is
the designer of the current iteration of the <a href="https://orgmode.org/">Org-mode web page</a> and
provides, among others, the blog <a href="https://blog.tecosaur.com/tmio/archive.html">This Month in Org</a> which, as it name
implies, offers a monthly overview of noteworthy new snippets that
concern the development of the deservedly beloved Org-mode.</dd>

<dt>Irreal</dt><dd>Jon Snader's <a href="https://irreal.org/blog/">Irreal blog</a> is one of the best places to start
learning about the people in the wider Emacs community and to continue
keeping track of their projects.  Irreal offers curated summaries of
our fellow Emacsers' contributions, as well as original entries.  Jon
takes the time to cover the main points in one's work and, where
appropriate, to highlight relevant information or offer a valuable
insight.</dd>

<dt>Álvaro Ramírez (aka xenodium)</dt><dd>Álvaro maintains a blog on Emacs and
related programming topics: <a href="https://xenodium.com">https://xenodium.com</a>.  One of my favourite
aspects about the posts you will find there are the high quality GIFs
that capture some precise and very powerful Emacs motion, custom
command, or workflow.  Álvaro is, among others, the developer of a
mobile app that helps you track your habits: <a href="https://flathabits.com/">Flat Habits</a>.  And the
best part is that it is all powered by Org mode!</dd>
</dl>

<p>
Please note that this is a non-exhaustive list.  Lots of people
contribute to the betterment of Emacs proper and to specialised
packages, such as Jonas Bernoulli (developer of Magit, among many
others), Oleh Krehel (developer of Ivy, Counsel, Swiper, and more),
Thierry Volpiatto (maintainer of Helm), Bastien Guerry (Org maintainer),
Eli Zaretskii (Emacs maintainer), Lars Ingebrigtsen (author of Gnus,
co-maintainer of Emacs), Dmitry Gutov (maintainer of several built-in
subsystems like project.el, as well as external packages like Company,
diff-hl&#x2026;), Henrik Lissner (author and maintainer of Doom Emacs), the
ever-resourceful maintainers and contributors to Org-roam, and many
others.
</p>

<p>
For my part, I wish to express my gratitude to all those who have
contributed to my own projects, including the ones who have sent patches
against my Emacs setup, but also users who have reported issues, shared
insights, provided code and suggestions for my Modus themes.  The
themes' manual (which is 27k words as of this writing on 2021-07-27)
contains an "Acknowledgements" section where everyone is included.  I
think the least we can do is acknowledge how much we as individuals
benefit from the communities that organically grow around our projects.
</p>

<p>
Every bit counts: a bug report, a blog post detailing one's workflow,
participation in a mailing list thread, etc.  Do not hesitate to add
your part and become a member of this wonderful community.
</p>

<p>
A big thank you to everyone!
</p>
</div>
</div>
